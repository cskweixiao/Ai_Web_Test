
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ai_prompts
 * 
 */
export type ai_prompts = $Result.DefaultSelection<Prisma.$ai_promptsPayload>
/**
 * Model ai_runs
 * 
 */
export type ai_runs = $Result.DefaultSelection<Prisma.$ai_runsPayload>
/**
 * Model api_tokens
 * 
 */
export type api_tokens = $Result.DefaultSelection<Prisma.$api_tokensPayload>
/**
 * Model attachments
 * 
 */
export type attachments = $Result.DefaultSelection<Prisma.$attachmentsPayload>
/**
 * Model audit_logs
 * 
 */
export type audit_logs = $Result.DefaultSelection<Prisma.$audit_logsPayload>
/**
 * Model feature_flags
 * 
 */
export type feature_flags = $Result.DefaultSelection<Prisma.$feature_flagsPayload>
/**
 * Model job_logs
 * 
 */
export type job_logs = $Result.DefaultSelection<Prisma.$job_logsPayload>
/**
 * Model metrics_daily
 * 
 */
export type metrics_daily = $Result.DefaultSelection<Prisma.$metrics_dailyPayload>
/**
 * Model reports
 * 
 */
export type reports = $Result.DefaultSelection<Prisma.$reportsPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model settings
 * 
 */
export type settings = $Result.DefaultSelection<Prisma.$settingsPayload>
/**
 * Model step_screenshots
 * 
 */
export type step_screenshots = $Result.DefaultSelection<Prisma.$step_screenshotsPayload>
/**
 * Model suite_case_map
 * 
 */
export type suite_case_map = $Result.DefaultSelection<Prisma.$suite_case_mapPayload>
/**
 * Model test_cases
 * 
 */
export type test_cases = $Result.DefaultSelection<Prisma.$test_casesPayload>
/**
 * Model test_run_results
 * 
 */
export type test_run_results = $Result.DefaultSelection<Prisma.$test_run_resultsPayload>
/**
 * Model test_runs
 * 
 */
export type test_runs = $Result.DefaultSelection<Prisma.$test_runsPayload>
/**
 * Model test_suites
 * 
 */
export type test_suites = $Result.DefaultSelection<Prisma.$test_suitesPayload>
/**
 * Model user_roles
 * 
 */
export type user_roles = $Result.DefaultSelection<Prisma.$user_rolesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model run_artifacts
 * 
 */
export type run_artifacts = $Result.DefaultSelection<Prisma.$run_artifactsPayload>
/**
 * Model case_versions
 * 
 */
export type case_versions = $Result.DefaultSelection<Prisma.$case_versionsPayload>
/**
 * Model bulk_edit_sessions
 * 
 */
export type bulk_edit_sessions = $Result.DefaultSelection<Prisma.$bulk_edit_sessionsPayload>
/**
 * Model case_patch_proposals
 * 
 */
export type case_patch_proposals = $Result.DefaultSelection<Prisma.$case_patch_proposalsPayload>
/**
 * Model test_case_executions
 * 
 */
export type test_case_executions = $Result.DefaultSelection<Prisma.$test_case_executionsPayload>
/**
 * Model functional_test_cases
 * 
 */
export type functional_test_cases = $Result.DefaultSelection<Prisma.$functional_test_casesPayload>
/**
 * Model ai_generation_sessions
 * 
 */
export type ai_generation_sessions = $Result.DefaultSelection<Prisma.$ai_generation_sessionsPayload>
/**
 * Model requirement_documents
 * 
 */
export type requirement_documents = $Result.DefaultSelection<Prisma.$requirement_documentsPayload>
/**
 * Model systems
 * 
 */
export type systems = $Result.DefaultSelection<Prisma.$systemsPayload>
/**
 * Model project_versions
 * 
 */
export type project_versions = $Result.DefaultSelection<Prisma.$project_versionsPayload>
/**
 * Model functional_test_executions
 * 
 */
export type functional_test_executions = $Result.DefaultSelection<Prisma.$functional_test_executionsPayload>
/**
 * Model test_plans
 * 
 */
export type test_plans = $Result.DefaultSelection<Prisma.$test_plansPayload>
/**
 * Model test_plan_cases
 * 
 */
export type test_plan_cases = $Result.DefaultSelection<Prisma.$test_plan_casesPayload>
/**
 * Model test_plan_executions
 * 
 */
export type test_plan_executions = $Result.DefaultSelection<Prisma.$test_plan_executionsPayload>
/**
 * Model ai_element_cache
 * 
 */
export type ai_element_cache = $Result.DefaultSelection<Prisma.$ai_element_cachePayload>
/**
 * Model ai_assertion_cache
 * 
 */
export type ai_assertion_cache = $Result.DefaultSelection<Prisma.$ai_assertion_cachePayload>
/**
 * Model ai_operation_cache
 * 
 */
export type ai_operation_cache = $Result.DefaultSelection<Prisma.$ai_operation_cachePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const job_logs_status: {
  STARTED: 'STARTED',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED'
};

export type job_logs_status = (typeof job_logs_status)[keyof typeof job_logs_status]


export const test_run_results_status: {
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  SKIPPED: 'SKIPPED'
};

export type test_run_results_status = (typeof test_run_results_status)[keyof typeof test_run_results_status]


export const test_runs_status: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type test_runs_status = (typeof test_runs_status)[keyof typeof test_runs_status]


export const step_screenshots_status: {
  success: 'success',
  failed: 'failed',
  error: 'error',
  completed: 'completed'
};

export type step_screenshots_status = (typeof step_screenshots_status)[keyof typeof step_screenshots_status]


export const bulk_edit_sessions_status: {
  dry_run: 'dry_run',
  applied: 'applied',
  cancelled: 'cancelled',
  failed: 'failed'
};

export type bulk_edit_sessions_status = (typeof bulk_edit_sessions_status)[keyof typeof bulk_edit_sessions_status]


export const proposal_risk_level: {
  low: 'low',
  medium: 'medium',
  high: 'high'
};

export type proposal_risk_level = (typeof proposal_risk_level)[keyof typeof proposal_risk_level]


export const proposal_apply_status: {
  pending: 'pending',
  applied: 'applied',
  skipped: 'skipped',
  conflicted: 'conflicted'
};

export type proposal_apply_status = (typeof proposal_apply_status)[keyof typeof proposal_apply_status]


export const test_case_execution_status: {
  queued: 'queued',
  running: 'running',
  completed: 'completed',
  failed: 'failed',
  cancelled: 'cancelled',
  error: 'error'
};

export type test_case_execution_status = (typeof test_case_execution_status)[keyof typeof test_case_execution_status]


export const functional_risk_level: {
  low: 'low',
  medium: 'medium',
  high: 'high'
};

export type functional_risk_level = (typeof functional_risk_level)[keyof typeof functional_risk_level]


export const requirement_doc_status: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED',
  DELETED: 'DELETED'
};

export type requirement_doc_status = (typeof requirement_doc_status)[keyof typeof requirement_doc_status]


export const functional_test_priority: {
  low: 'low',
  medium: 'medium',
  high: 'high',
  critical: 'critical'
};

export type functional_test_priority = (typeof functional_test_priority)[keyof typeof functional_test_priority]


export const functional_test_status: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type functional_test_status = (typeof functional_test_status)[keyof typeof functional_test_status]


export const functional_test_source: {
  MANUAL: 'MANUAL',
  AI_GENERATED: 'AI_GENERATED'
};

export type functional_test_source = (typeof functional_test_source)[keyof typeof functional_test_source]


export const functional_case_type: {
  SMOKE: 'SMOKE',
  FULL: 'FULL',
  ABNORMAL: 'ABNORMAL',
  BOUNDARY: 'BOUNDARY',
  PERFORMANCE: 'PERFORMANCE',
  SECURITY: 'SECURITY',
  USABILITY: 'USABILITY',
  COMPATIBILITY: 'COMPATIBILITY'
};

export type functional_case_type = (typeof functional_case_type)[keyof typeof functional_case_type]


export const functional_execution_result: {
  pass: 'pass',
  fail: 'fail',
  block: 'block'
};

export type functional_execution_result = (typeof functional_execution_result)[keyof typeof functional_execution_result]


export const system_status: {
  active: 'active',
  inactive: 'inactive'
};

export type system_status = (typeof system_status)[keyof typeof system_status]


export const test_plan_status: {
  draft: 'draft',
  not_started: 'not_started',
  active: 'active',
  completed: 'completed',
  expired: 'expired',
  cancelled: 'cancelled',
  archived: 'archived'
};

export type test_plan_status = (typeof test_plan_status)[keyof typeof test_plan_status]


export const test_plan_type: {
  functional: 'functional',
  ui_auto: 'ui_auto',
  mixed: 'mixed',
  regression: 'regression',
  smoke: 'smoke',
  integration: 'integration'
};

export type test_plan_type = (typeof test_plan_type)[keyof typeof test_plan_type]

}

export type job_logs_status = $Enums.job_logs_status

export const job_logs_status: typeof $Enums.job_logs_status

export type test_run_results_status = $Enums.test_run_results_status

export const test_run_results_status: typeof $Enums.test_run_results_status

export type test_runs_status = $Enums.test_runs_status

export const test_runs_status: typeof $Enums.test_runs_status

export type step_screenshots_status = $Enums.step_screenshots_status

export const step_screenshots_status: typeof $Enums.step_screenshots_status

export type bulk_edit_sessions_status = $Enums.bulk_edit_sessions_status

export const bulk_edit_sessions_status: typeof $Enums.bulk_edit_sessions_status

export type proposal_risk_level = $Enums.proposal_risk_level

export const proposal_risk_level: typeof $Enums.proposal_risk_level

export type proposal_apply_status = $Enums.proposal_apply_status

export const proposal_apply_status: typeof $Enums.proposal_apply_status

export type test_case_execution_status = $Enums.test_case_execution_status

export const test_case_execution_status: typeof $Enums.test_case_execution_status

export type functional_risk_level = $Enums.functional_risk_level

export const functional_risk_level: typeof $Enums.functional_risk_level

export type requirement_doc_status = $Enums.requirement_doc_status

export const requirement_doc_status: typeof $Enums.requirement_doc_status

export type functional_test_priority = $Enums.functional_test_priority

export const functional_test_priority: typeof $Enums.functional_test_priority

export type functional_test_status = $Enums.functional_test_status

export const functional_test_status: typeof $Enums.functional_test_status

export type functional_test_source = $Enums.functional_test_source

export const functional_test_source: typeof $Enums.functional_test_source

export type functional_case_type = $Enums.functional_case_type

export const functional_case_type: typeof $Enums.functional_case_type

export type functional_execution_result = $Enums.functional_execution_result

export const functional_execution_result: typeof $Enums.functional_execution_result

export type system_status = $Enums.system_status

export const system_status: typeof $Enums.system_status

export type test_plan_status = $Enums.test_plan_status

export const test_plan_status: typeof $Enums.test_plan_status

export type test_plan_type = $Enums.test_plan_type

export const test_plan_type: typeof $Enums.test_plan_type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ai_prompts
 * const ai_prompts = await prisma.ai_prompts.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ai_prompts
   * const ai_prompts = await prisma.ai_prompts.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.ai_prompts`: Exposes CRUD operations for the **ai_prompts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_prompts
    * const ai_prompts = await prisma.ai_prompts.findMany()
    * ```
    */
  get ai_prompts(): Prisma.ai_promptsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_runs`: Exposes CRUD operations for the **ai_runs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_runs
    * const ai_runs = await prisma.ai_runs.findMany()
    * ```
    */
  get ai_runs(): Prisma.ai_runsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.api_tokens`: Exposes CRUD operations for the **api_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Api_tokens
    * const api_tokens = await prisma.api_tokens.findMany()
    * ```
    */
  get api_tokens(): Prisma.api_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachments`: Exposes CRUD operations for the **attachments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachments.findMany()
    * ```
    */
  get attachments(): Prisma.attachmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit_logs`: Exposes CRUD operations for the **audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_logs
    * const audit_logs = await prisma.audit_logs.findMany()
    * ```
    */
  get audit_logs(): Prisma.audit_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feature_flags`: Exposes CRUD operations for the **feature_flags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feature_flags
    * const feature_flags = await prisma.feature_flags.findMany()
    * ```
    */
  get feature_flags(): Prisma.feature_flagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_logs`: Exposes CRUD operations for the **job_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_logs
    * const job_logs = await prisma.job_logs.findMany()
    * ```
    */
  get job_logs(): Prisma.job_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metrics_daily`: Exposes CRUD operations for the **metrics_daily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metrics_dailies
    * const metrics_dailies = await prisma.metrics_daily.findMany()
    * ```
    */
  get metrics_daily(): Prisma.metrics_dailyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reports`: Exposes CRUD operations for the **reports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.reports.findMany()
    * ```
    */
  get reports(): Prisma.reportsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.step_screenshots`: Exposes CRUD operations for the **step_screenshots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Step_screenshots
    * const step_screenshots = await prisma.step_screenshots.findMany()
    * ```
    */
  get step_screenshots(): Prisma.step_screenshotsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suite_case_map`: Exposes CRUD operations for the **suite_case_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suite_case_maps
    * const suite_case_maps = await prisma.suite_case_map.findMany()
    * ```
    */
  get suite_case_map(): Prisma.suite_case_mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_cases`: Exposes CRUD operations for the **test_cases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_cases
    * const test_cases = await prisma.test_cases.findMany()
    * ```
    */
  get test_cases(): Prisma.test_casesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_run_results`: Exposes CRUD operations for the **test_run_results** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_run_results
    * const test_run_results = await prisma.test_run_results.findMany()
    * ```
    */
  get test_run_results(): Prisma.test_run_resultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_runs`: Exposes CRUD operations for the **test_runs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_runs
    * const test_runs = await prisma.test_runs.findMany()
    * ```
    */
  get test_runs(): Prisma.test_runsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_suites`: Exposes CRUD operations for the **test_suites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_suites
    * const test_suites = await prisma.test_suites.findMany()
    * ```
    */
  get test_suites(): Prisma.test_suitesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_roles`: Exposes CRUD operations for the **user_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_roles.findMany()
    * ```
    */
  get user_roles(): Prisma.user_rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.run_artifacts`: Exposes CRUD operations for the **run_artifacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Run_artifacts
    * const run_artifacts = await prisma.run_artifacts.findMany()
    * ```
    */
  get run_artifacts(): Prisma.run_artifactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.case_versions`: Exposes CRUD operations for the **case_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Case_versions
    * const case_versions = await prisma.case_versions.findMany()
    * ```
    */
  get case_versions(): Prisma.case_versionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bulk_edit_sessions`: Exposes CRUD operations for the **bulk_edit_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bulk_edit_sessions
    * const bulk_edit_sessions = await prisma.bulk_edit_sessions.findMany()
    * ```
    */
  get bulk_edit_sessions(): Prisma.bulk_edit_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.case_patch_proposals`: Exposes CRUD operations for the **case_patch_proposals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Case_patch_proposals
    * const case_patch_proposals = await prisma.case_patch_proposals.findMany()
    * ```
    */
  get case_patch_proposals(): Prisma.case_patch_proposalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_case_executions`: Exposes CRUD operations for the **test_case_executions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_case_executions
    * const test_case_executions = await prisma.test_case_executions.findMany()
    * ```
    */
  get test_case_executions(): Prisma.test_case_executionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.functional_test_cases`: Exposes CRUD operations for the **functional_test_cases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Functional_test_cases
    * const functional_test_cases = await prisma.functional_test_cases.findMany()
    * ```
    */
  get functional_test_cases(): Prisma.functional_test_casesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_generation_sessions`: Exposes CRUD operations for the **ai_generation_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_generation_sessions
    * const ai_generation_sessions = await prisma.ai_generation_sessions.findMany()
    * ```
    */
  get ai_generation_sessions(): Prisma.ai_generation_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirement_documents`: Exposes CRUD operations for the **requirement_documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requirement_documents
    * const requirement_documents = await prisma.requirement_documents.findMany()
    * ```
    */
  get requirement_documents(): Prisma.requirement_documentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systems`: Exposes CRUD operations for the **systems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Systems
    * const systems = await prisma.systems.findMany()
    * ```
    */
  get systems(): Prisma.systemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project_versions`: Exposes CRUD operations for the **project_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Project_versions
    * const project_versions = await prisma.project_versions.findMany()
    * ```
    */
  get project_versions(): Prisma.project_versionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.functional_test_executions`: Exposes CRUD operations for the **functional_test_executions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Functional_test_executions
    * const functional_test_executions = await prisma.functional_test_executions.findMany()
    * ```
    */
  get functional_test_executions(): Prisma.functional_test_executionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_plans`: Exposes CRUD operations for the **test_plans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_plans
    * const test_plans = await prisma.test_plans.findMany()
    * ```
    */
  get test_plans(): Prisma.test_plansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_plan_cases`: Exposes CRUD operations for the **test_plan_cases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_plan_cases
    * const test_plan_cases = await prisma.test_plan_cases.findMany()
    * ```
    */
  get test_plan_cases(): Prisma.test_plan_casesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_plan_executions`: Exposes CRUD operations for the **test_plan_executions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_plan_executions
    * const test_plan_executions = await prisma.test_plan_executions.findMany()
    * ```
    */
  get test_plan_executions(): Prisma.test_plan_executionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_element_cache`: Exposes CRUD operations for the **ai_element_cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_element_caches
    * const ai_element_caches = await prisma.ai_element_cache.findMany()
    * ```
    */
  get ai_element_cache(): Prisma.ai_element_cacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_assertion_cache`: Exposes CRUD operations for the **ai_assertion_cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_assertion_caches
    * const ai_assertion_caches = await prisma.ai_assertion_cache.findMany()
    * ```
    */
  get ai_assertion_cache(): Prisma.ai_assertion_cacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_operation_cache`: Exposes CRUD operations for the **ai_operation_cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_operation_caches
    * const ai_operation_caches = await prisma.ai_operation_cache.findMany()
    * ```
    */
  get ai_operation_cache(): Prisma.ai_operation_cacheDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ai_prompts: 'ai_prompts',
    ai_runs: 'ai_runs',
    api_tokens: 'api_tokens',
    attachments: 'attachments',
    audit_logs: 'audit_logs',
    feature_flags: 'feature_flags',
    job_logs: 'job_logs',
    metrics_daily: 'metrics_daily',
    reports: 'reports',
    roles: 'roles',
    settings: 'settings',
    step_screenshots: 'step_screenshots',
    suite_case_map: 'suite_case_map',
    test_cases: 'test_cases',
    test_run_results: 'test_run_results',
    test_runs: 'test_runs',
    test_suites: 'test_suites',
    user_roles: 'user_roles',
    users: 'users',
    run_artifacts: 'run_artifacts',
    case_versions: 'case_versions',
    bulk_edit_sessions: 'bulk_edit_sessions',
    case_patch_proposals: 'case_patch_proposals',
    test_case_executions: 'test_case_executions',
    functional_test_cases: 'functional_test_cases',
    ai_generation_sessions: 'ai_generation_sessions',
    requirement_documents: 'requirement_documents',
    systems: 'systems',
    project_versions: 'project_versions',
    functional_test_executions: 'functional_test_executions',
    test_plans: 'test_plans',
    test_plan_cases: 'test_plan_cases',
    test_plan_executions: 'test_plan_executions',
    ai_element_cache: 'ai_element_cache',
    ai_assertion_cache: 'ai_assertion_cache',
    ai_operation_cache: 'ai_operation_cache'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "ai_prompts" | "ai_runs" | "api_tokens" | "attachments" | "audit_logs" | "feature_flags" | "job_logs" | "metrics_daily" | "reports" | "roles" | "settings" | "step_screenshots" | "suite_case_map" | "test_cases" | "test_run_results" | "test_runs" | "test_suites" | "user_roles" | "users" | "run_artifacts" | "case_versions" | "bulk_edit_sessions" | "case_patch_proposals" | "test_case_executions" | "functional_test_cases" | "ai_generation_sessions" | "requirement_documents" | "systems" | "project_versions" | "functional_test_executions" | "test_plans" | "test_plan_cases" | "test_plan_executions" | "ai_element_cache" | "ai_assertion_cache" | "ai_operation_cache"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ai_prompts: {
        payload: Prisma.$ai_promptsPayload<ExtArgs>
        fields: Prisma.ai_promptsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_promptsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_promptsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload>
          }
          findFirst: {
            args: Prisma.ai_promptsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_promptsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload>
          }
          findMany: {
            args: Prisma.ai_promptsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload>[]
          }
          create: {
            args: Prisma.ai_promptsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload>
          }
          createMany: {
            args: Prisma.ai_promptsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ai_promptsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload>
          }
          update: {
            args: Prisma.ai_promptsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload>
          }
          deleteMany: {
            args: Prisma.ai_promptsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_promptsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_promptsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_promptsPayload>
          }
          aggregate: {
            args: Prisma.Ai_promptsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_prompts>
          }
          groupBy: {
            args: Prisma.ai_promptsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_promptsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_promptsCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_promptsCountAggregateOutputType> | number
          }
        }
      }
      ai_runs: {
        payload: Prisma.$ai_runsPayload<ExtArgs>
        fields: Prisma.ai_runsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_runsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_runsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload>
          }
          findFirst: {
            args: Prisma.ai_runsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_runsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload>
          }
          findMany: {
            args: Prisma.ai_runsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload>[]
          }
          create: {
            args: Prisma.ai_runsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload>
          }
          createMany: {
            args: Prisma.ai_runsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ai_runsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload>
          }
          update: {
            args: Prisma.ai_runsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload>
          }
          deleteMany: {
            args: Prisma.ai_runsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_runsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_runsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_runsPayload>
          }
          aggregate: {
            args: Prisma.Ai_runsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_runs>
          }
          groupBy: {
            args: Prisma.ai_runsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_runsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_runsCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_runsCountAggregateOutputType> | number
          }
        }
      }
      api_tokens: {
        payload: Prisma.$api_tokensPayload<ExtArgs>
        fields: Prisma.api_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.api_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.api_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload>
          }
          findFirst: {
            args: Prisma.api_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.api_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload>
          }
          findMany: {
            args: Prisma.api_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload>[]
          }
          create: {
            args: Prisma.api_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload>
          }
          createMany: {
            args: Prisma.api_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.api_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload>
          }
          update: {
            args: Prisma.api_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload>
          }
          deleteMany: {
            args: Prisma.api_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.api_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.api_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_tokensPayload>
          }
          aggregate: {
            args: Prisma.Api_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApi_tokens>
          }
          groupBy: {
            args: Prisma.api_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Api_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.api_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Api_tokensCountAggregateOutputType> | number
          }
        }
      }
      attachments: {
        payload: Prisma.$attachmentsPayload<ExtArgs>
        fields: Prisma.attachmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attachmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attachmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          findFirst: {
            args: Prisma.attachmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attachmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          findMany: {
            args: Prisma.attachmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>[]
          }
          create: {
            args: Prisma.attachmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          createMany: {
            args: Prisma.attachmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attachmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          update: {
            args: Prisma.attachmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          deleteMany: {
            args: Prisma.attachmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attachmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attachmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          aggregate: {
            args: Prisma.AttachmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachments>
          }
          groupBy: {
            args: Prisma.attachmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.attachmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentsCountAggregateOutputType> | number
          }
        }
      }
      audit_logs: {
        payload: Prisma.$audit_logsPayload<ExtArgs>
        fields: Prisma.audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findFirst: {
            args: Prisma.audit_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findMany: {
            args: Prisma.audit_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          create: {
            args: Prisma.audit_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          createMany: {
            args: Prisma.audit_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.audit_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          update: {
            args: Prisma.audit_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.audit_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.audit_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Audit_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_logs>
          }
          groupBy: {
            args: Prisma.audit_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsCountAggregateOutputType> | number
          }
        }
      }
      feature_flags: {
        payload: Prisma.$feature_flagsPayload<ExtArgs>
        fields: Prisma.feature_flagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feature_flagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feature_flagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload>
          }
          findFirst: {
            args: Prisma.feature_flagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feature_flagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload>
          }
          findMany: {
            args: Prisma.feature_flagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload>[]
          }
          create: {
            args: Prisma.feature_flagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload>
          }
          createMany: {
            args: Prisma.feature_flagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.feature_flagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload>
          }
          update: {
            args: Prisma.feature_flagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload>
          }
          deleteMany: {
            args: Prisma.feature_flagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feature_flagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.feature_flagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feature_flagsPayload>
          }
          aggregate: {
            args: Prisma.Feature_flagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature_flags>
          }
          groupBy: {
            args: Prisma.feature_flagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Feature_flagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.feature_flagsCountArgs<ExtArgs>
            result: $Utils.Optional<Feature_flagsCountAggregateOutputType> | number
          }
        }
      }
      job_logs: {
        payload: Prisma.$job_logsPayload<ExtArgs>
        fields: Prisma.job_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload>
          }
          findFirst: {
            args: Prisma.job_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload>
          }
          findMany: {
            args: Prisma.job_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload>[]
          }
          create: {
            args: Prisma.job_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload>
          }
          createMany: {
            args: Prisma.job_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.job_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload>
          }
          update: {
            args: Prisma.job_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload>
          }
          deleteMany: {
            args: Prisma.job_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.job_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_logsPayload>
          }
          aggregate: {
            args: Prisma.Job_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_logs>
          }
          groupBy: {
            args: Prisma.job_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Job_logsCountAggregateOutputType> | number
          }
        }
      }
      metrics_daily: {
        payload: Prisma.$metrics_dailyPayload<ExtArgs>
        fields: Prisma.metrics_dailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.metrics_dailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.metrics_dailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload>
          }
          findFirst: {
            args: Prisma.metrics_dailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.metrics_dailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload>
          }
          findMany: {
            args: Prisma.metrics_dailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload>[]
          }
          create: {
            args: Prisma.metrics_dailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload>
          }
          createMany: {
            args: Prisma.metrics_dailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.metrics_dailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload>
          }
          update: {
            args: Prisma.metrics_dailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload>
          }
          deleteMany: {
            args: Prisma.metrics_dailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.metrics_dailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.metrics_dailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metrics_dailyPayload>
          }
          aggregate: {
            args: Prisma.Metrics_dailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetrics_daily>
          }
          groupBy: {
            args: Prisma.metrics_dailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Metrics_dailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.metrics_dailyCountArgs<ExtArgs>
            result: $Utils.Optional<Metrics_dailyCountAggregateOutputType> | number
          }
        }
      }
      reports: {
        payload: Prisma.$reportsPayload<ExtArgs>
        fields: Prisma.reportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          findFirst: {
            args: Prisma.reportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          findMany: {
            args: Prisma.reportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>[]
          }
          create: {
            args: Prisma.reportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          createMany: {
            args: Prisma.reportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          update: {
            args: Prisma.reportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          deleteMany: {
            args: Prisma.reportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          aggregate: {
            args: Prisma.ReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReports>
          }
          groupBy: {
            args: Prisma.reportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportsCountArgs<ExtArgs>
            result: $Utils.Optional<ReportsCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      settings: {
        payload: Prisma.$settingsPayload<ExtArgs>
        fields: Prisma.settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findFirst: {
            args: Prisma.settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findMany: {
            args: Prisma.settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          create: {
            args: Prisma.settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          createMany: {
            args: Prisma.settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          update: {
            args: Prisma.settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          deleteMany: {
            args: Prisma.settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.settingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      step_screenshots: {
        payload: Prisma.$step_screenshotsPayload<ExtArgs>
        fields: Prisma.step_screenshotsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.step_screenshotsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.step_screenshotsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload>
          }
          findFirst: {
            args: Prisma.step_screenshotsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.step_screenshotsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload>
          }
          findMany: {
            args: Prisma.step_screenshotsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload>[]
          }
          create: {
            args: Prisma.step_screenshotsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload>
          }
          createMany: {
            args: Prisma.step_screenshotsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.step_screenshotsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload>
          }
          update: {
            args: Prisma.step_screenshotsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload>
          }
          deleteMany: {
            args: Prisma.step_screenshotsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.step_screenshotsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.step_screenshotsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$step_screenshotsPayload>
          }
          aggregate: {
            args: Prisma.Step_screenshotsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStep_screenshots>
          }
          groupBy: {
            args: Prisma.step_screenshotsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Step_screenshotsGroupByOutputType>[]
          }
          count: {
            args: Prisma.step_screenshotsCountArgs<ExtArgs>
            result: $Utils.Optional<Step_screenshotsCountAggregateOutputType> | number
          }
        }
      }
      suite_case_map: {
        payload: Prisma.$suite_case_mapPayload<ExtArgs>
        fields: Prisma.suite_case_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.suite_case_mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.suite_case_mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload>
          }
          findFirst: {
            args: Prisma.suite_case_mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.suite_case_mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload>
          }
          findMany: {
            args: Prisma.suite_case_mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload>[]
          }
          create: {
            args: Prisma.suite_case_mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload>
          }
          createMany: {
            args: Prisma.suite_case_mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.suite_case_mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload>
          }
          update: {
            args: Prisma.suite_case_mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload>
          }
          deleteMany: {
            args: Prisma.suite_case_mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.suite_case_mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.suite_case_mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suite_case_mapPayload>
          }
          aggregate: {
            args: Prisma.Suite_case_mapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuite_case_map>
          }
          groupBy: {
            args: Prisma.suite_case_mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Suite_case_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.suite_case_mapCountArgs<ExtArgs>
            result: $Utils.Optional<Suite_case_mapCountAggregateOutputType> | number
          }
        }
      }
      test_cases: {
        payload: Prisma.$test_casesPayload<ExtArgs>
        fields: Prisma.test_casesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_casesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_casesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload>
          }
          findFirst: {
            args: Prisma.test_casesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_casesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload>
          }
          findMany: {
            args: Prisma.test_casesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload>[]
          }
          create: {
            args: Prisma.test_casesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload>
          }
          createMany: {
            args: Prisma.test_casesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_casesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload>
          }
          update: {
            args: Prisma.test_casesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload>
          }
          deleteMany: {
            args: Prisma.test_casesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_casesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_casesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_casesPayload>
          }
          aggregate: {
            args: Prisma.Test_casesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_cases>
          }
          groupBy: {
            args: Prisma.test_casesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_casesGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_casesCountArgs<ExtArgs>
            result: $Utils.Optional<Test_casesCountAggregateOutputType> | number
          }
        }
      }
      test_run_results: {
        payload: Prisma.$test_run_resultsPayload<ExtArgs>
        fields: Prisma.test_run_resultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_run_resultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_run_resultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload>
          }
          findFirst: {
            args: Prisma.test_run_resultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_run_resultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload>
          }
          findMany: {
            args: Prisma.test_run_resultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload>[]
          }
          create: {
            args: Prisma.test_run_resultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload>
          }
          createMany: {
            args: Prisma.test_run_resultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_run_resultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload>
          }
          update: {
            args: Prisma.test_run_resultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload>
          }
          deleteMany: {
            args: Prisma.test_run_resultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_run_resultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_run_resultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_run_resultsPayload>
          }
          aggregate: {
            args: Prisma.Test_run_resultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_run_results>
          }
          groupBy: {
            args: Prisma.test_run_resultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_run_resultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_run_resultsCountArgs<ExtArgs>
            result: $Utils.Optional<Test_run_resultsCountAggregateOutputType> | number
          }
        }
      }
      test_runs: {
        payload: Prisma.$test_runsPayload<ExtArgs>
        fields: Prisma.test_runsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_runsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_runsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload>
          }
          findFirst: {
            args: Prisma.test_runsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_runsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload>
          }
          findMany: {
            args: Prisma.test_runsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload>[]
          }
          create: {
            args: Prisma.test_runsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload>
          }
          createMany: {
            args: Prisma.test_runsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_runsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload>
          }
          update: {
            args: Prisma.test_runsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload>
          }
          deleteMany: {
            args: Prisma.test_runsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_runsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_runsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_runsPayload>
          }
          aggregate: {
            args: Prisma.Test_runsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_runs>
          }
          groupBy: {
            args: Prisma.test_runsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_runsGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_runsCountArgs<ExtArgs>
            result: $Utils.Optional<Test_runsCountAggregateOutputType> | number
          }
        }
      }
      test_suites: {
        payload: Prisma.$test_suitesPayload<ExtArgs>
        fields: Prisma.test_suitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_suitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_suitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload>
          }
          findFirst: {
            args: Prisma.test_suitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_suitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload>
          }
          findMany: {
            args: Prisma.test_suitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload>[]
          }
          create: {
            args: Prisma.test_suitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload>
          }
          createMany: {
            args: Prisma.test_suitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_suitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload>
          }
          update: {
            args: Prisma.test_suitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload>
          }
          deleteMany: {
            args: Prisma.test_suitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_suitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_suitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_suitesPayload>
          }
          aggregate: {
            args: Prisma.Test_suitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_suites>
          }
          groupBy: {
            args: Prisma.test_suitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_suitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_suitesCountArgs<ExtArgs>
            result: $Utils.Optional<Test_suitesCountAggregateOutputType> | number
          }
        }
      }
      user_roles: {
        payload: Prisma.$user_rolesPayload<ExtArgs>
        fields: Prisma.user_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findFirst: {
            args: Prisma.user_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findMany: {
            args: Prisma.user_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          create: {
            args: Prisma.user_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          createMany: {
            args: Prisma.user_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          update: {
            args: Prisma.user_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          deleteMany: {
            args: Prisma.user_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          aggregate: {
            args: Prisma.User_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_roles>
          }
          groupBy: {
            args: Prisma.user_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<User_rolesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      run_artifacts: {
        payload: Prisma.$run_artifactsPayload<ExtArgs>
        fields: Prisma.run_artifactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.run_artifactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.run_artifactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload>
          }
          findFirst: {
            args: Prisma.run_artifactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.run_artifactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload>
          }
          findMany: {
            args: Prisma.run_artifactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload>[]
          }
          create: {
            args: Prisma.run_artifactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload>
          }
          createMany: {
            args: Prisma.run_artifactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.run_artifactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload>
          }
          update: {
            args: Prisma.run_artifactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload>
          }
          deleteMany: {
            args: Prisma.run_artifactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.run_artifactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.run_artifactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$run_artifactsPayload>
          }
          aggregate: {
            args: Prisma.Run_artifactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRun_artifacts>
          }
          groupBy: {
            args: Prisma.run_artifactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Run_artifactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.run_artifactsCountArgs<ExtArgs>
            result: $Utils.Optional<Run_artifactsCountAggregateOutputType> | number
          }
        }
      }
      case_versions: {
        payload: Prisma.$case_versionsPayload<ExtArgs>
        fields: Prisma.case_versionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.case_versionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.case_versionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload>
          }
          findFirst: {
            args: Prisma.case_versionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.case_versionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload>
          }
          findMany: {
            args: Prisma.case_versionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload>[]
          }
          create: {
            args: Prisma.case_versionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload>
          }
          createMany: {
            args: Prisma.case_versionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.case_versionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload>
          }
          update: {
            args: Prisma.case_versionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload>
          }
          deleteMany: {
            args: Prisma.case_versionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.case_versionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.case_versionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_versionsPayload>
          }
          aggregate: {
            args: Prisma.Case_versionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCase_versions>
          }
          groupBy: {
            args: Prisma.case_versionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Case_versionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.case_versionsCountArgs<ExtArgs>
            result: $Utils.Optional<Case_versionsCountAggregateOutputType> | number
          }
        }
      }
      bulk_edit_sessions: {
        payload: Prisma.$bulk_edit_sessionsPayload<ExtArgs>
        fields: Prisma.bulk_edit_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bulk_edit_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bulk_edit_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload>
          }
          findFirst: {
            args: Prisma.bulk_edit_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bulk_edit_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload>
          }
          findMany: {
            args: Prisma.bulk_edit_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload>[]
          }
          create: {
            args: Prisma.bulk_edit_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload>
          }
          createMany: {
            args: Prisma.bulk_edit_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bulk_edit_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload>
          }
          update: {
            args: Prisma.bulk_edit_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.bulk_edit_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bulk_edit_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bulk_edit_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bulk_edit_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Bulk_edit_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBulk_edit_sessions>
          }
          groupBy: {
            args: Prisma.bulk_edit_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bulk_edit_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bulk_edit_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Bulk_edit_sessionsCountAggregateOutputType> | number
          }
        }
      }
      case_patch_proposals: {
        payload: Prisma.$case_patch_proposalsPayload<ExtArgs>
        fields: Prisma.case_patch_proposalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.case_patch_proposalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.case_patch_proposalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload>
          }
          findFirst: {
            args: Prisma.case_patch_proposalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.case_patch_proposalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload>
          }
          findMany: {
            args: Prisma.case_patch_proposalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload>[]
          }
          create: {
            args: Prisma.case_patch_proposalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload>
          }
          createMany: {
            args: Prisma.case_patch_proposalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.case_patch_proposalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload>
          }
          update: {
            args: Prisma.case_patch_proposalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload>
          }
          deleteMany: {
            args: Prisma.case_patch_proposalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.case_patch_proposalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.case_patch_proposalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_patch_proposalsPayload>
          }
          aggregate: {
            args: Prisma.Case_patch_proposalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCase_patch_proposals>
          }
          groupBy: {
            args: Prisma.case_patch_proposalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Case_patch_proposalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.case_patch_proposalsCountArgs<ExtArgs>
            result: $Utils.Optional<Case_patch_proposalsCountAggregateOutputType> | number
          }
        }
      }
      test_case_executions: {
        payload: Prisma.$test_case_executionsPayload<ExtArgs>
        fields: Prisma.test_case_executionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_case_executionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_case_executionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload>
          }
          findFirst: {
            args: Prisma.test_case_executionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_case_executionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload>
          }
          findMany: {
            args: Prisma.test_case_executionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload>[]
          }
          create: {
            args: Prisma.test_case_executionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload>
          }
          createMany: {
            args: Prisma.test_case_executionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_case_executionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload>
          }
          update: {
            args: Prisma.test_case_executionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload>
          }
          deleteMany: {
            args: Prisma.test_case_executionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_case_executionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_case_executionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_case_executionsPayload>
          }
          aggregate: {
            args: Prisma.Test_case_executionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_case_executions>
          }
          groupBy: {
            args: Prisma.test_case_executionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_case_executionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_case_executionsCountArgs<ExtArgs>
            result: $Utils.Optional<Test_case_executionsCountAggregateOutputType> | number
          }
        }
      }
      functional_test_cases: {
        payload: Prisma.$functional_test_casesPayload<ExtArgs>
        fields: Prisma.functional_test_casesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.functional_test_casesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.functional_test_casesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload>
          }
          findFirst: {
            args: Prisma.functional_test_casesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.functional_test_casesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload>
          }
          findMany: {
            args: Prisma.functional_test_casesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload>[]
          }
          create: {
            args: Prisma.functional_test_casesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload>
          }
          createMany: {
            args: Prisma.functional_test_casesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.functional_test_casesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload>
          }
          update: {
            args: Prisma.functional_test_casesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload>
          }
          deleteMany: {
            args: Prisma.functional_test_casesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.functional_test_casesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.functional_test_casesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_casesPayload>
          }
          aggregate: {
            args: Prisma.Functional_test_casesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunctional_test_cases>
          }
          groupBy: {
            args: Prisma.functional_test_casesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Functional_test_casesGroupByOutputType>[]
          }
          count: {
            args: Prisma.functional_test_casesCountArgs<ExtArgs>
            result: $Utils.Optional<Functional_test_casesCountAggregateOutputType> | number
          }
        }
      }
      ai_generation_sessions: {
        payload: Prisma.$ai_generation_sessionsPayload<ExtArgs>
        fields: Prisma.ai_generation_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_generation_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_generation_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload>
          }
          findFirst: {
            args: Prisma.ai_generation_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_generation_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload>
          }
          findMany: {
            args: Prisma.ai_generation_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload>[]
          }
          create: {
            args: Prisma.ai_generation_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload>
          }
          createMany: {
            args: Prisma.ai_generation_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ai_generation_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload>
          }
          update: {
            args: Prisma.ai_generation_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.ai_generation_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_generation_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_generation_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_generation_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Ai_generation_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_generation_sessions>
          }
          groupBy: {
            args: Prisma.ai_generation_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_generation_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_generation_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_generation_sessionsCountAggregateOutputType> | number
          }
        }
      }
      requirement_documents: {
        payload: Prisma.$requirement_documentsPayload<ExtArgs>
        fields: Prisma.requirement_documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.requirement_documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.requirement_documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload>
          }
          findFirst: {
            args: Prisma.requirement_documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.requirement_documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload>
          }
          findMany: {
            args: Prisma.requirement_documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload>[]
          }
          create: {
            args: Prisma.requirement_documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload>
          }
          createMany: {
            args: Prisma.requirement_documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.requirement_documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload>
          }
          update: {
            args: Prisma.requirement_documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload>
          }
          deleteMany: {
            args: Prisma.requirement_documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.requirement_documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.requirement_documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirement_documentsPayload>
          }
          aggregate: {
            args: Prisma.Requirement_documentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirement_documents>
          }
          groupBy: {
            args: Prisma.requirement_documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Requirement_documentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.requirement_documentsCountArgs<ExtArgs>
            result: $Utils.Optional<Requirement_documentsCountAggregateOutputType> | number
          }
        }
      }
      systems: {
        payload: Prisma.$systemsPayload<ExtArgs>
        fields: Prisma.systemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.systemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.systemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload>
          }
          findFirst: {
            args: Prisma.systemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.systemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload>
          }
          findMany: {
            args: Prisma.systemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload>[]
          }
          create: {
            args: Prisma.systemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload>
          }
          createMany: {
            args: Prisma.systemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.systemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload>
          }
          update: {
            args: Prisma.systemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload>
          }
          deleteMany: {
            args: Prisma.systemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.systemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.systemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemsPayload>
          }
          aggregate: {
            args: Prisma.SystemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystems>
          }
          groupBy: {
            args: Prisma.systemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.systemsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemsCountAggregateOutputType> | number
          }
        }
      }
      project_versions: {
        payload: Prisma.$project_versionsPayload<ExtArgs>
        fields: Prisma.project_versionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.project_versionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.project_versionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload>
          }
          findFirst: {
            args: Prisma.project_versionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.project_versionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload>
          }
          findMany: {
            args: Prisma.project_versionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload>[]
          }
          create: {
            args: Prisma.project_versionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload>
          }
          createMany: {
            args: Prisma.project_versionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.project_versionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload>
          }
          update: {
            args: Prisma.project_versionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload>
          }
          deleteMany: {
            args: Prisma.project_versionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.project_versionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.project_versionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_versionsPayload>
          }
          aggregate: {
            args: Prisma.Project_versionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject_versions>
          }
          groupBy: {
            args: Prisma.project_versionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Project_versionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.project_versionsCountArgs<ExtArgs>
            result: $Utils.Optional<Project_versionsCountAggregateOutputType> | number
          }
        }
      }
      functional_test_executions: {
        payload: Prisma.$functional_test_executionsPayload<ExtArgs>
        fields: Prisma.functional_test_executionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.functional_test_executionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.functional_test_executionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload>
          }
          findFirst: {
            args: Prisma.functional_test_executionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.functional_test_executionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload>
          }
          findMany: {
            args: Prisma.functional_test_executionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload>[]
          }
          create: {
            args: Prisma.functional_test_executionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload>
          }
          createMany: {
            args: Prisma.functional_test_executionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.functional_test_executionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload>
          }
          update: {
            args: Prisma.functional_test_executionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload>
          }
          deleteMany: {
            args: Prisma.functional_test_executionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.functional_test_executionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.functional_test_executionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functional_test_executionsPayload>
          }
          aggregate: {
            args: Prisma.Functional_test_executionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunctional_test_executions>
          }
          groupBy: {
            args: Prisma.functional_test_executionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Functional_test_executionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.functional_test_executionsCountArgs<ExtArgs>
            result: $Utils.Optional<Functional_test_executionsCountAggregateOutputType> | number
          }
        }
      }
      test_plans: {
        payload: Prisma.$test_plansPayload<ExtArgs>
        fields: Prisma.test_plansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_plansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_plansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          findFirst: {
            args: Prisma.test_plansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_plansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          findMany: {
            args: Prisma.test_plansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>[]
          }
          create: {
            args: Prisma.test_plansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          createMany: {
            args: Prisma.test_plansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_plansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          update: {
            args: Prisma.test_plansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          deleteMany: {
            args: Prisma.test_plansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_plansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_plansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plansPayload>
          }
          aggregate: {
            args: Prisma.Test_plansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_plans>
          }
          groupBy: {
            args: Prisma.test_plansGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_plansGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_plansCountArgs<ExtArgs>
            result: $Utils.Optional<Test_plansCountAggregateOutputType> | number
          }
        }
      }
      test_plan_cases: {
        payload: Prisma.$test_plan_casesPayload<ExtArgs>
        fields: Prisma.test_plan_casesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_plan_casesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_plan_casesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload>
          }
          findFirst: {
            args: Prisma.test_plan_casesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_plan_casesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload>
          }
          findMany: {
            args: Prisma.test_plan_casesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload>[]
          }
          create: {
            args: Prisma.test_plan_casesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload>
          }
          createMany: {
            args: Prisma.test_plan_casesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_plan_casesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload>
          }
          update: {
            args: Prisma.test_plan_casesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload>
          }
          deleteMany: {
            args: Prisma.test_plan_casesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_plan_casesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_plan_casesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_casesPayload>
          }
          aggregate: {
            args: Prisma.Test_plan_casesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_plan_cases>
          }
          groupBy: {
            args: Prisma.test_plan_casesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_plan_casesGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_plan_casesCountArgs<ExtArgs>
            result: $Utils.Optional<Test_plan_casesCountAggregateOutputType> | number
          }
        }
      }
      test_plan_executions: {
        payload: Prisma.$test_plan_executionsPayload<ExtArgs>
        fields: Prisma.test_plan_executionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_plan_executionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_plan_executionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload>
          }
          findFirst: {
            args: Prisma.test_plan_executionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_plan_executionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload>
          }
          findMany: {
            args: Prisma.test_plan_executionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload>[]
          }
          create: {
            args: Prisma.test_plan_executionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload>
          }
          createMany: {
            args: Prisma.test_plan_executionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_plan_executionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload>
          }
          update: {
            args: Prisma.test_plan_executionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload>
          }
          deleteMany: {
            args: Prisma.test_plan_executionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_plan_executionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_plan_executionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_plan_executionsPayload>
          }
          aggregate: {
            args: Prisma.Test_plan_executionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_plan_executions>
          }
          groupBy: {
            args: Prisma.test_plan_executionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_plan_executionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_plan_executionsCountArgs<ExtArgs>
            result: $Utils.Optional<Test_plan_executionsCountAggregateOutputType> | number
          }
        }
      }
      ai_element_cache: {
        payload: Prisma.$ai_element_cachePayload<ExtArgs>
        fields: Prisma.ai_element_cacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_element_cacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_element_cacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload>
          }
          findFirst: {
            args: Prisma.ai_element_cacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_element_cacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload>
          }
          findMany: {
            args: Prisma.ai_element_cacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload>[]
          }
          create: {
            args: Prisma.ai_element_cacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload>
          }
          createMany: {
            args: Prisma.ai_element_cacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ai_element_cacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload>
          }
          update: {
            args: Prisma.ai_element_cacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload>
          }
          deleteMany: {
            args: Prisma.ai_element_cacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_element_cacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_element_cacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_element_cachePayload>
          }
          aggregate: {
            args: Prisma.Ai_element_cacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_element_cache>
          }
          groupBy: {
            args: Prisma.ai_element_cacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_element_cacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_element_cacheCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_element_cacheCountAggregateOutputType> | number
          }
        }
      }
      ai_assertion_cache: {
        payload: Prisma.$ai_assertion_cachePayload<ExtArgs>
        fields: Prisma.ai_assertion_cacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_assertion_cacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_assertion_cacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload>
          }
          findFirst: {
            args: Prisma.ai_assertion_cacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_assertion_cacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload>
          }
          findMany: {
            args: Prisma.ai_assertion_cacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload>[]
          }
          create: {
            args: Prisma.ai_assertion_cacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload>
          }
          createMany: {
            args: Prisma.ai_assertion_cacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ai_assertion_cacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload>
          }
          update: {
            args: Prisma.ai_assertion_cacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload>
          }
          deleteMany: {
            args: Prisma.ai_assertion_cacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_assertion_cacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_assertion_cacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assertion_cachePayload>
          }
          aggregate: {
            args: Prisma.Ai_assertion_cacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_assertion_cache>
          }
          groupBy: {
            args: Prisma.ai_assertion_cacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_assertion_cacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_assertion_cacheCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_assertion_cacheCountAggregateOutputType> | number
          }
        }
      }
      ai_operation_cache: {
        payload: Prisma.$ai_operation_cachePayload<ExtArgs>
        fields: Prisma.ai_operation_cacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_operation_cacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_operation_cacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload>
          }
          findFirst: {
            args: Prisma.ai_operation_cacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_operation_cacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload>
          }
          findMany: {
            args: Prisma.ai_operation_cacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload>[]
          }
          create: {
            args: Prisma.ai_operation_cacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload>
          }
          createMany: {
            args: Prisma.ai_operation_cacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ai_operation_cacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload>
          }
          update: {
            args: Prisma.ai_operation_cacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload>
          }
          deleteMany: {
            args: Prisma.ai_operation_cacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_operation_cacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_operation_cacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_operation_cachePayload>
          }
          aggregate: {
            args: Prisma.Ai_operation_cacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_operation_cache>
          }
          groupBy: {
            args: Prisma.ai_operation_cacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_operation_cacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_operation_cacheCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_operation_cacheCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    ai_prompts?: ai_promptsOmit
    ai_runs?: ai_runsOmit
    api_tokens?: api_tokensOmit
    attachments?: attachmentsOmit
    audit_logs?: audit_logsOmit
    feature_flags?: feature_flagsOmit
    job_logs?: job_logsOmit
    metrics_daily?: metrics_dailyOmit
    reports?: reportsOmit
    roles?: rolesOmit
    settings?: settingsOmit
    step_screenshots?: step_screenshotsOmit
    suite_case_map?: suite_case_mapOmit
    test_cases?: test_casesOmit
    test_run_results?: test_run_resultsOmit
    test_runs?: test_runsOmit
    test_suites?: test_suitesOmit
    user_roles?: user_rolesOmit
    users?: usersOmit
    run_artifacts?: run_artifactsOmit
    case_versions?: case_versionsOmit
    bulk_edit_sessions?: bulk_edit_sessionsOmit
    case_patch_proposals?: case_patch_proposalsOmit
    test_case_executions?: test_case_executionsOmit
    functional_test_cases?: functional_test_casesOmit
    ai_generation_sessions?: ai_generation_sessionsOmit
    requirement_documents?: requirement_documentsOmit
    systems?: systemsOmit
    project_versions?: project_versionsOmit
    functional_test_executions?: functional_test_executionsOmit
    test_plans?: test_plansOmit
    test_plan_cases?: test_plan_casesOmit
    test_plan_executions?: test_plan_executionsOmit
    ai_element_cache?: ai_element_cacheOmit
    ai_assertion_cache?: ai_assertion_cacheOmit
    ai_operation_cache?: ai_operation_cacheOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Ai_promptsCountOutputType
   */

  export type Ai_promptsCountOutputType = {
    ai_runs: number
  }

  export type Ai_promptsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_runs?: boolean | Ai_promptsCountOutputTypeCountAi_runsArgs
  }

  // Custom InputTypes
  /**
   * Ai_promptsCountOutputType without action
   */
  export type Ai_promptsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ai_promptsCountOutputType
     */
    select?: Ai_promptsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ai_promptsCountOutputType without action
   */
  export type Ai_promptsCountOutputTypeCountAi_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_runsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    user_roles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | RolesCountOutputTypeCountUser_rolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }


  /**
   * Count Type Test_casesCountOutputType
   */

  export type Test_casesCountOutputType = {
    patch_proposals: number
    case_versions: number
    step_screenshots: number
    suite_case_map: number
    test_case_executions: number
    test_run_results: number
  }

  export type Test_casesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patch_proposals?: boolean | Test_casesCountOutputTypeCountPatch_proposalsArgs
    case_versions?: boolean | Test_casesCountOutputTypeCountCase_versionsArgs
    step_screenshots?: boolean | Test_casesCountOutputTypeCountStep_screenshotsArgs
    suite_case_map?: boolean | Test_casesCountOutputTypeCountSuite_case_mapArgs
    test_case_executions?: boolean | Test_casesCountOutputTypeCountTest_case_executionsArgs
    test_run_results?: boolean | Test_casesCountOutputTypeCountTest_run_resultsArgs
  }

  // Custom InputTypes
  /**
   * Test_casesCountOutputType without action
   */
  export type Test_casesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test_casesCountOutputType
     */
    select?: Test_casesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Test_casesCountOutputType without action
   */
  export type Test_casesCountOutputTypeCountPatch_proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_patch_proposalsWhereInput
  }

  /**
   * Test_casesCountOutputType without action
   */
  export type Test_casesCountOutputTypeCountCase_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_versionsWhereInput
  }

  /**
   * Test_casesCountOutputType without action
   */
  export type Test_casesCountOutputTypeCountStep_screenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: step_screenshotsWhereInput
  }

  /**
   * Test_casesCountOutputType without action
   */
  export type Test_casesCountOutputTypeCountSuite_case_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suite_case_mapWhereInput
  }

  /**
   * Test_casesCountOutputType without action
   */
  export type Test_casesCountOutputTypeCountTest_case_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_case_executionsWhereInput
  }

  /**
   * Test_casesCountOutputType without action
   */
  export type Test_casesCountOutputTypeCountTest_run_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_run_resultsWhereInput
  }


  /**
   * Count Type Test_run_resultsCountOutputType
   */

  export type Test_run_resultsCountOutputType = {
    attachments: number
  }

  export type Test_run_resultsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | Test_run_resultsCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * Test_run_resultsCountOutputType without action
   */
  export type Test_run_resultsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test_run_resultsCountOutputType
     */
    select?: Test_run_resultsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Test_run_resultsCountOutputType without action
   */
  export type Test_run_resultsCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attachmentsWhereInput
  }


  /**
   * Count Type Test_runsCountOutputType
   */

  export type Test_runsCountOutputType = {
    ai_runs: number
    reports: number
    test_run_results: number
  }

  export type Test_runsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_runs?: boolean | Test_runsCountOutputTypeCountAi_runsArgs
    reports?: boolean | Test_runsCountOutputTypeCountReportsArgs
    test_run_results?: boolean | Test_runsCountOutputTypeCountTest_run_resultsArgs
  }

  // Custom InputTypes
  /**
   * Test_runsCountOutputType without action
   */
  export type Test_runsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test_runsCountOutputType
     */
    select?: Test_runsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Test_runsCountOutputType without action
   */
  export type Test_runsCountOutputTypeCountAi_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_runsWhereInput
  }

  /**
   * Test_runsCountOutputType without action
   */
  export type Test_runsCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportsWhereInput
  }

  /**
   * Test_runsCountOutputType without action
   */
  export type Test_runsCountOutputTypeCountTest_run_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_run_resultsWhereInput
  }


  /**
   * Count Type Test_suitesCountOutputType
   */

  export type Test_suitesCountOutputType = {
    suite_case_map: number
    test_runs: number
  }

  export type Test_suitesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suite_case_map?: boolean | Test_suitesCountOutputTypeCountSuite_case_mapArgs
    test_runs?: boolean | Test_suitesCountOutputTypeCountTest_runsArgs
  }

  // Custom InputTypes
  /**
   * Test_suitesCountOutputType without action
   */
  export type Test_suitesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test_suitesCountOutputType
     */
    select?: Test_suitesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Test_suitesCountOutputType without action
   */
  export type Test_suitesCountOutputTypeCountSuite_case_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suite_case_mapWhereInput
  }

  /**
   * Test_suitesCountOutputType without action
   */
  export type Test_suitesCountOutputTypeCountTest_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_runsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    ai_generation_sessions: number
    api_tokens: number
    audit_logs: number
    bulk_edit_sessions: number
    case_versions: number
    functional_test_cases: number
    requirement_documents: number
    test_case_executions: number
    test_runs: number
    test_suites: number
    user_roles: number
    functional_test_executions: number
    test_plans: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_generation_sessions?: boolean | UsersCountOutputTypeCountAi_generation_sessionsArgs
    api_tokens?: boolean | UsersCountOutputTypeCountApi_tokensArgs
    audit_logs?: boolean | UsersCountOutputTypeCountAudit_logsArgs
    bulk_edit_sessions?: boolean | UsersCountOutputTypeCountBulk_edit_sessionsArgs
    case_versions?: boolean | UsersCountOutputTypeCountCase_versionsArgs
    functional_test_cases?: boolean | UsersCountOutputTypeCountFunctional_test_casesArgs
    requirement_documents?: boolean | UsersCountOutputTypeCountRequirement_documentsArgs
    test_case_executions?: boolean | UsersCountOutputTypeCountTest_case_executionsArgs
    test_runs?: boolean | UsersCountOutputTypeCountTest_runsArgs
    test_suites?: boolean | UsersCountOutputTypeCountTest_suitesArgs
    user_roles?: boolean | UsersCountOutputTypeCountUser_rolesArgs
    functional_test_executions?: boolean | UsersCountOutputTypeCountFunctional_test_executionsArgs
    test_plans?: boolean | UsersCountOutputTypeCountTest_plansArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_generation_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_generation_sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountApi_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: api_tokensWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAudit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBulk_edit_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bulk_edit_sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCase_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_versionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFunctional_test_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: functional_test_casesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRequirement_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requirement_documentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTest_case_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_case_executionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTest_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_runsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTest_suitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_suitesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFunctional_test_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: functional_test_executionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTest_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plansWhereInput
  }


  /**
   * Count Type Bulk_edit_sessionsCountOutputType
   */

  export type Bulk_edit_sessionsCountOutputType = {
    proposals: number
  }

  export type Bulk_edit_sessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposals?: boolean | Bulk_edit_sessionsCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * Bulk_edit_sessionsCountOutputType without action
   */
  export type Bulk_edit_sessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bulk_edit_sessionsCountOutputType
     */
    select?: Bulk_edit_sessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Bulk_edit_sessionsCountOutputType without action
   */
  export type Bulk_edit_sessionsCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_patch_proposalsWhereInput
  }


  /**
   * Count Type Functional_test_casesCountOutputType
   */

  export type Functional_test_casesCountOutputType = {
    executions: number
  }

  export type Functional_test_casesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | Functional_test_casesCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * Functional_test_casesCountOutputType without action
   */
  export type Functional_test_casesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functional_test_casesCountOutputType
     */
    select?: Functional_test_casesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Functional_test_casesCountOutputType without action
   */
  export type Functional_test_casesCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: functional_test_executionsWhereInput
  }


  /**
   * Count Type Ai_generation_sessionsCountOutputType
   */

  export type Ai_generation_sessionsCountOutputType = {
    requirement_documents: number
  }

  export type Ai_generation_sessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirement_documents?: boolean | Ai_generation_sessionsCountOutputTypeCountRequirement_documentsArgs
  }

  // Custom InputTypes
  /**
   * Ai_generation_sessionsCountOutputType without action
   */
  export type Ai_generation_sessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ai_generation_sessionsCountOutputType
     */
    select?: Ai_generation_sessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ai_generation_sessionsCountOutputType without action
   */
  export type Ai_generation_sessionsCountOutputTypeCountRequirement_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requirement_documentsWhereInput
  }


  /**
   * Count Type Requirement_documentsCountOutputType
   */

  export type Requirement_documentsCountOutputType = {
    test_cases: number
  }

  export type Requirement_documentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_cases?: boolean | Requirement_documentsCountOutputTypeCountTest_casesArgs
  }

  // Custom InputTypes
  /**
   * Requirement_documentsCountOutputType without action
   */
  export type Requirement_documentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement_documentsCountOutputType
     */
    select?: Requirement_documentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Requirement_documentsCountOutputType without action
   */
  export type Requirement_documentsCountOutputTypeCountTest_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: functional_test_casesWhereInput
  }


  /**
   * Count Type SystemsCountOutputType
   */

  export type SystemsCountOutputType = {
    versions: number
    requirement_documents: number
  }

  export type SystemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | SystemsCountOutputTypeCountVersionsArgs
    requirement_documents?: boolean | SystemsCountOutputTypeCountRequirement_documentsArgs
  }

  // Custom InputTypes
  /**
   * SystemsCountOutputType without action
   */
  export type SystemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemsCountOutputType
     */
    select?: SystemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SystemsCountOutputType without action
   */
  export type SystemsCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_versionsWhereInput
  }

  /**
   * SystemsCountOutputType without action
   */
  export type SystemsCountOutputTypeCountRequirement_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requirement_documentsWhereInput
  }


  /**
   * Count Type Project_versionsCountOutputType
   */

  export type Project_versionsCountOutputType = {
    functional_test_cases: number
    requirement_documents: number
  }

  export type Project_versionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    functional_test_cases?: boolean | Project_versionsCountOutputTypeCountFunctional_test_casesArgs
    requirement_documents?: boolean | Project_versionsCountOutputTypeCountRequirement_documentsArgs
  }

  // Custom InputTypes
  /**
   * Project_versionsCountOutputType without action
   */
  export type Project_versionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project_versionsCountOutputType
     */
    select?: Project_versionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Project_versionsCountOutputType without action
   */
  export type Project_versionsCountOutputTypeCountFunctional_test_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: functional_test_casesWhereInput
  }

  /**
   * Project_versionsCountOutputType without action
   */
  export type Project_versionsCountOutputTypeCountRequirement_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requirement_documentsWhereInput
  }


  /**
   * Count Type Test_plansCountOutputType
   */

  export type Test_plansCountOutputType = {
    plan_cases: number
    plan_executions: number
  }

  export type Test_plansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan_cases?: boolean | Test_plansCountOutputTypeCountPlan_casesArgs
    plan_executions?: boolean | Test_plansCountOutputTypeCountPlan_executionsArgs
  }

  // Custom InputTypes
  /**
   * Test_plansCountOutputType without action
   */
  export type Test_plansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test_plansCountOutputType
     */
    select?: Test_plansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Test_plansCountOutputType without action
   */
  export type Test_plansCountOutputTypeCountPlan_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plan_casesWhereInput
  }

  /**
   * Test_plansCountOutputType without action
   */
  export type Test_plansCountOutputTypeCountPlan_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plan_executionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ai_prompts
   */

  export type AggregateAi_prompts = {
    _count: Ai_promptsCountAggregateOutputType | null
    _avg: Ai_promptsAvgAggregateOutputType | null
    _sum: Ai_promptsSumAggregateOutputType | null
    _min: Ai_promptsMinAggregateOutputType | null
    _max: Ai_promptsMaxAggregateOutputType | null
  }

  export type Ai_promptsAvgAggregateOutputType = {
    id: number | null
    version: number | null
  }

  export type Ai_promptsSumAggregateOutputType = {
    id: number | null
    version: number | null
  }

  export type Ai_promptsMinAggregateOutputType = {
    id: number | null
    name: string | null
    version: number | null
    template: string | null
    created_at: Date | null
  }

  export type Ai_promptsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    version: number | null
    template: string | null
    created_at: Date | null
  }

  export type Ai_promptsCountAggregateOutputType = {
    id: number
    name: number
    version: number
    template: number
    created_at: number
    _all: number
  }


  export type Ai_promptsAvgAggregateInputType = {
    id?: true
    version?: true
  }

  export type Ai_promptsSumAggregateInputType = {
    id?: true
    version?: true
  }

  export type Ai_promptsMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    template?: true
    created_at?: true
  }

  export type Ai_promptsMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    template?: true
    created_at?: true
  }

  export type Ai_promptsCountAggregateInputType = {
    id?: true
    name?: true
    version?: true
    template?: true
    created_at?: true
    _all?: true
  }

  export type Ai_promptsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_prompts to aggregate.
     */
    where?: ai_promptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_prompts to fetch.
     */
    orderBy?: ai_promptsOrderByWithRelationInput | ai_promptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_promptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_prompts
    **/
    _count?: true | Ai_promptsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_promptsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_promptsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_promptsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_promptsMaxAggregateInputType
  }

  export type GetAi_promptsAggregateType<T extends Ai_promptsAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_prompts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_prompts[P]>
      : GetScalarType<T[P], AggregateAi_prompts[P]>
  }




  export type ai_promptsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_promptsWhereInput
    orderBy?: ai_promptsOrderByWithAggregationInput | ai_promptsOrderByWithAggregationInput[]
    by: Ai_promptsScalarFieldEnum[] | Ai_promptsScalarFieldEnum
    having?: ai_promptsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_promptsCountAggregateInputType | true
    _avg?: Ai_promptsAvgAggregateInputType
    _sum?: Ai_promptsSumAggregateInputType
    _min?: Ai_promptsMinAggregateInputType
    _max?: Ai_promptsMaxAggregateInputType
  }

  export type Ai_promptsGroupByOutputType = {
    id: number
    name: string
    version: number
    template: string
    created_at: Date | null
    _count: Ai_promptsCountAggregateOutputType | null
    _avg: Ai_promptsAvgAggregateOutputType | null
    _sum: Ai_promptsSumAggregateOutputType | null
    _min: Ai_promptsMinAggregateOutputType | null
    _max: Ai_promptsMaxAggregateOutputType | null
  }

  type GetAi_promptsGroupByPayload<T extends ai_promptsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_promptsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_promptsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_promptsGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_promptsGroupByOutputType[P]>
        }
      >
    >


  export type ai_promptsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    template?: boolean
    created_at?: boolean
    ai_runs?: boolean | ai_prompts$ai_runsArgs<ExtArgs>
    _count?: boolean | Ai_promptsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_prompts"]>



  export type ai_promptsSelectScalar = {
    id?: boolean
    name?: boolean
    version?: boolean
    template?: boolean
    created_at?: boolean
  }

  export type ai_promptsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "version" | "template" | "created_at", ExtArgs["result"]["ai_prompts"]>
  export type ai_promptsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_runs?: boolean | ai_prompts$ai_runsArgs<ExtArgs>
    _count?: boolean | Ai_promptsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ai_promptsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_prompts"
    objects: {
      ai_runs: Prisma.$ai_runsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      version: number
      template: string
      created_at: Date | null
    }, ExtArgs["result"]["ai_prompts"]>
    composites: {}
  }

  type ai_promptsGetPayload<S extends boolean | null | undefined | ai_promptsDefaultArgs> = $Result.GetResult<Prisma.$ai_promptsPayload, S>

  type ai_promptsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_promptsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_promptsCountAggregateInputType | true
    }

  export interface ai_promptsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_prompts'], meta: { name: 'ai_prompts' } }
    /**
     * Find zero or one Ai_prompts that matches the filter.
     * @param {ai_promptsFindUniqueArgs} args - Arguments to find a Ai_prompts
     * @example
     * // Get one Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_promptsFindUniqueArgs>(args: SelectSubset<T, ai_promptsFindUniqueArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_prompts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_promptsFindUniqueOrThrowArgs} args - Arguments to find a Ai_prompts
     * @example
     * // Get one Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_promptsFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_promptsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_prompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_promptsFindFirstArgs} args - Arguments to find a Ai_prompts
     * @example
     * // Get one Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_promptsFindFirstArgs>(args?: SelectSubset<T, ai_promptsFindFirstArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_prompts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_promptsFindFirstOrThrowArgs} args - Arguments to find a Ai_prompts
     * @example
     * // Get one Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_promptsFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_promptsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_prompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_promptsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.findMany()
     * 
     * // Get first 10 Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_promptsWithIdOnly = await prisma.ai_prompts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_promptsFindManyArgs>(args?: SelectSubset<T, ai_promptsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_prompts.
     * @param {ai_promptsCreateArgs} args - Arguments to create a Ai_prompts.
     * @example
     * // Create one Ai_prompts
     * const Ai_prompts = await prisma.ai_prompts.create({
     *   data: {
     *     // ... data to create a Ai_prompts
     *   }
     * })
     * 
     */
    create<T extends ai_promptsCreateArgs>(args: SelectSubset<T, ai_promptsCreateArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_prompts.
     * @param {ai_promptsCreateManyArgs} args - Arguments to create many Ai_prompts.
     * @example
     * // Create many Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_promptsCreateManyArgs>(args?: SelectSubset<T, ai_promptsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ai_prompts.
     * @param {ai_promptsDeleteArgs} args - Arguments to delete one Ai_prompts.
     * @example
     * // Delete one Ai_prompts
     * const Ai_prompts = await prisma.ai_prompts.delete({
     *   where: {
     *     // ... filter to delete one Ai_prompts
     *   }
     * })
     * 
     */
    delete<T extends ai_promptsDeleteArgs>(args: SelectSubset<T, ai_promptsDeleteArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_prompts.
     * @param {ai_promptsUpdateArgs} args - Arguments to update one Ai_prompts.
     * @example
     * // Update one Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_promptsUpdateArgs>(args: SelectSubset<T, ai_promptsUpdateArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_prompts.
     * @param {ai_promptsDeleteManyArgs} args - Arguments to filter Ai_prompts to delete.
     * @example
     * // Delete a few Ai_prompts
     * const { count } = await prisma.ai_prompts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_promptsDeleteManyArgs>(args?: SelectSubset<T, ai_promptsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_promptsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_promptsUpdateManyArgs>(args: SelectSubset<T, ai_promptsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_prompts.
     * @param {ai_promptsUpsertArgs} args - Arguments to update or create a Ai_prompts.
     * @example
     * // Update or create a Ai_prompts
     * const ai_prompts = await prisma.ai_prompts.upsert({
     *   create: {
     *     // ... data to create a Ai_prompts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_prompts we want to update
     *   }
     * })
     */
    upsert<T extends ai_promptsUpsertArgs>(args: SelectSubset<T, ai_promptsUpsertArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_promptsCountArgs} args - Arguments to filter Ai_prompts to count.
     * @example
     * // Count the number of Ai_prompts
     * const count = await prisma.ai_prompts.count({
     *   where: {
     *     // ... the filter for the Ai_prompts we want to count
     *   }
     * })
    **/
    count<T extends ai_promptsCountArgs>(
      args?: Subset<T, ai_promptsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_promptsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_promptsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_promptsAggregateArgs>(args: Subset<T, Ai_promptsAggregateArgs>): Prisma.PrismaPromise<GetAi_promptsAggregateType<T>>

    /**
     * Group by Ai_prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_promptsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_promptsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_promptsGroupByArgs['orderBy'] }
        : { orderBy?: ai_promptsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_promptsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_promptsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_prompts model
   */
  readonly fields: ai_promptsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_prompts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_promptsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ai_runs<T extends ai_prompts$ai_runsArgs<ExtArgs> = {}>(args?: Subset<T, ai_prompts$ai_runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_prompts model
   */
  interface ai_promptsFieldRefs {
    readonly id: FieldRef<"ai_prompts", 'Int'>
    readonly name: FieldRef<"ai_prompts", 'String'>
    readonly version: FieldRef<"ai_prompts", 'Int'>
    readonly template: FieldRef<"ai_prompts", 'String'>
    readonly created_at: FieldRef<"ai_prompts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_prompts findUnique
   */
  export type ai_promptsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * Filter, which ai_prompts to fetch.
     */
    where: ai_promptsWhereUniqueInput
  }

  /**
   * ai_prompts findUniqueOrThrow
   */
  export type ai_promptsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * Filter, which ai_prompts to fetch.
     */
    where: ai_promptsWhereUniqueInput
  }

  /**
   * ai_prompts findFirst
   */
  export type ai_promptsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * Filter, which ai_prompts to fetch.
     */
    where?: ai_promptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_prompts to fetch.
     */
    orderBy?: ai_promptsOrderByWithRelationInput | ai_promptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_prompts.
     */
    cursor?: ai_promptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_prompts.
     */
    distinct?: Ai_promptsScalarFieldEnum | Ai_promptsScalarFieldEnum[]
  }

  /**
   * ai_prompts findFirstOrThrow
   */
  export type ai_promptsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * Filter, which ai_prompts to fetch.
     */
    where?: ai_promptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_prompts to fetch.
     */
    orderBy?: ai_promptsOrderByWithRelationInput | ai_promptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_prompts.
     */
    cursor?: ai_promptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_prompts.
     */
    distinct?: Ai_promptsScalarFieldEnum | Ai_promptsScalarFieldEnum[]
  }

  /**
   * ai_prompts findMany
   */
  export type ai_promptsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * Filter, which ai_prompts to fetch.
     */
    where?: ai_promptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_prompts to fetch.
     */
    orderBy?: ai_promptsOrderByWithRelationInput | ai_promptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_prompts.
     */
    cursor?: ai_promptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_prompts.
     */
    skip?: number
    distinct?: Ai_promptsScalarFieldEnum | Ai_promptsScalarFieldEnum[]
  }

  /**
   * ai_prompts create
   */
  export type ai_promptsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_prompts.
     */
    data: XOR<ai_promptsCreateInput, ai_promptsUncheckedCreateInput>
  }

  /**
   * ai_prompts createMany
   */
  export type ai_promptsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_prompts.
     */
    data: ai_promptsCreateManyInput | ai_promptsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_prompts update
   */
  export type ai_promptsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_prompts.
     */
    data: XOR<ai_promptsUpdateInput, ai_promptsUncheckedUpdateInput>
    /**
     * Choose, which ai_prompts to update.
     */
    where: ai_promptsWhereUniqueInput
  }

  /**
   * ai_prompts updateMany
   */
  export type ai_promptsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_prompts.
     */
    data: XOR<ai_promptsUpdateManyMutationInput, ai_promptsUncheckedUpdateManyInput>
    /**
     * Filter which ai_prompts to update
     */
    where?: ai_promptsWhereInput
    /**
     * Limit how many ai_prompts to update.
     */
    limit?: number
  }

  /**
   * ai_prompts upsert
   */
  export type ai_promptsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_prompts to update in case it exists.
     */
    where: ai_promptsWhereUniqueInput
    /**
     * In case the ai_prompts found by the `where` argument doesn't exist, create a new ai_prompts with this data.
     */
    create: XOR<ai_promptsCreateInput, ai_promptsUncheckedCreateInput>
    /**
     * In case the ai_prompts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_promptsUpdateInput, ai_promptsUncheckedUpdateInput>
  }

  /**
   * ai_prompts delete
   */
  export type ai_promptsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
    /**
     * Filter which ai_prompts to delete.
     */
    where: ai_promptsWhereUniqueInput
  }

  /**
   * ai_prompts deleteMany
   */
  export type ai_promptsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_prompts to delete
     */
    where?: ai_promptsWhereInput
    /**
     * Limit how many ai_prompts to delete.
     */
    limit?: number
  }

  /**
   * ai_prompts.ai_runs
   */
  export type ai_prompts$ai_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    where?: ai_runsWhereInput
    orderBy?: ai_runsOrderByWithRelationInput | ai_runsOrderByWithRelationInput[]
    cursor?: ai_runsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_runsScalarFieldEnum | Ai_runsScalarFieldEnum[]
  }

  /**
   * ai_prompts without action
   */
  export type ai_promptsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_prompts
     */
    select?: ai_promptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_prompts
     */
    omit?: ai_promptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_promptsInclude<ExtArgs> | null
  }


  /**
   * Model ai_runs
   */

  export type AggregateAi_runs = {
    _count: Ai_runsCountAggregateOutputType | null
    _avg: Ai_runsAvgAggregateOutputType | null
    _sum: Ai_runsSumAggregateOutputType | null
    _min: Ai_runsMinAggregateOutputType | null
    _max: Ai_runsMaxAggregateOutputType | null
  }

  export type Ai_runsAvgAggregateOutputType = {
    id: number | null
    prompt_id: number | null
    run_id: number | null
    token_used: number | null
    cost_usd: Decimal | null
  }

  export type Ai_runsSumAggregateOutputType = {
    id: number | null
    prompt_id: number | null
    run_id: number | null
    token_used: number | null
    cost_usd: Decimal | null
  }

  export type Ai_runsMinAggregateOutputType = {
    id: number | null
    prompt_id: number | null
    run_id: number | null
    token_used: number | null
    cost_usd: Decimal | null
    executed_at: Date | null
  }

  export type Ai_runsMaxAggregateOutputType = {
    id: number | null
    prompt_id: number | null
    run_id: number | null
    token_used: number | null
    cost_usd: Decimal | null
    executed_at: Date | null
  }

  export type Ai_runsCountAggregateOutputType = {
    id: number
    prompt_id: number
    run_id: number
    token_used: number
    cost_usd: number
    executed_at: number
    _all: number
  }


  export type Ai_runsAvgAggregateInputType = {
    id?: true
    prompt_id?: true
    run_id?: true
    token_used?: true
    cost_usd?: true
  }

  export type Ai_runsSumAggregateInputType = {
    id?: true
    prompt_id?: true
    run_id?: true
    token_used?: true
    cost_usd?: true
  }

  export type Ai_runsMinAggregateInputType = {
    id?: true
    prompt_id?: true
    run_id?: true
    token_used?: true
    cost_usd?: true
    executed_at?: true
  }

  export type Ai_runsMaxAggregateInputType = {
    id?: true
    prompt_id?: true
    run_id?: true
    token_used?: true
    cost_usd?: true
    executed_at?: true
  }

  export type Ai_runsCountAggregateInputType = {
    id?: true
    prompt_id?: true
    run_id?: true
    token_used?: true
    cost_usd?: true
    executed_at?: true
    _all?: true
  }

  export type Ai_runsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_runs to aggregate.
     */
    where?: ai_runsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_runs to fetch.
     */
    orderBy?: ai_runsOrderByWithRelationInput | ai_runsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_runsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_runs
    **/
    _count?: true | Ai_runsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_runsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_runsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_runsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_runsMaxAggregateInputType
  }

  export type GetAi_runsAggregateType<T extends Ai_runsAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_runs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_runs[P]>
      : GetScalarType<T[P], AggregateAi_runs[P]>
  }




  export type ai_runsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_runsWhereInput
    orderBy?: ai_runsOrderByWithAggregationInput | ai_runsOrderByWithAggregationInput[]
    by: Ai_runsScalarFieldEnum[] | Ai_runsScalarFieldEnum
    having?: ai_runsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_runsCountAggregateInputType | true
    _avg?: Ai_runsAvgAggregateInputType
    _sum?: Ai_runsSumAggregateInputType
    _min?: Ai_runsMinAggregateInputType
    _max?: Ai_runsMaxAggregateInputType
  }

  export type Ai_runsGroupByOutputType = {
    id: number
    prompt_id: number
    run_id: number | null
    token_used: number | null
    cost_usd: Decimal | null
    executed_at: Date | null
    _count: Ai_runsCountAggregateOutputType | null
    _avg: Ai_runsAvgAggregateOutputType | null
    _sum: Ai_runsSumAggregateOutputType | null
    _min: Ai_runsMinAggregateOutputType | null
    _max: Ai_runsMaxAggregateOutputType | null
  }

  type GetAi_runsGroupByPayload<T extends ai_runsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_runsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_runsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_runsGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_runsGroupByOutputType[P]>
        }
      >
    >


  export type ai_runsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt_id?: boolean
    run_id?: boolean
    token_used?: boolean
    cost_usd?: boolean
    executed_at?: boolean
    ai_prompts?: boolean | ai_promptsDefaultArgs<ExtArgs>
    test_runs?: boolean | ai_runs$test_runsArgs<ExtArgs>
  }, ExtArgs["result"]["ai_runs"]>



  export type ai_runsSelectScalar = {
    id?: boolean
    prompt_id?: boolean
    run_id?: boolean
    token_used?: boolean
    cost_usd?: boolean
    executed_at?: boolean
  }

  export type ai_runsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prompt_id" | "run_id" | "token_used" | "cost_usd" | "executed_at", ExtArgs["result"]["ai_runs"]>
  export type ai_runsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_prompts?: boolean | ai_promptsDefaultArgs<ExtArgs>
    test_runs?: boolean | ai_runs$test_runsArgs<ExtArgs>
  }

  export type $ai_runsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_runs"
    objects: {
      ai_prompts: Prisma.$ai_promptsPayload<ExtArgs>
      test_runs: Prisma.$test_runsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prompt_id: number
      run_id: number | null
      token_used: number | null
      cost_usd: Prisma.Decimal | null
      executed_at: Date | null
    }, ExtArgs["result"]["ai_runs"]>
    composites: {}
  }

  type ai_runsGetPayload<S extends boolean | null | undefined | ai_runsDefaultArgs> = $Result.GetResult<Prisma.$ai_runsPayload, S>

  type ai_runsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_runsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_runsCountAggregateInputType | true
    }

  export interface ai_runsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_runs'], meta: { name: 'ai_runs' } }
    /**
     * Find zero or one Ai_runs that matches the filter.
     * @param {ai_runsFindUniqueArgs} args - Arguments to find a Ai_runs
     * @example
     * // Get one Ai_runs
     * const ai_runs = await prisma.ai_runs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_runsFindUniqueArgs>(args: SelectSubset<T, ai_runsFindUniqueArgs<ExtArgs>>): Prisma__ai_runsClient<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_runs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_runsFindUniqueOrThrowArgs} args - Arguments to find a Ai_runs
     * @example
     * // Get one Ai_runs
     * const ai_runs = await prisma.ai_runs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_runsFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_runsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_runsClient<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_runs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_runsFindFirstArgs} args - Arguments to find a Ai_runs
     * @example
     * // Get one Ai_runs
     * const ai_runs = await prisma.ai_runs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_runsFindFirstArgs>(args?: SelectSubset<T, ai_runsFindFirstArgs<ExtArgs>>): Prisma__ai_runsClient<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_runs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_runsFindFirstOrThrowArgs} args - Arguments to find a Ai_runs
     * @example
     * // Get one Ai_runs
     * const ai_runs = await prisma.ai_runs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_runsFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_runsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_runsClient<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_runs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_runsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_runs
     * const ai_runs = await prisma.ai_runs.findMany()
     * 
     * // Get first 10 Ai_runs
     * const ai_runs = await prisma.ai_runs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_runsWithIdOnly = await prisma.ai_runs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_runsFindManyArgs>(args?: SelectSubset<T, ai_runsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_runs.
     * @param {ai_runsCreateArgs} args - Arguments to create a Ai_runs.
     * @example
     * // Create one Ai_runs
     * const Ai_runs = await prisma.ai_runs.create({
     *   data: {
     *     // ... data to create a Ai_runs
     *   }
     * })
     * 
     */
    create<T extends ai_runsCreateArgs>(args: SelectSubset<T, ai_runsCreateArgs<ExtArgs>>): Prisma__ai_runsClient<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_runs.
     * @param {ai_runsCreateManyArgs} args - Arguments to create many Ai_runs.
     * @example
     * // Create many Ai_runs
     * const ai_runs = await prisma.ai_runs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_runsCreateManyArgs>(args?: SelectSubset<T, ai_runsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ai_runs.
     * @param {ai_runsDeleteArgs} args - Arguments to delete one Ai_runs.
     * @example
     * // Delete one Ai_runs
     * const Ai_runs = await prisma.ai_runs.delete({
     *   where: {
     *     // ... filter to delete one Ai_runs
     *   }
     * })
     * 
     */
    delete<T extends ai_runsDeleteArgs>(args: SelectSubset<T, ai_runsDeleteArgs<ExtArgs>>): Prisma__ai_runsClient<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_runs.
     * @param {ai_runsUpdateArgs} args - Arguments to update one Ai_runs.
     * @example
     * // Update one Ai_runs
     * const ai_runs = await prisma.ai_runs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_runsUpdateArgs>(args: SelectSubset<T, ai_runsUpdateArgs<ExtArgs>>): Prisma__ai_runsClient<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_runs.
     * @param {ai_runsDeleteManyArgs} args - Arguments to filter Ai_runs to delete.
     * @example
     * // Delete a few Ai_runs
     * const { count } = await prisma.ai_runs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_runsDeleteManyArgs>(args?: SelectSubset<T, ai_runsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_runsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_runs
     * const ai_runs = await prisma.ai_runs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_runsUpdateManyArgs>(args: SelectSubset<T, ai_runsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_runs.
     * @param {ai_runsUpsertArgs} args - Arguments to update or create a Ai_runs.
     * @example
     * // Update or create a Ai_runs
     * const ai_runs = await prisma.ai_runs.upsert({
     *   create: {
     *     // ... data to create a Ai_runs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_runs we want to update
     *   }
     * })
     */
    upsert<T extends ai_runsUpsertArgs>(args: SelectSubset<T, ai_runsUpsertArgs<ExtArgs>>): Prisma__ai_runsClient<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_runsCountArgs} args - Arguments to filter Ai_runs to count.
     * @example
     * // Count the number of Ai_runs
     * const count = await prisma.ai_runs.count({
     *   where: {
     *     // ... the filter for the Ai_runs we want to count
     *   }
     * })
    **/
    count<T extends ai_runsCountArgs>(
      args?: Subset<T, ai_runsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_runsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_runsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_runsAggregateArgs>(args: Subset<T, Ai_runsAggregateArgs>): Prisma.PrismaPromise<GetAi_runsAggregateType<T>>

    /**
     * Group by Ai_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_runsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_runsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_runsGroupByArgs['orderBy'] }
        : { orderBy?: ai_runsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_runsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_runsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_runs model
   */
  readonly fields: ai_runsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_runs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_runsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ai_prompts<T extends ai_promptsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ai_promptsDefaultArgs<ExtArgs>>): Prisma__ai_promptsClient<$Result.GetResult<Prisma.$ai_promptsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    test_runs<T extends ai_runs$test_runsArgs<ExtArgs> = {}>(args?: Subset<T, ai_runs$test_runsArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_runs model
   */
  interface ai_runsFieldRefs {
    readonly id: FieldRef<"ai_runs", 'Int'>
    readonly prompt_id: FieldRef<"ai_runs", 'Int'>
    readonly run_id: FieldRef<"ai_runs", 'Int'>
    readonly token_used: FieldRef<"ai_runs", 'Int'>
    readonly cost_usd: FieldRef<"ai_runs", 'Decimal'>
    readonly executed_at: FieldRef<"ai_runs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_runs findUnique
   */
  export type ai_runsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * Filter, which ai_runs to fetch.
     */
    where: ai_runsWhereUniqueInput
  }

  /**
   * ai_runs findUniqueOrThrow
   */
  export type ai_runsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * Filter, which ai_runs to fetch.
     */
    where: ai_runsWhereUniqueInput
  }

  /**
   * ai_runs findFirst
   */
  export type ai_runsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * Filter, which ai_runs to fetch.
     */
    where?: ai_runsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_runs to fetch.
     */
    orderBy?: ai_runsOrderByWithRelationInput | ai_runsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_runs.
     */
    cursor?: ai_runsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_runs.
     */
    distinct?: Ai_runsScalarFieldEnum | Ai_runsScalarFieldEnum[]
  }

  /**
   * ai_runs findFirstOrThrow
   */
  export type ai_runsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * Filter, which ai_runs to fetch.
     */
    where?: ai_runsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_runs to fetch.
     */
    orderBy?: ai_runsOrderByWithRelationInput | ai_runsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_runs.
     */
    cursor?: ai_runsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_runs.
     */
    distinct?: Ai_runsScalarFieldEnum | Ai_runsScalarFieldEnum[]
  }

  /**
   * ai_runs findMany
   */
  export type ai_runsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * Filter, which ai_runs to fetch.
     */
    where?: ai_runsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_runs to fetch.
     */
    orderBy?: ai_runsOrderByWithRelationInput | ai_runsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_runs.
     */
    cursor?: ai_runsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_runs.
     */
    skip?: number
    distinct?: Ai_runsScalarFieldEnum | Ai_runsScalarFieldEnum[]
  }

  /**
   * ai_runs create
   */
  export type ai_runsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_runs.
     */
    data: XOR<ai_runsCreateInput, ai_runsUncheckedCreateInput>
  }

  /**
   * ai_runs createMany
   */
  export type ai_runsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_runs.
     */
    data: ai_runsCreateManyInput | ai_runsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_runs update
   */
  export type ai_runsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_runs.
     */
    data: XOR<ai_runsUpdateInput, ai_runsUncheckedUpdateInput>
    /**
     * Choose, which ai_runs to update.
     */
    where: ai_runsWhereUniqueInput
  }

  /**
   * ai_runs updateMany
   */
  export type ai_runsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_runs.
     */
    data: XOR<ai_runsUpdateManyMutationInput, ai_runsUncheckedUpdateManyInput>
    /**
     * Filter which ai_runs to update
     */
    where?: ai_runsWhereInput
    /**
     * Limit how many ai_runs to update.
     */
    limit?: number
  }

  /**
   * ai_runs upsert
   */
  export type ai_runsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_runs to update in case it exists.
     */
    where: ai_runsWhereUniqueInput
    /**
     * In case the ai_runs found by the `where` argument doesn't exist, create a new ai_runs with this data.
     */
    create: XOR<ai_runsCreateInput, ai_runsUncheckedCreateInput>
    /**
     * In case the ai_runs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_runsUpdateInput, ai_runsUncheckedUpdateInput>
  }

  /**
   * ai_runs delete
   */
  export type ai_runsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    /**
     * Filter which ai_runs to delete.
     */
    where: ai_runsWhereUniqueInput
  }

  /**
   * ai_runs deleteMany
   */
  export type ai_runsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_runs to delete
     */
    where?: ai_runsWhereInput
    /**
     * Limit how many ai_runs to delete.
     */
    limit?: number
  }

  /**
   * ai_runs.test_runs
   */
  export type ai_runs$test_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    where?: test_runsWhereInput
  }

  /**
   * ai_runs without action
   */
  export type ai_runsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
  }


  /**
   * Model api_tokens
   */

  export type AggregateApi_tokens = {
    _count: Api_tokensCountAggregateOutputType | null
    _avg: Api_tokensAvgAggregateOutputType | null
    _sum: Api_tokensSumAggregateOutputType | null
    _min: Api_tokensMinAggregateOutputType | null
    _max: Api_tokensMaxAggregateOutputType | null
  }

  export type Api_tokensAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Api_tokensSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Api_tokensMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    token_hash: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type Api_tokensMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    token_hash: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type Api_tokensCountAggregateOutputType = {
    id: number
    user_id: number
    token_hash: number
    scopes: number
    expires_at: number
    created_at: number
    _all: number
  }


  export type Api_tokensAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Api_tokensSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Api_tokensMinAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    expires_at?: true
    created_at?: true
  }

  export type Api_tokensMaxAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    expires_at?: true
    created_at?: true
  }

  export type Api_tokensCountAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    scopes?: true
    expires_at?: true
    created_at?: true
    _all?: true
  }

  export type Api_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_tokens to aggregate.
     */
    where?: api_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_tokens to fetch.
     */
    orderBy?: api_tokensOrderByWithRelationInput | api_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: api_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned api_tokens
    **/
    _count?: true | Api_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Api_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Api_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Api_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Api_tokensMaxAggregateInputType
  }

  export type GetApi_tokensAggregateType<T extends Api_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateApi_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApi_tokens[P]>
      : GetScalarType<T[P], AggregateApi_tokens[P]>
  }




  export type api_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: api_tokensWhereInput
    orderBy?: api_tokensOrderByWithAggregationInput | api_tokensOrderByWithAggregationInput[]
    by: Api_tokensScalarFieldEnum[] | Api_tokensScalarFieldEnum
    having?: api_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Api_tokensCountAggregateInputType | true
    _avg?: Api_tokensAvgAggregateInputType
    _sum?: Api_tokensSumAggregateInputType
    _min?: Api_tokensMinAggregateInputType
    _max?: Api_tokensMaxAggregateInputType
  }

  export type Api_tokensGroupByOutputType = {
    id: number
    user_id: number
    token_hash: string
    scopes: JsonValue | null
    expires_at: Date | null
    created_at: Date | null
    _count: Api_tokensCountAggregateOutputType | null
    _avg: Api_tokensAvgAggregateOutputType | null
    _sum: Api_tokensSumAggregateOutputType | null
    _min: Api_tokensMinAggregateOutputType | null
    _max: Api_tokensMaxAggregateOutputType | null
  }

  type GetApi_tokensGroupByPayload<T extends api_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Api_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Api_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Api_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Api_tokensGroupByOutputType[P]>
        }
      >
    >


  export type api_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    scopes?: boolean
    expires_at?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["api_tokens"]>



  export type api_tokensSelectScalar = {
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    scopes?: boolean
    expires_at?: boolean
    created_at?: boolean
  }

  export type api_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token_hash" | "scopes" | "expires_at" | "created_at", ExtArgs["result"]["api_tokens"]>
  export type api_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $api_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "api_tokens"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      token_hash: string
      scopes: Prisma.JsonValue | null
      expires_at: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["api_tokens"]>
    composites: {}
  }

  type api_tokensGetPayload<S extends boolean | null | undefined | api_tokensDefaultArgs> = $Result.GetResult<Prisma.$api_tokensPayload, S>

  type api_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<api_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Api_tokensCountAggregateInputType | true
    }

  export interface api_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['api_tokens'], meta: { name: 'api_tokens' } }
    /**
     * Find zero or one Api_tokens that matches the filter.
     * @param {api_tokensFindUniqueArgs} args - Arguments to find a Api_tokens
     * @example
     * // Get one Api_tokens
     * const api_tokens = await prisma.api_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends api_tokensFindUniqueArgs>(args: SelectSubset<T, api_tokensFindUniqueArgs<ExtArgs>>): Prisma__api_tokensClient<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Api_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {api_tokensFindUniqueOrThrowArgs} args - Arguments to find a Api_tokens
     * @example
     * // Get one Api_tokens
     * const api_tokens = await prisma.api_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends api_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, api_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__api_tokensClient<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Api_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_tokensFindFirstArgs} args - Arguments to find a Api_tokens
     * @example
     * // Get one Api_tokens
     * const api_tokens = await prisma.api_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends api_tokensFindFirstArgs>(args?: SelectSubset<T, api_tokensFindFirstArgs<ExtArgs>>): Prisma__api_tokensClient<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Api_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_tokensFindFirstOrThrowArgs} args - Arguments to find a Api_tokens
     * @example
     * // Get one Api_tokens
     * const api_tokens = await prisma.api_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends api_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, api_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__api_tokensClient<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Api_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Api_tokens
     * const api_tokens = await prisma.api_tokens.findMany()
     * 
     * // Get first 10 Api_tokens
     * const api_tokens = await prisma.api_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const api_tokensWithIdOnly = await prisma.api_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends api_tokensFindManyArgs>(args?: SelectSubset<T, api_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Api_tokens.
     * @param {api_tokensCreateArgs} args - Arguments to create a Api_tokens.
     * @example
     * // Create one Api_tokens
     * const Api_tokens = await prisma.api_tokens.create({
     *   data: {
     *     // ... data to create a Api_tokens
     *   }
     * })
     * 
     */
    create<T extends api_tokensCreateArgs>(args: SelectSubset<T, api_tokensCreateArgs<ExtArgs>>): Prisma__api_tokensClient<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Api_tokens.
     * @param {api_tokensCreateManyArgs} args - Arguments to create many Api_tokens.
     * @example
     * // Create many Api_tokens
     * const api_tokens = await prisma.api_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends api_tokensCreateManyArgs>(args?: SelectSubset<T, api_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Api_tokens.
     * @param {api_tokensDeleteArgs} args - Arguments to delete one Api_tokens.
     * @example
     * // Delete one Api_tokens
     * const Api_tokens = await prisma.api_tokens.delete({
     *   where: {
     *     // ... filter to delete one Api_tokens
     *   }
     * })
     * 
     */
    delete<T extends api_tokensDeleteArgs>(args: SelectSubset<T, api_tokensDeleteArgs<ExtArgs>>): Prisma__api_tokensClient<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Api_tokens.
     * @param {api_tokensUpdateArgs} args - Arguments to update one Api_tokens.
     * @example
     * // Update one Api_tokens
     * const api_tokens = await prisma.api_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends api_tokensUpdateArgs>(args: SelectSubset<T, api_tokensUpdateArgs<ExtArgs>>): Prisma__api_tokensClient<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Api_tokens.
     * @param {api_tokensDeleteManyArgs} args - Arguments to filter Api_tokens to delete.
     * @example
     * // Delete a few Api_tokens
     * const { count } = await prisma.api_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends api_tokensDeleteManyArgs>(args?: SelectSubset<T, api_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Api_tokens
     * const api_tokens = await prisma.api_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends api_tokensUpdateManyArgs>(args: SelectSubset<T, api_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Api_tokens.
     * @param {api_tokensUpsertArgs} args - Arguments to update or create a Api_tokens.
     * @example
     * // Update or create a Api_tokens
     * const api_tokens = await prisma.api_tokens.upsert({
     *   create: {
     *     // ... data to create a Api_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Api_tokens we want to update
     *   }
     * })
     */
    upsert<T extends api_tokensUpsertArgs>(args: SelectSubset<T, api_tokensUpsertArgs<ExtArgs>>): Prisma__api_tokensClient<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Api_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_tokensCountArgs} args - Arguments to filter Api_tokens to count.
     * @example
     * // Count the number of Api_tokens
     * const count = await prisma.api_tokens.count({
     *   where: {
     *     // ... the filter for the Api_tokens we want to count
     *   }
     * })
    **/
    count<T extends api_tokensCountArgs>(
      args?: Subset<T, api_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Api_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Api_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Api_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Api_tokensAggregateArgs>(args: Subset<T, Api_tokensAggregateArgs>): Prisma.PrismaPromise<GetApi_tokensAggregateType<T>>

    /**
     * Group by Api_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends api_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: api_tokensGroupByArgs['orderBy'] }
        : { orderBy?: api_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, api_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApi_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the api_tokens model
   */
  readonly fields: api_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for api_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__api_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the api_tokens model
   */
  interface api_tokensFieldRefs {
    readonly id: FieldRef<"api_tokens", 'Int'>
    readonly user_id: FieldRef<"api_tokens", 'Int'>
    readonly token_hash: FieldRef<"api_tokens", 'String'>
    readonly scopes: FieldRef<"api_tokens", 'Json'>
    readonly expires_at: FieldRef<"api_tokens", 'DateTime'>
    readonly created_at: FieldRef<"api_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * api_tokens findUnique
   */
  export type api_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * Filter, which api_tokens to fetch.
     */
    where: api_tokensWhereUniqueInput
  }

  /**
   * api_tokens findUniqueOrThrow
   */
  export type api_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * Filter, which api_tokens to fetch.
     */
    where: api_tokensWhereUniqueInput
  }

  /**
   * api_tokens findFirst
   */
  export type api_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * Filter, which api_tokens to fetch.
     */
    where?: api_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_tokens to fetch.
     */
    orderBy?: api_tokensOrderByWithRelationInput | api_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_tokens.
     */
    cursor?: api_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_tokens.
     */
    distinct?: Api_tokensScalarFieldEnum | Api_tokensScalarFieldEnum[]
  }

  /**
   * api_tokens findFirstOrThrow
   */
  export type api_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * Filter, which api_tokens to fetch.
     */
    where?: api_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_tokens to fetch.
     */
    orderBy?: api_tokensOrderByWithRelationInput | api_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_tokens.
     */
    cursor?: api_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_tokens.
     */
    distinct?: Api_tokensScalarFieldEnum | Api_tokensScalarFieldEnum[]
  }

  /**
   * api_tokens findMany
   */
  export type api_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * Filter, which api_tokens to fetch.
     */
    where?: api_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_tokens to fetch.
     */
    orderBy?: api_tokensOrderByWithRelationInput | api_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing api_tokens.
     */
    cursor?: api_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_tokens.
     */
    skip?: number
    distinct?: Api_tokensScalarFieldEnum | Api_tokensScalarFieldEnum[]
  }

  /**
   * api_tokens create
   */
  export type api_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a api_tokens.
     */
    data: XOR<api_tokensCreateInput, api_tokensUncheckedCreateInput>
  }

  /**
   * api_tokens createMany
   */
  export type api_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many api_tokens.
     */
    data: api_tokensCreateManyInput | api_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * api_tokens update
   */
  export type api_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a api_tokens.
     */
    data: XOR<api_tokensUpdateInput, api_tokensUncheckedUpdateInput>
    /**
     * Choose, which api_tokens to update.
     */
    where: api_tokensWhereUniqueInput
  }

  /**
   * api_tokens updateMany
   */
  export type api_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update api_tokens.
     */
    data: XOR<api_tokensUpdateManyMutationInput, api_tokensUncheckedUpdateManyInput>
    /**
     * Filter which api_tokens to update
     */
    where?: api_tokensWhereInput
    /**
     * Limit how many api_tokens to update.
     */
    limit?: number
  }

  /**
   * api_tokens upsert
   */
  export type api_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the api_tokens to update in case it exists.
     */
    where: api_tokensWhereUniqueInput
    /**
     * In case the api_tokens found by the `where` argument doesn't exist, create a new api_tokens with this data.
     */
    create: XOR<api_tokensCreateInput, api_tokensUncheckedCreateInput>
    /**
     * In case the api_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<api_tokensUpdateInput, api_tokensUncheckedUpdateInput>
  }

  /**
   * api_tokens delete
   */
  export type api_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    /**
     * Filter which api_tokens to delete.
     */
    where: api_tokensWhereUniqueInput
  }

  /**
   * api_tokens deleteMany
   */
  export type api_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_tokens to delete
     */
    where?: api_tokensWhereInput
    /**
     * Limit how many api_tokens to delete.
     */
    limit?: number
  }

  /**
   * api_tokens without action
   */
  export type api_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
  }


  /**
   * Model attachments
   */

  export type AggregateAttachments = {
    _count: AttachmentsCountAggregateOutputType | null
    _avg: AttachmentsAvgAggregateOutputType | null
    _sum: AttachmentsSumAggregateOutputType | null
    _min: AttachmentsMinAggregateOutputType | null
    _max: AttachmentsMaxAggregateOutputType | null
  }

  export type AttachmentsAvgAggregateOutputType = {
    id: number | null
    run_result_id: number | null
    size_bytes: number | null
  }

  export type AttachmentsSumAggregateOutputType = {
    id: number | null
    run_result_id: number | null
    size_bytes: bigint | null
  }

  export type AttachmentsMinAggregateOutputType = {
    id: number | null
    run_result_id: number | null
    file_key: string | null
    mime_type: string | null
    size_bytes: bigint | null
    created_at: Date | null
  }

  export type AttachmentsMaxAggregateOutputType = {
    id: number | null
    run_result_id: number | null
    file_key: string | null
    mime_type: string | null
    size_bytes: bigint | null
    created_at: Date | null
  }

  export type AttachmentsCountAggregateOutputType = {
    id: number
    run_result_id: number
    file_key: number
    mime_type: number
    size_bytes: number
    created_at: number
    _all: number
  }


  export type AttachmentsAvgAggregateInputType = {
    id?: true
    run_result_id?: true
    size_bytes?: true
  }

  export type AttachmentsSumAggregateInputType = {
    id?: true
    run_result_id?: true
    size_bytes?: true
  }

  export type AttachmentsMinAggregateInputType = {
    id?: true
    run_result_id?: true
    file_key?: true
    mime_type?: true
    size_bytes?: true
    created_at?: true
  }

  export type AttachmentsMaxAggregateInputType = {
    id?: true
    run_result_id?: true
    file_key?: true
    mime_type?: true
    size_bytes?: true
    created_at?: true
  }

  export type AttachmentsCountAggregateInputType = {
    id?: true
    run_result_id?: true
    file_key?: true
    mime_type?: true
    size_bytes?: true
    created_at?: true
    _all?: true
  }

  export type AttachmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attachments to aggregate.
     */
    where?: attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attachments
    **/
    _count?: true | AttachmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentsMaxAggregateInputType
  }

  export type GetAttachmentsAggregateType<T extends AttachmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachments[P]>
      : GetScalarType<T[P], AggregateAttachments[P]>
  }




  export type attachmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attachmentsWhereInput
    orderBy?: attachmentsOrderByWithAggregationInput | attachmentsOrderByWithAggregationInput[]
    by: AttachmentsScalarFieldEnum[] | AttachmentsScalarFieldEnum
    having?: attachmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentsCountAggregateInputType | true
    _avg?: AttachmentsAvgAggregateInputType
    _sum?: AttachmentsSumAggregateInputType
    _min?: AttachmentsMinAggregateInputType
    _max?: AttachmentsMaxAggregateInputType
  }

  export type AttachmentsGroupByOutputType = {
    id: number
    run_result_id: number
    file_key: string
    mime_type: string | null
    size_bytes: bigint | null
    created_at: Date | null
    _count: AttachmentsCountAggregateOutputType | null
    _avg: AttachmentsAvgAggregateOutputType | null
    _sum: AttachmentsSumAggregateOutputType | null
    _min: AttachmentsMinAggregateOutputType | null
    _max: AttachmentsMaxAggregateOutputType | null
  }

  type GetAttachmentsGroupByPayload<T extends attachmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentsGroupByOutputType[P]>
        }
      >
    >


  export type attachmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    run_result_id?: boolean
    file_key?: boolean
    mime_type?: boolean
    size_bytes?: boolean
    created_at?: boolean
    test_run_results?: boolean | test_run_resultsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachments"]>



  export type attachmentsSelectScalar = {
    id?: boolean
    run_result_id?: boolean
    file_key?: boolean
    mime_type?: boolean
    size_bytes?: boolean
    created_at?: boolean
  }

  export type attachmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "run_result_id" | "file_key" | "mime_type" | "size_bytes" | "created_at", ExtArgs["result"]["attachments"]>
  export type attachmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_run_results?: boolean | test_run_resultsDefaultArgs<ExtArgs>
  }

  export type $attachmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attachments"
    objects: {
      test_run_results: Prisma.$test_run_resultsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      run_result_id: number
      file_key: string
      mime_type: string | null
      size_bytes: bigint | null
      created_at: Date | null
    }, ExtArgs["result"]["attachments"]>
    composites: {}
  }

  type attachmentsGetPayload<S extends boolean | null | undefined | attachmentsDefaultArgs> = $Result.GetResult<Prisma.$attachmentsPayload, S>

  type attachmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attachmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentsCountAggregateInputType | true
    }

  export interface attachmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attachments'], meta: { name: 'attachments' } }
    /**
     * Find zero or one Attachments that matches the filter.
     * @param {attachmentsFindUniqueArgs} args - Arguments to find a Attachments
     * @example
     * // Get one Attachments
     * const attachments = await prisma.attachments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attachmentsFindUniqueArgs>(args: SelectSubset<T, attachmentsFindUniqueArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attachmentsFindUniqueOrThrowArgs} args - Arguments to find a Attachments
     * @example
     * // Get one Attachments
     * const attachments = await prisma.attachments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attachmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, attachmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsFindFirstArgs} args - Arguments to find a Attachments
     * @example
     * // Get one Attachments
     * const attachments = await prisma.attachments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attachmentsFindFirstArgs>(args?: SelectSubset<T, attachmentsFindFirstArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsFindFirstOrThrowArgs} args - Arguments to find a Attachments
     * @example
     * // Get one Attachments
     * const attachments = await prisma.attachments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attachmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, attachmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachments.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentsWithIdOnly = await prisma.attachments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attachmentsFindManyArgs>(args?: SelectSubset<T, attachmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachments.
     * @param {attachmentsCreateArgs} args - Arguments to create a Attachments.
     * @example
     * // Create one Attachments
     * const Attachments = await prisma.attachments.create({
     *   data: {
     *     // ... data to create a Attachments
     *   }
     * })
     * 
     */
    create<T extends attachmentsCreateArgs>(args: SelectSubset<T, attachmentsCreateArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {attachmentsCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachments = await prisma.attachments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attachmentsCreateManyArgs>(args?: SelectSubset<T, attachmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attachments.
     * @param {attachmentsDeleteArgs} args - Arguments to delete one Attachments.
     * @example
     * // Delete one Attachments
     * const Attachments = await prisma.attachments.delete({
     *   where: {
     *     // ... filter to delete one Attachments
     *   }
     * })
     * 
     */
    delete<T extends attachmentsDeleteArgs>(args: SelectSubset<T, attachmentsDeleteArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachments.
     * @param {attachmentsUpdateArgs} args - Arguments to update one Attachments.
     * @example
     * // Update one Attachments
     * const attachments = await prisma.attachments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attachmentsUpdateArgs>(args: SelectSubset<T, attachmentsUpdateArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {attachmentsDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attachmentsDeleteManyArgs>(args?: SelectSubset<T, attachmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachments = await prisma.attachments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attachmentsUpdateManyArgs>(args: SelectSubset<T, attachmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachments.
     * @param {attachmentsUpsertArgs} args - Arguments to update or create a Attachments.
     * @example
     * // Update or create a Attachments
     * const attachments = await prisma.attachments.upsert({
     *   create: {
     *     // ... data to create a Attachments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachments we want to update
     *   }
     * })
     */
    upsert<T extends attachmentsUpsertArgs>(args: SelectSubset<T, attachmentsUpsertArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachments.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends attachmentsCountArgs>(
      args?: Subset<T, attachmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentsAggregateArgs>(args: Subset<T, AttachmentsAggregateArgs>): Prisma.PrismaPromise<GetAttachmentsAggregateType<T>>

    /**
     * Group by Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attachmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attachmentsGroupByArgs['orderBy'] }
        : { orderBy?: attachmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attachmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attachments model
   */
  readonly fields: attachmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attachments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attachmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_run_results<T extends test_run_resultsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_run_resultsDefaultArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attachments model
   */
  interface attachmentsFieldRefs {
    readonly id: FieldRef<"attachments", 'Int'>
    readonly run_result_id: FieldRef<"attachments", 'Int'>
    readonly file_key: FieldRef<"attachments", 'String'>
    readonly mime_type: FieldRef<"attachments", 'String'>
    readonly size_bytes: FieldRef<"attachments", 'BigInt'>
    readonly created_at: FieldRef<"attachments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attachments findUnique
   */
  export type attachmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where: attachmentsWhereUniqueInput
  }

  /**
   * attachments findUniqueOrThrow
   */
  export type attachmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where: attachmentsWhereUniqueInput
  }

  /**
   * attachments findFirst
   */
  export type attachmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where?: attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachments.
     */
    cursor?: attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachments.
     */
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * attachments findFirstOrThrow
   */
  export type attachmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where?: attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachments.
     */
    cursor?: attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachments.
     */
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * attachments findMany
   */
  export type attachmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where?: attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attachments.
     */
    cursor?: attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * attachments create
   */
  export type attachmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a attachments.
     */
    data: XOR<attachmentsCreateInput, attachmentsUncheckedCreateInput>
  }

  /**
   * attachments createMany
   */
  export type attachmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attachments.
     */
    data: attachmentsCreateManyInput | attachmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attachments update
   */
  export type attachmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a attachments.
     */
    data: XOR<attachmentsUpdateInput, attachmentsUncheckedUpdateInput>
    /**
     * Choose, which attachments to update.
     */
    where: attachmentsWhereUniqueInput
  }

  /**
   * attachments updateMany
   */
  export type attachmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attachments.
     */
    data: XOR<attachmentsUpdateManyMutationInput, attachmentsUncheckedUpdateManyInput>
    /**
     * Filter which attachments to update
     */
    where?: attachmentsWhereInput
    /**
     * Limit how many attachments to update.
     */
    limit?: number
  }

  /**
   * attachments upsert
   */
  export type attachmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the attachments to update in case it exists.
     */
    where: attachmentsWhereUniqueInput
    /**
     * In case the attachments found by the `where` argument doesn't exist, create a new attachments with this data.
     */
    create: XOR<attachmentsCreateInput, attachmentsUncheckedCreateInput>
    /**
     * In case the attachments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attachmentsUpdateInput, attachmentsUncheckedUpdateInput>
  }

  /**
   * attachments delete
   */
  export type attachmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter which attachments to delete.
     */
    where: attachmentsWhereUniqueInput
  }

  /**
   * attachments deleteMany
   */
  export type attachmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attachments to delete
     */
    where?: attachmentsWhereInput
    /**
     * Limit how many attachments to delete.
     */
    limit?: number
  }

  /**
   * attachments without action
   */
  export type attachmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
  }


  /**
   * Model audit_logs
   */

  export type AggregateAudit_logs = {
    _count: Audit_logsCountAggregateOutputType | null
    _avg: Audit_logsAvgAggregateOutputType | null
    _sum: Audit_logsSumAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  export type Audit_logsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    target_id: number | null
  }

  export type Audit_logsSumAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    target_id: bigint | null
  }

  export type Audit_logsMinAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    action: string | null
    target_type: string | null
    target_id: bigint | null
    created_at: Date | null
  }

  export type Audit_logsMaxAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    action: string | null
    target_type: string | null
    target_id: bigint | null
    created_at: Date | null
  }

  export type Audit_logsCountAggregateOutputType = {
    id: number
    user_id: number
    action: number
    target_type: number
    target_id: number
    meta: number
    created_at: number
    _all: number
  }


  export type Audit_logsAvgAggregateInputType = {
    id?: true
    user_id?: true
    target_id?: true
  }

  export type Audit_logsSumAggregateInputType = {
    id?: true
    user_id?: true
    target_id?: true
  }

  export type Audit_logsMinAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    target_type?: true
    target_id?: true
    created_at?: true
  }

  export type Audit_logsMaxAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    target_type?: true
    target_id?: true
    created_at?: true
  }

  export type Audit_logsCountAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    target_type?: true
    target_id?: true
    meta?: true
    created_at?: true
    _all?: true
  }

  export type Audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to aggregate.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_logs
    **/
    _count?: true | Audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Audit_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Audit_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_logsMaxAggregateInputType
  }

  export type GetAudit_logsAggregateType<T extends Audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_logs[P]>
      : GetScalarType<T[P], AggregateAudit_logs[P]>
  }




  export type audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithAggregationInput | audit_logsOrderByWithAggregationInput[]
    by: Audit_logsScalarFieldEnum[] | Audit_logsScalarFieldEnum
    having?: audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_logsCountAggregateInputType | true
    _avg?: Audit_logsAvgAggregateInputType
    _sum?: Audit_logsSumAggregateInputType
    _min?: Audit_logsMinAggregateInputType
    _max?: Audit_logsMaxAggregateInputType
  }

  export type Audit_logsGroupByOutputType = {
    id: bigint
    user_id: number | null
    action: string
    target_type: string | null
    target_id: bigint | null
    meta: JsonValue | null
    created_at: Date | null
    _count: Audit_logsCountAggregateOutputType | null
    _avg: Audit_logsAvgAggregateOutputType | null
    _sum: Audit_logsSumAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  type GetAudit_logsGroupByPayload<T extends audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    target_type?: boolean
    target_id?: boolean
    meta?: boolean
    created_at?: boolean
    users?: boolean | audit_logs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>



  export type audit_logsSelectScalar = {
    id?: boolean
    user_id?: boolean
    action?: boolean
    target_type?: boolean
    target_id?: boolean
    meta?: boolean
    created_at?: boolean
  }

  export type audit_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "action" | "target_type" | "target_id" | "meta" | "created_at", ExtArgs["result"]["audit_logs"]>
  export type audit_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | audit_logs$usersArgs<ExtArgs>
  }

  export type $audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_logs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: number | null
      action: string
      target_type: string | null
      target_id: bigint | null
      meta: Prisma.JsonValue | null
      created_at: Date | null
    }, ExtArgs["result"]["audit_logs"]>
    composites: {}
  }

  type audit_logsGetPayload<S extends boolean | null | undefined | audit_logsDefaultArgs> = $Result.GetResult<Prisma.$audit_logsPayload, S>

  type audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_logsCountAggregateInputType | true
    }

  export interface audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_logs'], meta: { name: 'audit_logs' } }
    /**
     * Find zero or one Audit_logs that matches the filter.
     * @param {audit_logsFindUniqueArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_logsFindUniqueArgs>(args: SelectSubset<T, audit_logsFindUniqueArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_logsFindFirstArgs>(args?: SelectSubset<T, audit_logsFindFirstArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany()
     * 
     * // Get first 10 Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends audit_logsFindManyArgs>(args?: SelectSubset<T, audit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_logs.
     * @param {audit_logsCreateArgs} args - Arguments to create a Audit_logs.
     * @example
     * // Create one Audit_logs
     * const Audit_logs = await prisma.audit_logs.create({
     *   data: {
     *     // ... data to create a Audit_logs
     *   }
     * })
     * 
     */
    create<T extends audit_logsCreateArgs>(args: SelectSubset<T, audit_logsCreateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_logs.
     * @param {audit_logsCreateManyArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_logsCreateManyArgs>(args?: SelectSubset<T, audit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Audit_logs.
     * @param {audit_logsDeleteArgs} args - Arguments to delete one Audit_logs.
     * @example
     * // Delete one Audit_logs
     * const Audit_logs = await prisma.audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Audit_logs
     *   }
     * })
     * 
     */
    delete<T extends audit_logsDeleteArgs>(args: SelectSubset<T, audit_logsDeleteArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_logs.
     * @param {audit_logsUpdateArgs} args - Arguments to update one Audit_logs.
     * @example
     * // Update one Audit_logs
     * const audit_logs = await prisma.audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_logsUpdateArgs>(args: SelectSubset<T, audit_logsUpdateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_logs.
     * @param {audit_logsDeleteManyArgs} args - Arguments to filter Audit_logs to delete.
     * @example
     * // Delete a few Audit_logs
     * const { count } = await prisma.audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_logsDeleteManyArgs>(args?: SelectSubset<T, audit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_logsUpdateManyArgs>(args: SelectSubset<T, audit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audit_logs.
     * @param {audit_logsUpsertArgs} args - Arguments to update or create a Audit_logs.
     * @example
     * // Update or create a Audit_logs
     * const audit_logs = await prisma.audit_logs.upsert({
     *   create: {
     *     // ... data to create a Audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_logs we want to update
     *   }
     * })
     */
    upsert<T extends audit_logsUpsertArgs>(args: SelectSubset<T, audit_logsUpsertArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsCountArgs} args - Arguments to filter Audit_logs to count.
     * @example
     * // Count the number of Audit_logs
     * const count = await prisma.audit_logs.count({
     *   where: {
     *     // ... the filter for the Audit_logs we want to count
     *   }
     * })
    **/
    count<T extends audit_logsCountArgs>(
      args?: Subset<T, audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_logsAggregateArgs>(args: Subset<T, Audit_logsAggregateArgs>): Prisma.PrismaPromise<GetAudit_logsAggregateType<T>>

    /**
     * Group by Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_logs model
   */
  readonly fields: audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends audit_logs$usersArgs<ExtArgs> = {}>(args?: Subset<T, audit_logs$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_logs model
   */
  interface audit_logsFieldRefs {
    readonly id: FieldRef<"audit_logs", 'BigInt'>
    readonly user_id: FieldRef<"audit_logs", 'Int'>
    readonly action: FieldRef<"audit_logs", 'String'>
    readonly target_type: FieldRef<"audit_logs", 'String'>
    readonly target_id: FieldRef<"audit_logs", 'BigInt'>
    readonly meta: FieldRef<"audit_logs", 'Json'>
    readonly created_at: FieldRef<"audit_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * audit_logs findUnique
   */
  export type audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findUniqueOrThrow
   */
  export type audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findFirst
   */
  export type audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findFirstOrThrow
   */
  export type audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findMany
   */
  export type audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs create
   */
  export type audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a audit_logs.
     */
    data: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
  }

  /**
   * audit_logs createMany
   */
  export type audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_logs update
   */
  export type audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a audit_logs.
     */
    data: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
    /**
     * Choose, which audit_logs to update.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs updateMany
   */
  export type audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
  }

  /**
   * audit_logs upsert
   */
  export type audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the audit_logs to update in case it exists.
     */
    where: audit_logsWhereUniqueInput
    /**
     * In case the audit_logs found by the `where` argument doesn't exist, create a new audit_logs with this data.
     */
    create: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
    /**
     * In case the audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
  }

  /**
   * audit_logs delete
   */
  export type audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter which audit_logs to delete.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs deleteMany
   */
  export type audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to delete
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to delete.
     */
    limit?: number
  }

  /**
   * audit_logs.users
   */
  export type audit_logs$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * audit_logs without action
   */
  export type audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
  }


  /**
   * Model feature_flags
   */

  export type AggregateFeature_flags = {
    _count: Feature_flagsCountAggregateOutputType | null
    _avg: Feature_flagsAvgAggregateOutputType | null
    _sum: Feature_flagsSumAggregateOutputType | null
    _min: Feature_flagsMinAggregateOutputType | null
    _max: Feature_flagsMaxAggregateOutputType | null
  }

  export type Feature_flagsAvgAggregateOutputType = {
    rollout_percentage: number | null
  }

  export type Feature_flagsSumAggregateOutputType = {
    rollout_percentage: number | null
  }

  export type Feature_flagsMinAggregateOutputType = {
    flag_name: string | null
    is_enabled: boolean | null
    rollout_percentage: number | null
    updated_at: Date | null
  }

  export type Feature_flagsMaxAggregateOutputType = {
    flag_name: string | null
    is_enabled: boolean | null
    rollout_percentage: number | null
    updated_at: Date | null
  }

  export type Feature_flagsCountAggregateOutputType = {
    flag_name: number
    is_enabled: number
    rollout_percentage: number
    updated_at: number
    _all: number
  }


  export type Feature_flagsAvgAggregateInputType = {
    rollout_percentage?: true
  }

  export type Feature_flagsSumAggregateInputType = {
    rollout_percentage?: true
  }

  export type Feature_flagsMinAggregateInputType = {
    flag_name?: true
    is_enabled?: true
    rollout_percentage?: true
    updated_at?: true
  }

  export type Feature_flagsMaxAggregateInputType = {
    flag_name?: true
    is_enabled?: true
    rollout_percentage?: true
    updated_at?: true
  }

  export type Feature_flagsCountAggregateInputType = {
    flag_name?: true
    is_enabled?: true
    rollout_percentage?: true
    updated_at?: true
    _all?: true
  }

  export type Feature_flagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feature_flags to aggregate.
     */
    where?: feature_flagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_flags to fetch.
     */
    orderBy?: feature_flagsOrderByWithRelationInput | feature_flagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feature_flagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feature_flags
    **/
    _count?: true | Feature_flagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Feature_flagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Feature_flagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Feature_flagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Feature_flagsMaxAggregateInputType
  }

  export type GetFeature_flagsAggregateType<T extends Feature_flagsAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature_flags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature_flags[P]>
      : GetScalarType<T[P], AggregateFeature_flags[P]>
  }




  export type feature_flagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feature_flagsWhereInput
    orderBy?: feature_flagsOrderByWithAggregationInput | feature_flagsOrderByWithAggregationInput[]
    by: Feature_flagsScalarFieldEnum[] | Feature_flagsScalarFieldEnum
    having?: feature_flagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Feature_flagsCountAggregateInputType | true
    _avg?: Feature_flagsAvgAggregateInputType
    _sum?: Feature_flagsSumAggregateInputType
    _min?: Feature_flagsMinAggregateInputType
    _max?: Feature_flagsMaxAggregateInputType
  }

  export type Feature_flagsGroupByOutputType = {
    flag_name: string
    is_enabled: boolean | null
    rollout_percentage: number | null
    updated_at: Date | null
    _count: Feature_flagsCountAggregateOutputType | null
    _avg: Feature_flagsAvgAggregateOutputType | null
    _sum: Feature_flagsSumAggregateOutputType | null
    _min: Feature_flagsMinAggregateOutputType | null
    _max: Feature_flagsMaxAggregateOutputType | null
  }

  type GetFeature_flagsGroupByPayload<T extends feature_flagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Feature_flagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Feature_flagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Feature_flagsGroupByOutputType[P]>
            : GetScalarType<T[P], Feature_flagsGroupByOutputType[P]>
        }
      >
    >


  export type feature_flagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    flag_name?: boolean
    is_enabled?: boolean
    rollout_percentage?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["feature_flags"]>



  export type feature_flagsSelectScalar = {
    flag_name?: boolean
    is_enabled?: boolean
    rollout_percentage?: boolean
    updated_at?: boolean
  }

  export type feature_flagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"flag_name" | "is_enabled" | "rollout_percentage" | "updated_at", ExtArgs["result"]["feature_flags"]>

  export type $feature_flagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feature_flags"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      flag_name: string
      is_enabled: boolean | null
      rollout_percentage: number | null
      updated_at: Date | null
    }, ExtArgs["result"]["feature_flags"]>
    composites: {}
  }

  type feature_flagsGetPayload<S extends boolean | null | undefined | feature_flagsDefaultArgs> = $Result.GetResult<Prisma.$feature_flagsPayload, S>

  type feature_flagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<feature_flagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Feature_flagsCountAggregateInputType | true
    }

  export interface feature_flagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feature_flags'], meta: { name: 'feature_flags' } }
    /**
     * Find zero or one Feature_flags that matches the filter.
     * @param {feature_flagsFindUniqueArgs} args - Arguments to find a Feature_flags
     * @example
     * // Get one Feature_flags
     * const feature_flags = await prisma.feature_flags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feature_flagsFindUniqueArgs>(args: SelectSubset<T, feature_flagsFindUniqueArgs<ExtArgs>>): Prisma__feature_flagsClient<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feature_flags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {feature_flagsFindUniqueOrThrowArgs} args - Arguments to find a Feature_flags
     * @example
     * // Get one Feature_flags
     * const feature_flags = await prisma.feature_flags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feature_flagsFindUniqueOrThrowArgs>(args: SelectSubset<T, feature_flagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feature_flagsClient<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature_flags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_flagsFindFirstArgs} args - Arguments to find a Feature_flags
     * @example
     * // Get one Feature_flags
     * const feature_flags = await prisma.feature_flags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feature_flagsFindFirstArgs>(args?: SelectSubset<T, feature_flagsFindFirstArgs<ExtArgs>>): Prisma__feature_flagsClient<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature_flags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_flagsFindFirstOrThrowArgs} args - Arguments to find a Feature_flags
     * @example
     * // Get one Feature_flags
     * const feature_flags = await prisma.feature_flags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feature_flagsFindFirstOrThrowArgs>(args?: SelectSubset<T, feature_flagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__feature_flagsClient<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feature_flags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_flagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feature_flags
     * const feature_flags = await prisma.feature_flags.findMany()
     * 
     * // Get first 10 Feature_flags
     * const feature_flags = await prisma.feature_flags.findMany({ take: 10 })
     * 
     * // Only select the `flag_name`
     * const feature_flagsWithFlag_nameOnly = await prisma.feature_flags.findMany({ select: { flag_name: true } })
     * 
     */
    findMany<T extends feature_flagsFindManyArgs>(args?: SelectSubset<T, feature_flagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feature_flags.
     * @param {feature_flagsCreateArgs} args - Arguments to create a Feature_flags.
     * @example
     * // Create one Feature_flags
     * const Feature_flags = await prisma.feature_flags.create({
     *   data: {
     *     // ... data to create a Feature_flags
     *   }
     * })
     * 
     */
    create<T extends feature_flagsCreateArgs>(args: SelectSubset<T, feature_flagsCreateArgs<ExtArgs>>): Prisma__feature_flagsClient<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feature_flags.
     * @param {feature_flagsCreateManyArgs} args - Arguments to create many Feature_flags.
     * @example
     * // Create many Feature_flags
     * const feature_flags = await prisma.feature_flags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feature_flagsCreateManyArgs>(args?: SelectSubset<T, feature_flagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feature_flags.
     * @param {feature_flagsDeleteArgs} args - Arguments to delete one Feature_flags.
     * @example
     * // Delete one Feature_flags
     * const Feature_flags = await prisma.feature_flags.delete({
     *   where: {
     *     // ... filter to delete one Feature_flags
     *   }
     * })
     * 
     */
    delete<T extends feature_flagsDeleteArgs>(args: SelectSubset<T, feature_flagsDeleteArgs<ExtArgs>>): Prisma__feature_flagsClient<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feature_flags.
     * @param {feature_flagsUpdateArgs} args - Arguments to update one Feature_flags.
     * @example
     * // Update one Feature_flags
     * const feature_flags = await prisma.feature_flags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feature_flagsUpdateArgs>(args: SelectSubset<T, feature_flagsUpdateArgs<ExtArgs>>): Prisma__feature_flagsClient<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feature_flags.
     * @param {feature_flagsDeleteManyArgs} args - Arguments to filter Feature_flags to delete.
     * @example
     * // Delete a few Feature_flags
     * const { count } = await prisma.feature_flags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feature_flagsDeleteManyArgs>(args?: SelectSubset<T, feature_flagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feature_flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_flagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feature_flags
     * const feature_flags = await prisma.feature_flags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feature_flagsUpdateManyArgs>(args: SelectSubset<T, feature_flagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feature_flags.
     * @param {feature_flagsUpsertArgs} args - Arguments to update or create a Feature_flags.
     * @example
     * // Update or create a Feature_flags
     * const feature_flags = await prisma.feature_flags.upsert({
     *   create: {
     *     // ... data to create a Feature_flags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature_flags we want to update
     *   }
     * })
     */
    upsert<T extends feature_flagsUpsertArgs>(args: SelectSubset<T, feature_flagsUpsertArgs<ExtArgs>>): Prisma__feature_flagsClient<$Result.GetResult<Prisma.$feature_flagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feature_flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_flagsCountArgs} args - Arguments to filter Feature_flags to count.
     * @example
     * // Count the number of Feature_flags
     * const count = await prisma.feature_flags.count({
     *   where: {
     *     // ... the filter for the Feature_flags we want to count
     *   }
     * })
    **/
    count<T extends feature_flagsCountArgs>(
      args?: Subset<T, feature_flagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Feature_flagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature_flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Feature_flagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Feature_flagsAggregateArgs>(args: Subset<T, Feature_flagsAggregateArgs>): Prisma.PrismaPromise<GetFeature_flagsAggregateType<T>>

    /**
     * Group by Feature_flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feature_flagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feature_flagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feature_flagsGroupByArgs['orderBy'] }
        : { orderBy?: feature_flagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feature_flagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeature_flagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feature_flags model
   */
  readonly fields: feature_flagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feature_flags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feature_flagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feature_flags model
   */
  interface feature_flagsFieldRefs {
    readonly flag_name: FieldRef<"feature_flags", 'String'>
    readonly is_enabled: FieldRef<"feature_flags", 'Boolean'>
    readonly rollout_percentage: FieldRef<"feature_flags", 'Int'>
    readonly updated_at: FieldRef<"feature_flags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * feature_flags findUnique
   */
  export type feature_flagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * Filter, which feature_flags to fetch.
     */
    where: feature_flagsWhereUniqueInput
  }

  /**
   * feature_flags findUniqueOrThrow
   */
  export type feature_flagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * Filter, which feature_flags to fetch.
     */
    where: feature_flagsWhereUniqueInput
  }

  /**
   * feature_flags findFirst
   */
  export type feature_flagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * Filter, which feature_flags to fetch.
     */
    where?: feature_flagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_flags to fetch.
     */
    orderBy?: feature_flagsOrderByWithRelationInput | feature_flagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feature_flags.
     */
    cursor?: feature_flagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feature_flags.
     */
    distinct?: Feature_flagsScalarFieldEnum | Feature_flagsScalarFieldEnum[]
  }

  /**
   * feature_flags findFirstOrThrow
   */
  export type feature_flagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * Filter, which feature_flags to fetch.
     */
    where?: feature_flagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_flags to fetch.
     */
    orderBy?: feature_flagsOrderByWithRelationInput | feature_flagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feature_flags.
     */
    cursor?: feature_flagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feature_flags.
     */
    distinct?: Feature_flagsScalarFieldEnum | Feature_flagsScalarFieldEnum[]
  }

  /**
   * feature_flags findMany
   */
  export type feature_flagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * Filter, which feature_flags to fetch.
     */
    where?: feature_flagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feature_flags to fetch.
     */
    orderBy?: feature_flagsOrderByWithRelationInput | feature_flagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feature_flags.
     */
    cursor?: feature_flagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feature_flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feature_flags.
     */
    skip?: number
    distinct?: Feature_flagsScalarFieldEnum | Feature_flagsScalarFieldEnum[]
  }

  /**
   * feature_flags create
   */
  export type feature_flagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * The data needed to create a feature_flags.
     */
    data: XOR<feature_flagsCreateInput, feature_flagsUncheckedCreateInput>
  }

  /**
   * feature_flags createMany
   */
  export type feature_flagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feature_flags.
     */
    data: feature_flagsCreateManyInput | feature_flagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feature_flags update
   */
  export type feature_flagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * The data needed to update a feature_flags.
     */
    data: XOR<feature_flagsUpdateInput, feature_flagsUncheckedUpdateInput>
    /**
     * Choose, which feature_flags to update.
     */
    where: feature_flagsWhereUniqueInput
  }

  /**
   * feature_flags updateMany
   */
  export type feature_flagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feature_flags.
     */
    data: XOR<feature_flagsUpdateManyMutationInput, feature_flagsUncheckedUpdateManyInput>
    /**
     * Filter which feature_flags to update
     */
    where?: feature_flagsWhereInput
    /**
     * Limit how many feature_flags to update.
     */
    limit?: number
  }

  /**
   * feature_flags upsert
   */
  export type feature_flagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * The filter to search for the feature_flags to update in case it exists.
     */
    where: feature_flagsWhereUniqueInput
    /**
     * In case the feature_flags found by the `where` argument doesn't exist, create a new feature_flags with this data.
     */
    create: XOR<feature_flagsCreateInput, feature_flagsUncheckedCreateInput>
    /**
     * In case the feature_flags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feature_flagsUpdateInput, feature_flagsUncheckedUpdateInput>
  }

  /**
   * feature_flags delete
   */
  export type feature_flagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
    /**
     * Filter which feature_flags to delete.
     */
    where: feature_flagsWhereUniqueInput
  }

  /**
   * feature_flags deleteMany
   */
  export type feature_flagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feature_flags to delete
     */
    where?: feature_flagsWhereInput
    /**
     * Limit how many feature_flags to delete.
     */
    limit?: number
  }

  /**
   * feature_flags without action
   */
  export type feature_flagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feature_flags
     */
    select?: feature_flagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feature_flags
     */
    omit?: feature_flagsOmit<ExtArgs> | null
  }


  /**
   * Model job_logs
   */

  export type AggregateJob_logs = {
    _count: Job_logsCountAggregateOutputType | null
    _avg: Job_logsAvgAggregateOutputType | null
    _sum: Job_logsSumAggregateOutputType | null
    _min: Job_logsMinAggregateOutputType | null
    _max: Job_logsMaxAggregateOutputType | null
  }

  export type Job_logsAvgAggregateOutputType = {
    id: number | null
  }

  export type Job_logsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Job_logsMinAggregateOutputType = {
    id: bigint | null
    job_name: string | null
    status: $Enums.job_logs_status | null
    message: string | null
    started_at: Date | null
    ended_at: Date | null
  }

  export type Job_logsMaxAggregateOutputType = {
    id: bigint | null
    job_name: string | null
    status: $Enums.job_logs_status | null
    message: string | null
    started_at: Date | null
    ended_at: Date | null
  }

  export type Job_logsCountAggregateOutputType = {
    id: number
    job_name: number
    status: number
    message: number
    started_at: number
    ended_at: number
    _all: number
  }


  export type Job_logsAvgAggregateInputType = {
    id?: true
  }

  export type Job_logsSumAggregateInputType = {
    id?: true
  }

  export type Job_logsMinAggregateInputType = {
    id?: true
    job_name?: true
    status?: true
    message?: true
    started_at?: true
    ended_at?: true
  }

  export type Job_logsMaxAggregateInputType = {
    id?: true
    job_name?: true
    status?: true
    message?: true
    started_at?: true
    ended_at?: true
  }

  export type Job_logsCountAggregateInputType = {
    id?: true
    job_name?: true
    status?: true
    message?: true
    started_at?: true
    ended_at?: true
    _all?: true
  }

  export type Job_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_logs to aggregate.
     */
    where?: job_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_logs to fetch.
     */
    orderBy?: job_logsOrderByWithRelationInput | job_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_logs
    **/
    _count?: true | Job_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_logsMaxAggregateInputType
  }

  export type GetJob_logsAggregateType<T extends Job_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_logs[P]>
      : GetScalarType<T[P], AggregateJob_logs[P]>
  }




  export type job_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_logsWhereInput
    orderBy?: job_logsOrderByWithAggregationInput | job_logsOrderByWithAggregationInput[]
    by: Job_logsScalarFieldEnum[] | Job_logsScalarFieldEnum
    having?: job_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_logsCountAggregateInputType | true
    _avg?: Job_logsAvgAggregateInputType
    _sum?: Job_logsSumAggregateInputType
    _min?: Job_logsMinAggregateInputType
    _max?: Job_logsMaxAggregateInputType
  }

  export type Job_logsGroupByOutputType = {
    id: bigint
    job_name: string
    status: $Enums.job_logs_status
    message: string | null
    started_at: Date | null
    ended_at: Date | null
    _count: Job_logsCountAggregateOutputType | null
    _avg: Job_logsAvgAggregateOutputType | null
    _sum: Job_logsSumAggregateOutputType | null
    _min: Job_logsMinAggregateOutputType | null
    _max: Job_logsMaxAggregateOutputType | null
  }

  type GetJob_logsGroupByPayload<T extends job_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Job_logsGroupByOutputType[P]>
        }
      >
    >


  export type job_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_name?: boolean
    status?: boolean
    message?: boolean
    started_at?: boolean
    ended_at?: boolean
  }, ExtArgs["result"]["job_logs"]>



  export type job_logsSelectScalar = {
    id?: boolean
    job_name?: boolean
    status?: boolean
    message?: boolean
    started_at?: boolean
    ended_at?: boolean
  }

  export type job_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_name" | "status" | "message" | "started_at" | "ended_at", ExtArgs["result"]["job_logs"]>

  export type $job_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      job_name: string
      status: $Enums.job_logs_status
      message: string | null
      started_at: Date | null
      ended_at: Date | null
    }, ExtArgs["result"]["job_logs"]>
    composites: {}
  }

  type job_logsGetPayload<S extends boolean | null | undefined | job_logsDefaultArgs> = $Result.GetResult<Prisma.$job_logsPayload, S>

  type job_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_logsCountAggregateInputType | true
    }

  export interface job_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_logs'], meta: { name: 'job_logs' } }
    /**
     * Find zero or one Job_logs that matches the filter.
     * @param {job_logsFindUniqueArgs} args - Arguments to find a Job_logs
     * @example
     * // Get one Job_logs
     * const job_logs = await prisma.job_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_logsFindUniqueArgs>(args: SelectSubset<T, job_logsFindUniqueArgs<ExtArgs>>): Prisma__job_logsClient<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_logsFindUniqueOrThrowArgs} args - Arguments to find a Job_logs
     * @example
     * // Get one Job_logs
     * const job_logs = await prisma.job_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, job_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_logsClient<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_logsFindFirstArgs} args - Arguments to find a Job_logs
     * @example
     * // Get one Job_logs
     * const job_logs = await prisma.job_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_logsFindFirstArgs>(args?: SelectSubset<T, job_logsFindFirstArgs<ExtArgs>>): Prisma__job_logsClient<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_logsFindFirstOrThrowArgs} args - Arguments to find a Job_logs
     * @example
     * // Get one Job_logs
     * const job_logs = await prisma.job_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, job_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_logsClient<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_logs
     * const job_logs = await prisma.job_logs.findMany()
     * 
     * // Get first 10 Job_logs
     * const job_logs = await prisma.job_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_logsWithIdOnly = await prisma.job_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_logsFindManyArgs>(args?: SelectSubset<T, job_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_logs.
     * @param {job_logsCreateArgs} args - Arguments to create a Job_logs.
     * @example
     * // Create one Job_logs
     * const Job_logs = await prisma.job_logs.create({
     *   data: {
     *     // ... data to create a Job_logs
     *   }
     * })
     * 
     */
    create<T extends job_logsCreateArgs>(args: SelectSubset<T, job_logsCreateArgs<ExtArgs>>): Prisma__job_logsClient<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_logs.
     * @param {job_logsCreateManyArgs} args - Arguments to create many Job_logs.
     * @example
     * // Create many Job_logs
     * const job_logs = await prisma.job_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_logsCreateManyArgs>(args?: SelectSubset<T, job_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Job_logs.
     * @param {job_logsDeleteArgs} args - Arguments to delete one Job_logs.
     * @example
     * // Delete one Job_logs
     * const Job_logs = await prisma.job_logs.delete({
     *   where: {
     *     // ... filter to delete one Job_logs
     *   }
     * })
     * 
     */
    delete<T extends job_logsDeleteArgs>(args: SelectSubset<T, job_logsDeleteArgs<ExtArgs>>): Prisma__job_logsClient<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_logs.
     * @param {job_logsUpdateArgs} args - Arguments to update one Job_logs.
     * @example
     * // Update one Job_logs
     * const job_logs = await prisma.job_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_logsUpdateArgs>(args: SelectSubset<T, job_logsUpdateArgs<ExtArgs>>): Prisma__job_logsClient<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_logs.
     * @param {job_logsDeleteManyArgs} args - Arguments to filter Job_logs to delete.
     * @example
     * // Delete a few Job_logs
     * const { count } = await prisma.job_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_logsDeleteManyArgs>(args?: SelectSubset<T, job_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_logs
     * const job_logs = await prisma.job_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_logsUpdateManyArgs>(args: SelectSubset<T, job_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job_logs.
     * @param {job_logsUpsertArgs} args - Arguments to update or create a Job_logs.
     * @example
     * // Update or create a Job_logs
     * const job_logs = await prisma.job_logs.upsert({
     *   create: {
     *     // ... data to create a Job_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_logs we want to update
     *   }
     * })
     */
    upsert<T extends job_logsUpsertArgs>(args: SelectSubset<T, job_logsUpsertArgs<ExtArgs>>): Prisma__job_logsClient<$Result.GetResult<Prisma.$job_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_logsCountArgs} args - Arguments to filter Job_logs to count.
     * @example
     * // Count the number of Job_logs
     * const count = await prisma.job_logs.count({
     *   where: {
     *     // ... the filter for the Job_logs we want to count
     *   }
     * })
    **/
    count<T extends job_logsCountArgs>(
      args?: Subset<T, job_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_logsAggregateArgs>(args: Subset<T, Job_logsAggregateArgs>): Prisma.PrismaPromise<GetJob_logsAggregateType<T>>

    /**
     * Group by Job_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_logsGroupByArgs['orderBy'] }
        : { orderBy?: job_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_logs model
   */
  readonly fields: job_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_logs model
   */
  interface job_logsFieldRefs {
    readonly id: FieldRef<"job_logs", 'BigInt'>
    readonly job_name: FieldRef<"job_logs", 'String'>
    readonly status: FieldRef<"job_logs", 'job_logs_status'>
    readonly message: FieldRef<"job_logs", 'String'>
    readonly started_at: FieldRef<"job_logs", 'DateTime'>
    readonly ended_at: FieldRef<"job_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_logs findUnique
   */
  export type job_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * Filter, which job_logs to fetch.
     */
    where: job_logsWhereUniqueInput
  }

  /**
   * job_logs findUniqueOrThrow
   */
  export type job_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * Filter, which job_logs to fetch.
     */
    where: job_logsWhereUniqueInput
  }

  /**
   * job_logs findFirst
   */
  export type job_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * Filter, which job_logs to fetch.
     */
    where?: job_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_logs to fetch.
     */
    orderBy?: job_logsOrderByWithRelationInput | job_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_logs.
     */
    cursor?: job_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_logs.
     */
    distinct?: Job_logsScalarFieldEnum | Job_logsScalarFieldEnum[]
  }

  /**
   * job_logs findFirstOrThrow
   */
  export type job_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * Filter, which job_logs to fetch.
     */
    where?: job_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_logs to fetch.
     */
    orderBy?: job_logsOrderByWithRelationInput | job_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_logs.
     */
    cursor?: job_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_logs.
     */
    distinct?: Job_logsScalarFieldEnum | Job_logsScalarFieldEnum[]
  }

  /**
   * job_logs findMany
   */
  export type job_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * Filter, which job_logs to fetch.
     */
    where?: job_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_logs to fetch.
     */
    orderBy?: job_logsOrderByWithRelationInput | job_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_logs.
     */
    cursor?: job_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_logs.
     */
    skip?: number
    distinct?: Job_logsScalarFieldEnum | Job_logsScalarFieldEnum[]
  }

  /**
   * job_logs create
   */
  export type job_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a job_logs.
     */
    data: XOR<job_logsCreateInput, job_logsUncheckedCreateInput>
  }

  /**
   * job_logs createMany
   */
  export type job_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_logs.
     */
    data: job_logsCreateManyInput | job_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_logs update
   */
  export type job_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a job_logs.
     */
    data: XOR<job_logsUpdateInput, job_logsUncheckedUpdateInput>
    /**
     * Choose, which job_logs to update.
     */
    where: job_logsWhereUniqueInput
  }

  /**
   * job_logs updateMany
   */
  export type job_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_logs.
     */
    data: XOR<job_logsUpdateManyMutationInput, job_logsUncheckedUpdateManyInput>
    /**
     * Filter which job_logs to update
     */
    where?: job_logsWhereInput
    /**
     * Limit how many job_logs to update.
     */
    limit?: number
  }

  /**
   * job_logs upsert
   */
  export type job_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the job_logs to update in case it exists.
     */
    where: job_logsWhereUniqueInput
    /**
     * In case the job_logs found by the `where` argument doesn't exist, create a new job_logs with this data.
     */
    create: XOR<job_logsCreateInput, job_logsUncheckedCreateInput>
    /**
     * In case the job_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_logsUpdateInput, job_logsUncheckedUpdateInput>
  }

  /**
   * job_logs delete
   */
  export type job_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
    /**
     * Filter which job_logs to delete.
     */
    where: job_logsWhereUniqueInput
  }

  /**
   * job_logs deleteMany
   */
  export type job_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_logs to delete
     */
    where?: job_logsWhereInput
    /**
     * Limit how many job_logs to delete.
     */
    limit?: number
  }

  /**
   * job_logs without action
   */
  export type job_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_logs
     */
    select?: job_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_logs
     */
    omit?: job_logsOmit<ExtArgs> | null
  }


  /**
   * Model metrics_daily
   */

  export type AggregateMetrics_daily = {
    _count: Metrics_dailyCountAggregateOutputType | null
    _avg: Metrics_dailyAvgAggregateOutputType | null
    _sum: Metrics_dailySumAggregateOutputType | null
    _min: Metrics_dailyMinAggregateOutputType | null
    _max: Metrics_dailyMaxAggregateOutputType | null
  }

  export type Metrics_dailyAvgAggregateOutputType = {
    suite_id: number | null
    pass_rate: Decimal | null
    avg_duration_ms: number | null
  }

  export type Metrics_dailySumAggregateOutputType = {
    suite_id: number | null
    pass_rate: Decimal | null
    avg_duration_ms: number | null
  }

  export type Metrics_dailyMinAggregateOutputType = {
    metric_date: Date | null
    suite_id: number | null
    pass_rate: Decimal | null
    avg_duration_ms: number | null
  }

  export type Metrics_dailyMaxAggregateOutputType = {
    metric_date: Date | null
    suite_id: number | null
    pass_rate: Decimal | null
    avg_duration_ms: number | null
  }

  export type Metrics_dailyCountAggregateOutputType = {
    metric_date: number
    suite_id: number
    pass_rate: number
    avg_duration_ms: number
    _all: number
  }


  export type Metrics_dailyAvgAggregateInputType = {
    suite_id?: true
    pass_rate?: true
    avg_duration_ms?: true
  }

  export type Metrics_dailySumAggregateInputType = {
    suite_id?: true
    pass_rate?: true
    avg_duration_ms?: true
  }

  export type Metrics_dailyMinAggregateInputType = {
    metric_date?: true
    suite_id?: true
    pass_rate?: true
    avg_duration_ms?: true
  }

  export type Metrics_dailyMaxAggregateInputType = {
    metric_date?: true
    suite_id?: true
    pass_rate?: true
    avg_duration_ms?: true
  }

  export type Metrics_dailyCountAggregateInputType = {
    metric_date?: true
    suite_id?: true
    pass_rate?: true
    avg_duration_ms?: true
    _all?: true
  }

  export type Metrics_dailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which metrics_daily to aggregate.
     */
    where?: metrics_dailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metrics_dailies to fetch.
     */
    orderBy?: metrics_dailyOrderByWithRelationInput | metrics_dailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: metrics_dailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metrics_dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metrics_dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned metrics_dailies
    **/
    _count?: true | Metrics_dailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Metrics_dailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Metrics_dailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Metrics_dailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Metrics_dailyMaxAggregateInputType
  }

  export type GetMetrics_dailyAggregateType<T extends Metrics_dailyAggregateArgs> = {
        [P in keyof T & keyof AggregateMetrics_daily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetrics_daily[P]>
      : GetScalarType<T[P], AggregateMetrics_daily[P]>
  }




  export type metrics_dailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metrics_dailyWhereInput
    orderBy?: metrics_dailyOrderByWithAggregationInput | metrics_dailyOrderByWithAggregationInput[]
    by: Metrics_dailyScalarFieldEnum[] | Metrics_dailyScalarFieldEnum
    having?: metrics_dailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Metrics_dailyCountAggregateInputType | true
    _avg?: Metrics_dailyAvgAggregateInputType
    _sum?: Metrics_dailySumAggregateInputType
    _min?: Metrics_dailyMinAggregateInputType
    _max?: Metrics_dailyMaxAggregateInputType
  }

  export type Metrics_dailyGroupByOutputType = {
    metric_date: Date
    suite_id: number
    pass_rate: Decimal | null
    avg_duration_ms: number | null
    _count: Metrics_dailyCountAggregateOutputType | null
    _avg: Metrics_dailyAvgAggregateOutputType | null
    _sum: Metrics_dailySumAggregateOutputType | null
    _min: Metrics_dailyMinAggregateOutputType | null
    _max: Metrics_dailyMaxAggregateOutputType | null
  }

  type GetMetrics_dailyGroupByPayload<T extends metrics_dailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Metrics_dailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Metrics_dailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Metrics_dailyGroupByOutputType[P]>
            : GetScalarType<T[P], Metrics_dailyGroupByOutputType[P]>
        }
      >
    >


  export type metrics_dailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    metric_date?: boolean
    suite_id?: boolean
    pass_rate?: boolean
    avg_duration_ms?: boolean
  }, ExtArgs["result"]["metrics_daily"]>



  export type metrics_dailySelectScalar = {
    metric_date?: boolean
    suite_id?: boolean
    pass_rate?: boolean
    avg_duration_ms?: boolean
  }

  export type metrics_dailyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"metric_date" | "suite_id" | "pass_rate" | "avg_duration_ms", ExtArgs["result"]["metrics_daily"]>

  export type $metrics_dailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "metrics_daily"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      metric_date: Date
      suite_id: number
      pass_rate: Prisma.Decimal | null
      avg_duration_ms: number | null
    }, ExtArgs["result"]["metrics_daily"]>
    composites: {}
  }

  type metrics_dailyGetPayload<S extends boolean | null | undefined | metrics_dailyDefaultArgs> = $Result.GetResult<Prisma.$metrics_dailyPayload, S>

  type metrics_dailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<metrics_dailyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Metrics_dailyCountAggregateInputType | true
    }

  export interface metrics_dailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['metrics_daily'], meta: { name: 'metrics_daily' } }
    /**
     * Find zero or one Metrics_daily that matches the filter.
     * @param {metrics_dailyFindUniqueArgs} args - Arguments to find a Metrics_daily
     * @example
     * // Get one Metrics_daily
     * const metrics_daily = await prisma.metrics_daily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends metrics_dailyFindUniqueArgs>(args: SelectSubset<T, metrics_dailyFindUniqueArgs<ExtArgs>>): Prisma__metrics_dailyClient<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Metrics_daily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {metrics_dailyFindUniqueOrThrowArgs} args - Arguments to find a Metrics_daily
     * @example
     * // Get one Metrics_daily
     * const metrics_daily = await prisma.metrics_daily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends metrics_dailyFindUniqueOrThrowArgs>(args: SelectSubset<T, metrics_dailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__metrics_dailyClient<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metrics_daily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metrics_dailyFindFirstArgs} args - Arguments to find a Metrics_daily
     * @example
     * // Get one Metrics_daily
     * const metrics_daily = await prisma.metrics_daily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends metrics_dailyFindFirstArgs>(args?: SelectSubset<T, metrics_dailyFindFirstArgs<ExtArgs>>): Prisma__metrics_dailyClient<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metrics_daily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metrics_dailyFindFirstOrThrowArgs} args - Arguments to find a Metrics_daily
     * @example
     * // Get one Metrics_daily
     * const metrics_daily = await prisma.metrics_daily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends metrics_dailyFindFirstOrThrowArgs>(args?: SelectSubset<T, metrics_dailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__metrics_dailyClient<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Metrics_dailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metrics_dailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metrics_dailies
     * const metrics_dailies = await prisma.metrics_daily.findMany()
     * 
     * // Get first 10 Metrics_dailies
     * const metrics_dailies = await prisma.metrics_daily.findMany({ take: 10 })
     * 
     * // Only select the `metric_date`
     * const metrics_dailyWithMetric_dateOnly = await prisma.metrics_daily.findMany({ select: { metric_date: true } })
     * 
     */
    findMany<T extends metrics_dailyFindManyArgs>(args?: SelectSubset<T, metrics_dailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Metrics_daily.
     * @param {metrics_dailyCreateArgs} args - Arguments to create a Metrics_daily.
     * @example
     * // Create one Metrics_daily
     * const Metrics_daily = await prisma.metrics_daily.create({
     *   data: {
     *     // ... data to create a Metrics_daily
     *   }
     * })
     * 
     */
    create<T extends metrics_dailyCreateArgs>(args: SelectSubset<T, metrics_dailyCreateArgs<ExtArgs>>): Prisma__metrics_dailyClient<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Metrics_dailies.
     * @param {metrics_dailyCreateManyArgs} args - Arguments to create many Metrics_dailies.
     * @example
     * // Create many Metrics_dailies
     * const metrics_daily = await prisma.metrics_daily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends metrics_dailyCreateManyArgs>(args?: SelectSubset<T, metrics_dailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Metrics_daily.
     * @param {metrics_dailyDeleteArgs} args - Arguments to delete one Metrics_daily.
     * @example
     * // Delete one Metrics_daily
     * const Metrics_daily = await prisma.metrics_daily.delete({
     *   where: {
     *     // ... filter to delete one Metrics_daily
     *   }
     * })
     * 
     */
    delete<T extends metrics_dailyDeleteArgs>(args: SelectSubset<T, metrics_dailyDeleteArgs<ExtArgs>>): Prisma__metrics_dailyClient<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Metrics_daily.
     * @param {metrics_dailyUpdateArgs} args - Arguments to update one Metrics_daily.
     * @example
     * // Update one Metrics_daily
     * const metrics_daily = await prisma.metrics_daily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends metrics_dailyUpdateArgs>(args: SelectSubset<T, metrics_dailyUpdateArgs<ExtArgs>>): Prisma__metrics_dailyClient<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Metrics_dailies.
     * @param {metrics_dailyDeleteManyArgs} args - Arguments to filter Metrics_dailies to delete.
     * @example
     * // Delete a few Metrics_dailies
     * const { count } = await prisma.metrics_daily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends metrics_dailyDeleteManyArgs>(args?: SelectSubset<T, metrics_dailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics_dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metrics_dailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metrics_dailies
     * const metrics_daily = await prisma.metrics_daily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends metrics_dailyUpdateManyArgs>(args: SelectSubset<T, metrics_dailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Metrics_daily.
     * @param {metrics_dailyUpsertArgs} args - Arguments to update or create a Metrics_daily.
     * @example
     * // Update or create a Metrics_daily
     * const metrics_daily = await prisma.metrics_daily.upsert({
     *   create: {
     *     // ... data to create a Metrics_daily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metrics_daily we want to update
     *   }
     * })
     */
    upsert<T extends metrics_dailyUpsertArgs>(args: SelectSubset<T, metrics_dailyUpsertArgs<ExtArgs>>): Prisma__metrics_dailyClient<$Result.GetResult<Prisma.$metrics_dailyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Metrics_dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metrics_dailyCountArgs} args - Arguments to filter Metrics_dailies to count.
     * @example
     * // Count the number of Metrics_dailies
     * const count = await prisma.metrics_daily.count({
     *   where: {
     *     // ... the filter for the Metrics_dailies we want to count
     *   }
     * })
    **/
    count<T extends metrics_dailyCountArgs>(
      args?: Subset<T, metrics_dailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Metrics_dailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metrics_daily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metrics_dailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Metrics_dailyAggregateArgs>(args: Subset<T, Metrics_dailyAggregateArgs>): Prisma.PrismaPromise<GetMetrics_dailyAggregateType<T>>

    /**
     * Group by Metrics_daily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metrics_dailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends metrics_dailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: metrics_dailyGroupByArgs['orderBy'] }
        : { orderBy?: metrics_dailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, metrics_dailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetrics_dailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the metrics_daily model
   */
  readonly fields: metrics_dailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for metrics_daily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__metrics_dailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the metrics_daily model
   */
  interface metrics_dailyFieldRefs {
    readonly metric_date: FieldRef<"metrics_daily", 'DateTime'>
    readonly suite_id: FieldRef<"metrics_daily", 'Int'>
    readonly pass_rate: FieldRef<"metrics_daily", 'Decimal'>
    readonly avg_duration_ms: FieldRef<"metrics_daily", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * metrics_daily findUnique
   */
  export type metrics_dailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * Filter, which metrics_daily to fetch.
     */
    where: metrics_dailyWhereUniqueInput
  }

  /**
   * metrics_daily findUniqueOrThrow
   */
  export type metrics_dailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * Filter, which metrics_daily to fetch.
     */
    where: metrics_dailyWhereUniqueInput
  }

  /**
   * metrics_daily findFirst
   */
  export type metrics_dailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * Filter, which metrics_daily to fetch.
     */
    where?: metrics_dailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metrics_dailies to fetch.
     */
    orderBy?: metrics_dailyOrderByWithRelationInput | metrics_dailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metrics_dailies.
     */
    cursor?: metrics_dailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metrics_dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metrics_dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metrics_dailies.
     */
    distinct?: Metrics_dailyScalarFieldEnum | Metrics_dailyScalarFieldEnum[]
  }

  /**
   * metrics_daily findFirstOrThrow
   */
  export type metrics_dailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * Filter, which metrics_daily to fetch.
     */
    where?: metrics_dailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metrics_dailies to fetch.
     */
    orderBy?: metrics_dailyOrderByWithRelationInput | metrics_dailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metrics_dailies.
     */
    cursor?: metrics_dailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metrics_dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metrics_dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metrics_dailies.
     */
    distinct?: Metrics_dailyScalarFieldEnum | Metrics_dailyScalarFieldEnum[]
  }

  /**
   * metrics_daily findMany
   */
  export type metrics_dailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * Filter, which metrics_dailies to fetch.
     */
    where?: metrics_dailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metrics_dailies to fetch.
     */
    orderBy?: metrics_dailyOrderByWithRelationInput | metrics_dailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing metrics_dailies.
     */
    cursor?: metrics_dailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metrics_dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metrics_dailies.
     */
    skip?: number
    distinct?: Metrics_dailyScalarFieldEnum | Metrics_dailyScalarFieldEnum[]
  }

  /**
   * metrics_daily create
   */
  export type metrics_dailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * The data needed to create a metrics_daily.
     */
    data: XOR<metrics_dailyCreateInput, metrics_dailyUncheckedCreateInput>
  }

  /**
   * metrics_daily createMany
   */
  export type metrics_dailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many metrics_dailies.
     */
    data: metrics_dailyCreateManyInput | metrics_dailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * metrics_daily update
   */
  export type metrics_dailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * The data needed to update a metrics_daily.
     */
    data: XOR<metrics_dailyUpdateInput, metrics_dailyUncheckedUpdateInput>
    /**
     * Choose, which metrics_daily to update.
     */
    where: metrics_dailyWhereUniqueInput
  }

  /**
   * metrics_daily updateMany
   */
  export type metrics_dailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update metrics_dailies.
     */
    data: XOR<metrics_dailyUpdateManyMutationInput, metrics_dailyUncheckedUpdateManyInput>
    /**
     * Filter which metrics_dailies to update
     */
    where?: metrics_dailyWhereInput
    /**
     * Limit how many metrics_dailies to update.
     */
    limit?: number
  }

  /**
   * metrics_daily upsert
   */
  export type metrics_dailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * The filter to search for the metrics_daily to update in case it exists.
     */
    where: metrics_dailyWhereUniqueInput
    /**
     * In case the metrics_daily found by the `where` argument doesn't exist, create a new metrics_daily with this data.
     */
    create: XOR<metrics_dailyCreateInput, metrics_dailyUncheckedCreateInput>
    /**
     * In case the metrics_daily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<metrics_dailyUpdateInput, metrics_dailyUncheckedUpdateInput>
  }

  /**
   * metrics_daily delete
   */
  export type metrics_dailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
    /**
     * Filter which metrics_daily to delete.
     */
    where: metrics_dailyWhereUniqueInput
  }

  /**
   * metrics_daily deleteMany
   */
  export type metrics_dailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which metrics_dailies to delete
     */
    where?: metrics_dailyWhereInput
    /**
     * Limit how many metrics_dailies to delete.
     */
    limit?: number
  }

  /**
   * metrics_daily without action
   */
  export type metrics_dailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metrics_daily
     */
    select?: metrics_dailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the metrics_daily
     */
    omit?: metrics_dailyOmit<ExtArgs> | null
  }


  /**
   * Model reports
   */

  export type AggregateReports = {
    _count: ReportsCountAggregateOutputType | null
    _avg: ReportsAvgAggregateOutputType | null
    _sum: ReportsSumAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  export type ReportsAvgAggregateOutputType = {
    id: number | null
    run_id: number | null
  }

  export type ReportsSumAggregateOutputType = {
    id: number | null
    run_id: number | null
  }

  export type ReportsMinAggregateOutputType = {
    id: number | null
    run_id: number | null
    generated_at: Date | null
  }

  export type ReportsMaxAggregateOutputType = {
    id: number | null
    run_id: number | null
    generated_at: Date | null
  }

  export type ReportsCountAggregateOutputType = {
    id: number
    run_id: number
    summary: number
    generated_at: number
    _all: number
  }


  export type ReportsAvgAggregateInputType = {
    id?: true
    run_id?: true
  }

  export type ReportsSumAggregateInputType = {
    id?: true
    run_id?: true
  }

  export type ReportsMinAggregateInputType = {
    id?: true
    run_id?: true
    generated_at?: true
  }

  export type ReportsMaxAggregateInputType = {
    id?: true
    run_id?: true
    generated_at?: true
  }

  export type ReportsCountAggregateInputType = {
    id?: true
    run_id?: true
    summary?: true
    generated_at?: true
    _all?: true
  }

  export type ReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reports to aggregate.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reports
    **/
    _count?: true | ReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportsMaxAggregateInputType
  }

  export type GetReportsAggregateType<T extends ReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReports[P]>
      : GetScalarType<T[P], AggregateReports[P]>
  }




  export type reportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportsWhereInput
    orderBy?: reportsOrderByWithAggregationInput | reportsOrderByWithAggregationInput[]
    by: ReportsScalarFieldEnum[] | ReportsScalarFieldEnum
    having?: reportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportsCountAggregateInputType | true
    _avg?: ReportsAvgAggregateInputType
    _sum?: ReportsSumAggregateInputType
    _min?: ReportsMinAggregateInputType
    _max?: ReportsMaxAggregateInputType
  }

  export type ReportsGroupByOutputType = {
    id: number
    run_id: number
    summary: JsonValue | null
    generated_at: Date | null
    _count: ReportsCountAggregateOutputType | null
    _avg: ReportsAvgAggregateOutputType | null
    _sum: ReportsSumAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  type GetReportsGroupByPayload<T extends reportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportsGroupByOutputType[P]>
            : GetScalarType<T[P], ReportsGroupByOutputType[P]>
        }
      >
    >


  export type reportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    run_id?: boolean
    summary?: boolean
    generated_at?: boolean
    test_runs?: boolean | test_runsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reports"]>



  export type reportsSelectScalar = {
    id?: boolean
    run_id?: boolean
    summary?: boolean
    generated_at?: boolean
  }

  export type reportsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "run_id" | "summary" | "generated_at", ExtArgs["result"]["reports"]>
  export type reportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_runs?: boolean | test_runsDefaultArgs<ExtArgs>
  }

  export type $reportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reports"
    objects: {
      test_runs: Prisma.$test_runsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      run_id: number
      summary: Prisma.JsonValue | null
      generated_at: Date | null
    }, ExtArgs["result"]["reports"]>
    composites: {}
  }

  type reportsGetPayload<S extends boolean | null | undefined | reportsDefaultArgs> = $Result.GetResult<Prisma.$reportsPayload, S>

  type reportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reportsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportsCountAggregateInputType | true
    }

  export interface reportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reports'], meta: { name: 'reports' } }
    /**
     * Find zero or one Reports that matches the filter.
     * @param {reportsFindUniqueArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reportsFindUniqueArgs>(args: SelectSubset<T, reportsFindUniqueArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reportsFindUniqueOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reportsFindUniqueOrThrowArgs>(args: SelectSubset<T, reportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindFirstArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reportsFindFirstArgs>(args?: SelectSubset<T, reportsFindFirstArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindFirstOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reportsFindFirstOrThrowArgs>(args?: SelectSubset<T, reportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.reports.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.reports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportsWithIdOnly = await prisma.reports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reportsFindManyArgs>(args?: SelectSubset<T, reportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reports.
     * @param {reportsCreateArgs} args - Arguments to create a Reports.
     * @example
     * // Create one Reports
     * const Reports = await prisma.reports.create({
     *   data: {
     *     // ... data to create a Reports
     *   }
     * })
     * 
     */
    create<T extends reportsCreateArgs>(args: SelectSubset<T, reportsCreateArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {reportsCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const reports = await prisma.reports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reportsCreateManyArgs>(args?: SelectSubset<T, reportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reports.
     * @param {reportsDeleteArgs} args - Arguments to delete one Reports.
     * @example
     * // Delete one Reports
     * const Reports = await prisma.reports.delete({
     *   where: {
     *     // ... filter to delete one Reports
     *   }
     * })
     * 
     */
    delete<T extends reportsDeleteArgs>(args: SelectSubset<T, reportsDeleteArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reports.
     * @param {reportsUpdateArgs} args - Arguments to update one Reports.
     * @example
     * // Update one Reports
     * const reports = await prisma.reports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reportsUpdateArgs>(args: SelectSubset<T, reportsUpdateArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {reportsDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.reports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reportsDeleteManyArgs>(args?: SelectSubset<T, reportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const reports = await prisma.reports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reportsUpdateManyArgs>(args: SelectSubset<T, reportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reports.
     * @param {reportsUpsertArgs} args - Arguments to update or create a Reports.
     * @example
     * // Update or create a Reports
     * const reports = await prisma.reports.upsert({
     *   create: {
     *     // ... data to create a Reports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reports we want to update
     *   }
     * })
     */
    upsert<T extends reportsUpsertArgs>(args: SelectSubset<T, reportsUpsertArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.reports.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends reportsCountArgs>(
      args?: Subset<T, reportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportsAggregateArgs>(args: Subset<T, ReportsAggregateArgs>): Prisma.PrismaPromise<GetReportsAggregateType<T>>

    /**
     * Group by Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportsGroupByArgs['orderBy'] }
        : { orderBy?: reportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reports model
   */
  readonly fields: reportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_runs<T extends test_runsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_runsDefaultArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reports model
   */
  interface reportsFieldRefs {
    readonly id: FieldRef<"reports", 'Int'>
    readonly run_id: FieldRef<"reports", 'Int'>
    readonly summary: FieldRef<"reports", 'Json'>
    readonly generated_at: FieldRef<"reports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reports findUnique
   */
  export type reportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports findUniqueOrThrow
   */
  export type reportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports findFirst
   */
  export type reportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports findFirstOrThrow
   */
  export type reportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports findMany
   */
  export type reportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports create
   */
  export type reportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * The data needed to create a reports.
     */
    data: XOR<reportsCreateInput, reportsUncheckedCreateInput>
  }

  /**
   * reports createMany
   */
  export type reportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reports.
     */
    data: reportsCreateManyInput | reportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reports update
   */
  export type reportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * The data needed to update a reports.
     */
    data: XOR<reportsUpdateInput, reportsUncheckedUpdateInput>
    /**
     * Choose, which reports to update.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports updateMany
   */
  export type reportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reports.
     */
    data: XOR<reportsUpdateManyMutationInput, reportsUncheckedUpdateManyInput>
    /**
     * Filter which reports to update
     */
    where?: reportsWhereInput
    /**
     * Limit how many reports to update.
     */
    limit?: number
  }

  /**
   * reports upsert
   */
  export type reportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * The filter to search for the reports to update in case it exists.
     */
    where: reportsWhereUniqueInput
    /**
     * In case the reports found by the `where` argument doesn't exist, create a new reports with this data.
     */
    create: XOR<reportsCreateInput, reportsUncheckedCreateInput>
    /**
     * In case the reports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportsUpdateInput, reportsUncheckedUpdateInput>
  }

  /**
   * reports delete
   */
  export type reportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter which reports to delete.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports deleteMany
   */
  export type reportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reports to delete
     */
    where?: reportsWhereInput
    /**
     * Limit how many reports to delete.
     */
    limit?: number
  }

  /**
   * reports without action
   */
  export type reportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    user_roles?: boolean | roles$user_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>



  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["roles"]>
  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | roles$user_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      user_roles: Prisma.$user_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_roles<T extends roles$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly name: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * roles.user_roles
   */
  export type roles$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    key: string | null
    value: string | null
    updated_at: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    key: string | null
    value: string | null
    updated_at: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    key: number
    value: number
    updated_at: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    key?: true
    value?: true
    updated_at?: true
  }

  export type SettingsMaxAggregateInputType = {
    key?: true
    value?: true
    updated_at?: true
  }

  export type SettingsCountAggregateInputType = {
    key?: true
    value?: true
    updated_at?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to aggregate.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput
    orderBy?: settingsOrderByWithAggregationInput | settingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    key: string
    value: string | null
    updated_at: Date | null
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["settings"]>



  export type settingsSelectScalar = {
    key?: boolean
    value?: boolean
    updated_at?: boolean
  }

  export type settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "updated_at", ExtArgs["result"]["settings"]>

  export type $settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string | null
      updated_at: Date | null
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type settingsGetPayload<S extends boolean | null | undefined | settingsDefaultArgs> = $Result.GetResult<Prisma.$settingsPayload, S>

  type settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settings'], meta: { name: 'settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingsFindUniqueArgs>(args: SelectSubset<T, settingsFindUniqueArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingsFindFirstArgs>(args?: SelectSubset<T, settingsFindFirstArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const settingsWithKeyOnly = await prisma.settings.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends settingsFindManyArgs>(args?: SelectSubset<T, settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends settingsCreateArgs>(args: SelectSubset<T, settingsCreateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {settingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settingsCreateManyArgs>(args?: SelectSubset<T, settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends settingsDeleteArgs>(args: SelectSubset<T, settingsDeleteArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settingsUpdateArgs>(args: SelectSubset<T, settingsUpdateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settingsDeleteManyArgs>(args?: SelectSubset<T, settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settingsUpdateManyArgs>(args: SelectSubset<T, settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends settingsUpsertArgs>(args: SelectSubset<T, settingsUpsertArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingsGroupByArgs['orderBy'] }
        : { orderBy?: settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settings model
   */
  readonly fields: settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the settings model
   */
  interface settingsFieldRefs {
    readonly key: FieldRef<"settings", 'String'>
    readonly value: FieldRef<"settings", 'String'>
    readonly updated_at: FieldRef<"settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * settings findUnique
   */
  export type settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findFirst
   */
  export type settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findMany
   */
  export type settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings create
   */
  export type settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data needed to create a settings.
     */
    data: XOR<settingsCreateInput, settingsUncheckedCreateInput>
  }

  /**
   * settings createMany
   */
  export type settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * settings update
   */
  export type settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data needed to update a settings.
     */
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
    /**
     * Choose, which settings to update.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
  }

  /**
   * settings upsert
   */
  export type settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The filter to search for the settings to update in case it exists.
     */
    where: settingsWhereUniqueInput
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     */
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
  }

  /**
   * settings delete
   */
  export type settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter which settings to delete.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to delete.
     */
    limit?: number
  }

  /**
   * settings without action
   */
  export type settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
  }


  /**
   * Model step_screenshots
   */

  export type AggregateStep_screenshots = {
    _count: Step_screenshotsCountAggregateOutputType | null
    _avg: Step_screenshotsAvgAggregateOutputType | null
    _sum: Step_screenshotsSumAggregateOutputType | null
    _min: Step_screenshotsMinAggregateOutputType | null
    _max: Step_screenshotsMaxAggregateOutputType | null
  }

  export type Step_screenshotsAvgAggregateOutputType = {
    id: number | null
    test_case_id: number | null
    file_size: number | null
  }

  export type Step_screenshotsSumAggregateOutputType = {
    id: number | null
    test_case_id: number | null
    file_size: bigint | null
  }

  export type Step_screenshotsMinAggregateOutputType = {
    id: number | null
    run_id: string | null
    test_case_id: number | null
    step_index: string | null
    step_description: string | null
    status: $Enums.step_screenshots_status | null
    file_path: string | null
    file_name: string | null
    file_size: bigint | null
    mime_type: string | null
    created_at: Date | null
    file_exists: boolean | null
  }

  export type Step_screenshotsMaxAggregateOutputType = {
    id: number | null
    run_id: string | null
    test_case_id: number | null
    step_index: string | null
    step_description: string | null
    status: $Enums.step_screenshots_status | null
    file_path: string | null
    file_name: string | null
    file_size: bigint | null
    mime_type: string | null
    created_at: Date | null
    file_exists: boolean | null
  }

  export type Step_screenshotsCountAggregateOutputType = {
    id: number
    run_id: number
    test_case_id: number
    step_index: number
    step_description: number
    status: number
    file_path: number
    file_name: number
    file_size: number
    mime_type: number
    created_at: number
    file_exists: number
    _all: number
  }


  export type Step_screenshotsAvgAggregateInputType = {
    id?: true
    test_case_id?: true
    file_size?: true
  }

  export type Step_screenshotsSumAggregateInputType = {
    id?: true
    test_case_id?: true
    file_size?: true
  }

  export type Step_screenshotsMinAggregateInputType = {
    id?: true
    run_id?: true
    test_case_id?: true
    step_index?: true
    step_description?: true
    status?: true
    file_path?: true
    file_name?: true
    file_size?: true
    mime_type?: true
    created_at?: true
    file_exists?: true
  }

  export type Step_screenshotsMaxAggregateInputType = {
    id?: true
    run_id?: true
    test_case_id?: true
    step_index?: true
    step_description?: true
    status?: true
    file_path?: true
    file_name?: true
    file_size?: true
    mime_type?: true
    created_at?: true
    file_exists?: true
  }

  export type Step_screenshotsCountAggregateInputType = {
    id?: true
    run_id?: true
    test_case_id?: true
    step_index?: true
    step_description?: true
    status?: true
    file_path?: true
    file_name?: true
    file_size?: true
    mime_type?: true
    created_at?: true
    file_exists?: true
    _all?: true
  }

  export type Step_screenshotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which step_screenshots to aggregate.
     */
    where?: step_screenshotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of step_screenshots to fetch.
     */
    orderBy?: step_screenshotsOrderByWithRelationInput | step_screenshotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: step_screenshotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` step_screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` step_screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned step_screenshots
    **/
    _count?: true | Step_screenshotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Step_screenshotsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Step_screenshotsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Step_screenshotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Step_screenshotsMaxAggregateInputType
  }

  export type GetStep_screenshotsAggregateType<T extends Step_screenshotsAggregateArgs> = {
        [P in keyof T & keyof AggregateStep_screenshots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStep_screenshots[P]>
      : GetScalarType<T[P], AggregateStep_screenshots[P]>
  }




  export type step_screenshotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: step_screenshotsWhereInput
    orderBy?: step_screenshotsOrderByWithAggregationInput | step_screenshotsOrderByWithAggregationInput[]
    by: Step_screenshotsScalarFieldEnum[] | Step_screenshotsScalarFieldEnum
    having?: step_screenshotsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Step_screenshotsCountAggregateInputType | true
    _avg?: Step_screenshotsAvgAggregateInputType
    _sum?: Step_screenshotsSumAggregateInputType
    _min?: Step_screenshotsMinAggregateInputType
    _max?: Step_screenshotsMaxAggregateInputType
  }

  export type Step_screenshotsGroupByOutputType = {
    id: number
    run_id: string
    test_case_id: number | null
    step_index: string
    step_description: string | null
    status: $Enums.step_screenshots_status
    file_path: string
    file_name: string
    file_size: bigint | null
    mime_type: string | null
    created_at: Date | null
    file_exists: boolean
    _count: Step_screenshotsCountAggregateOutputType | null
    _avg: Step_screenshotsAvgAggregateOutputType | null
    _sum: Step_screenshotsSumAggregateOutputType | null
    _min: Step_screenshotsMinAggregateOutputType | null
    _max: Step_screenshotsMaxAggregateOutputType | null
  }

  type GetStep_screenshotsGroupByPayload<T extends step_screenshotsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Step_screenshotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Step_screenshotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Step_screenshotsGroupByOutputType[P]>
            : GetScalarType<T[P], Step_screenshotsGroupByOutputType[P]>
        }
      >
    >


  export type step_screenshotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    run_id?: boolean
    test_case_id?: boolean
    step_index?: boolean
    step_description?: boolean
    status?: boolean
    file_path?: boolean
    file_name?: boolean
    file_size?: boolean
    mime_type?: boolean
    created_at?: boolean
    file_exists?: boolean
    test_cases?: boolean | step_screenshots$test_casesArgs<ExtArgs>
  }, ExtArgs["result"]["step_screenshots"]>



  export type step_screenshotsSelectScalar = {
    id?: boolean
    run_id?: boolean
    test_case_id?: boolean
    step_index?: boolean
    step_description?: boolean
    status?: boolean
    file_path?: boolean
    file_name?: boolean
    file_size?: boolean
    mime_type?: boolean
    created_at?: boolean
    file_exists?: boolean
  }

  export type step_screenshotsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "run_id" | "test_case_id" | "step_index" | "step_description" | "status" | "file_path" | "file_name" | "file_size" | "mime_type" | "created_at" | "file_exists", ExtArgs["result"]["step_screenshots"]>
  export type step_screenshotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_cases?: boolean | step_screenshots$test_casesArgs<ExtArgs>
  }

  export type $step_screenshotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "step_screenshots"
    objects: {
      test_cases: Prisma.$test_casesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      run_id: string
      test_case_id: number | null
      step_index: string
      step_description: string | null
      status: $Enums.step_screenshots_status
      file_path: string
      file_name: string
      file_size: bigint | null
      mime_type: string | null
      created_at: Date | null
      file_exists: boolean
    }, ExtArgs["result"]["step_screenshots"]>
    composites: {}
  }

  type step_screenshotsGetPayload<S extends boolean | null | undefined | step_screenshotsDefaultArgs> = $Result.GetResult<Prisma.$step_screenshotsPayload, S>

  type step_screenshotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<step_screenshotsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Step_screenshotsCountAggregateInputType | true
    }

  export interface step_screenshotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['step_screenshots'], meta: { name: 'step_screenshots' } }
    /**
     * Find zero or one Step_screenshots that matches the filter.
     * @param {step_screenshotsFindUniqueArgs} args - Arguments to find a Step_screenshots
     * @example
     * // Get one Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends step_screenshotsFindUniqueArgs>(args: SelectSubset<T, step_screenshotsFindUniqueArgs<ExtArgs>>): Prisma__step_screenshotsClient<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Step_screenshots that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {step_screenshotsFindUniqueOrThrowArgs} args - Arguments to find a Step_screenshots
     * @example
     * // Get one Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends step_screenshotsFindUniqueOrThrowArgs>(args: SelectSubset<T, step_screenshotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__step_screenshotsClient<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Step_screenshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {step_screenshotsFindFirstArgs} args - Arguments to find a Step_screenshots
     * @example
     * // Get one Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends step_screenshotsFindFirstArgs>(args?: SelectSubset<T, step_screenshotsFindFirstArgs<ExtArgs>>): Prisma__step_screenshotsClient<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Step_screenshots that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {step_screenshotsFindFirstOrThrowArgs} args - Arguments to find a Step_screenshots
     * @example
     * // Get one Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends step_screenshotsFindFirstOrThrowArgs>(args?: SelectSubset<T, step_screenshotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__step_screenshotsClient<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Step_screenshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {step_screenshotsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.findMany()
     * 
     * // Get first 10 Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const step_screenshotsWithIdOnly = await prisma.step_screenshots.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends step_screenshotsFindManyArgs>(args?: SelectSubset<T, step_screenshotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Step_screenshots.
     * @param {step_screenshotsCreateArgs} args - Arguments to create a Step_screenshots.
     * @example
     * // Create one Step_screenshots
     * const Step_screenshots = await prisma.step_screenshots.create({
     *   data: {
     *     // ... data to create a Step_screenshots
     *   }
     * })
     * 
     */
    create<T extends step_screenshotsCreateArgs>(args: SelectSubset<T, step_screenshotsCreateArgs<ExtArgs>>): Prisma__step_screenshotsClient<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Step_screenshots.
     * @param {step_screenshotsCreateManyArgs} args - Arguments to create many Step_screenshots.
     * @example
     * // Create many Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends step_screenshotsCreateManyArgs>(args?: SelectSubset<T, step_screenshotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Step_screenshots.
     * @param {step_screenshotsDeleteArgs} args - Arguments to delete one Step_screenshots.
     * @example
     * // Delete one Step_screenshots
     * const Step_screenshots = await prisma.step_screenshots.delete({
     *   where: {
     *     // ... filter to delete one Step_screenshots
     *   }
     * })
     * 
     */
    delete<T extends step_screenshotsDeleteArgs>(args: SelectSubset<T, step_screenshotsDeleteArgs<ExtArgs>>): Prisma__step_screenshotsClient<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Step_screenshots.
     * @param {step_screenshotsUpdateArgs} args - Arguments to update one Step_screenshots.
     * @example
     * // Update one Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends step_screenshotsUpdateArgs>(args: SelectSubset<T, step_screenshotsUpdateArgs<ExtArgs>>): Prisma__step_screenshotsClient<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Step_screenshots.
     * @param {step_screenshotsDeleteManyArgs} args - Arguments to filter Step_screenshots to delete.
     * @example
     * // Delete a few Step_screenshots
     * const { count } = await prisma.step_screenshots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends step_screenshotsDeleteManyArgs>(args?: SelectSubset<T, step_screenshotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Step_screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {step_screenshotsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends step_screenshotsUpdateManyArgs>(args: SelectSubset<T, step_screenshotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Step_screenshots.
     * @param {step_screenshotsUpsertArgs} args - Arguments to update or create a Step_screenshots.
     * @example
     * // Update or create a Step_screenshots
     * const step_screenshots = await prisma.step_screenshots.upsert({
     *   create: {
     *     // ... data to create a Step_screenshots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Step_screenshots we want to update
     *   }
     * })
     */
    upsert<T extends step_screenshotsUpsertArgs>(args: SelectSubset<T, step_screenshotsUpsertArgs<ExtArgs>>): Prisma__step_screenshotsClient<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Step_screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {step_screenshotsCountArgs} args - Arguments to filter Step_screenshots to count.
     * @example
     * // Count the number of Step_screenshots
     * const count = await prisma.step_screenshots.count({
     *   where: {
     *     // ... the filter for the Step_screenshots we want to count
     *   }
     * })
    **/
    count<T extends step_screenshotsCountArgs>(
      args?: Subset<T, step_screenshotsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Step_screenshotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Step_screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Step_screenshotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Step_screenshotsAggregateArgs>(args: Subset<T, Step_screenshotsAggregateArgs>): Prisma.PrismaPromise<GetStep_screenshotsAggregateType<T>>

    /**
     * Group by Step_screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {step_screenshotsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends step_screenshotsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: step_screenshotsGroupByArgs['orderBy'] }
        : { orderBy?: step_screenshotsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, step_screenshotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStep_screenshotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the step_screenshots model
   */
  readonly fields: step_screenshotsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for step_screenshots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__step_screenshotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_cases<T extends step_screenshots$test_casesArgs<ExtArgs> = {}>(args?: Subset<T, step_screenshots$test_casesArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the step_screenshots model
   */
  interface step_screenshotsFieldRefs {
    readonly id: FieldRef<"step_screenshots", 'Int'>
    readonly run_id: FieldRef<"step_screenshots", 'String'>
    readonly test_case_id: FieldRef<"step_screenshots", 'Int'>
    readonly step_index: FieldRef<"step_screenshots", 'String'>
    readonly step_description: FieldRef<"step_screenshots", 'String'>
    readonly status: FieldRef<"step_screenshots", 'step_screenshots_status'>
    readonly file_path: FieldRef<"step_screenshots", 'String'>
    readonly file_name: FieldRef<"step_screenshots", 'String'>
    readonly file_size: FieldRef<"step_screenshots", 'BigInt'>
    readonly mime_type: FieldRef<"step_screenshots", 'String'>
    readonly created_at: FieldRef<"step_screenshots", 'DateTime'>
    readonly file_exists: FieldRef<"step_screenshots", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * step_screenshots findUnique
   */
  export type step_screenshotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * Filter, which step_screenshots to fetch.
     */
    where: step_screenshotsWhereUniqueInput
  }

  /**
   * step_screenshots findUniqueOrThrow
   */
  export type step_screenshotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * Filter, which step_screenshots to fetch.
     */
    where: step_screenshotsWhereUniqueInput
  }

  /**
   * step_screenshots findFirst
   */
  export type step_screenshotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * Filter, which step_screenshots to fetch.
     */
    where?: step_screenshotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of step_screenshots to fetch.
     */
    orderBy?: step_screenshotsOrderByWithRelationInput | step_screenshotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for step_screenshots.
     */
    cursor?: step_screenshotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` step_screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` step_screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of step_screenshots.
     */
    distinct?: Step_screenshotsScalarFieldEnum | Step_screenshotsScalarFieldEnum[]
  }

  /**
   * step_screenshots findFirstOrThrow
   */
  export type step_screenshotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * Filter, which step_screenshots to fetch.
     */
    where?: step_screenshotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of step_screenshots to fetch.
     */
    orderBy?: step_screenshotsOrderByWithRelationInput | step_screenshotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for step_screenshots.
     */
    cursor?: step_screenshotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` step_screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` step_screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of step_screenshots.
     */
    distinct?: Step_screenshotsScalarFieldEnum | Step_screenshotsScalarFieldEnum[]
  }

  /**
   * step_screenshots findMany
   */
  export type step_screenshotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * Filter, which step_screenshots to fetch.
     */
    where?: step_screenshotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of step_screenshots to fetch.
     */
    orderBy?: step_screenshotsOrderByWithRelationInput | step_screenshotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing step_screenshots.
     */
    cursor?: step_screenshotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` step_screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` step_screenshots.
     */
    skip?: number
    distinct?: Step_screenshotsScalarFieldEnum | Step_screenshotsScalarFieldEnum[]
  }

  /**
   * step_screenshots create
   */
  export type step_screenshotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * The data needed to create a step_screenshots.
     */
    data: XOR<step_screenshotsCreateInput, step_screenshotsUncheckedCreateInput>
  }

  /**
   * step_screenshots createMany
   */
  export type step_screenshotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many step_screenshots.
     */
    data: step_screenshotsCreateManyInput | step_screenshotsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * step_screenshots update
   */
  export type step_screenshotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * The data needed to update a step_screenshots.
     */
    data: XOR<step_screenshotsUpdateInput, step_screenshotsUncheckedUpdateInput>
    /**
     * Choose, which step_screenshots to update.
     */
    where: step_screenshotsWhereUniqueInput
  }

  /**
   * step_screenshots updateMany
   */
  export type step_screenshotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update step_screenshots.
     */
    data: XOR<step_screenshotsUpdateManyMutationInput, step_screenshotsUncheckedUpdateManyInput>
    /**
     * Filter which step_screenshots to update
     */
    where?: step_screenshotsWhereInput
    /**
     * Limit how many step_screenshots to update.
     */
    limit?: number
  }

  /**
   * step_screenshots upsert
   */
  export type step_screenshotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * The filter to search for the step_screenshots to update in case it exists.
     */
    where: step_screenshotsWhereUniqueInput
    /**
     * In case the step_screenshots found by the `where` argument doesn't exist, create a new step_screenshots with this data.
     */
    create: XOR<step_screenshotsCreateInput, step_screenshotsUncheckedCreateInput>
    /**
     * In case the step_screenshots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<step_screenshotsUpdateInput, step_screenshotsUncheckedUpdateInput>
  }

  /**
   * step_screenshots delete
   */
  export type step_screenshotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    /**
     * Filter which step_screenshots to delete.
     */
    where: step_screenshotsWhereUniqueInput
  }

  /**
   * step_screenshots deleteMany
   */
  export type step_screenshotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which step_screenshots to delete
     */
    where?: step_screenshotsWhereInput
    /**
     * Limit how many step_screenshots to delete.
     */
    limit?: number
  }

  /**
   * step_screenshots.test_cases
   */
  export type step_screenshots$test_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    where?: test_casesWhereInput
  }

  /**
   * step_screenshots without action
   */
  export type step_screenshotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
  }


  /**
   * Model suite_case_map
   */

  export type AggregateSuite_case_map = {
    _count: Suite_case_mapCountAggregateOutputType | null
    _avg: Suite_case_mapAvgAggregateOutputType | null
    _sum: Suite_case_mapSumAggregateOutputType | null
    _min: Suite_case_mapMinAggregateOutputType | null
    _max: Suite_case_mapMaxAggregateOutputType | null
  }

  export type Suite_case_mapAvgAggregateOutputType = {
    suite_id: number | null
    case_id: number | null
  }

  export type Suite_case_mapSumAggregateOutputType = {
    suite_id: number | null
    case_id: number | null
  }

  export type Suite_case_mapMinAggregateOutputType = {
    suite_id: number | null
    case_id: number | null
  }

  export type Suite_case_mapMaxAggregateOutputType = {
    suite_id: number | null
    case_id: number | null
  }

  export type Suite_case_mapCountAggregateOutputType = {
    suite_id: number
    case_id: number
    _all: number
  }


  export type Suite_case_mapAvgAggregateInputType = {
    suite_id?: true
    case_id?: true
  }

  export type Suite_case_mapSumAggregateInputType = {
    suite_id?: true
    case_id?: true
  }

  export type Suite_case_mapMinAggregateInputType = {
    suite_id?: true
    case_id?: true
  }

  export type Suite_case_mapMaxAggregateInputType = {
    suite_id?: true
    case_id?: true
  }

  export type Suite_case_mapCountAggregateInputType = {
    suite_id?: true
    case_id?: true
    _all?: true
  }

  export type Suite_case_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suite_case_map to aggregate.
     */
    where?: suite_case_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suite_case_maps to fetch.
     */
    orderBy?: suite_case_mapOrderByWithRelationInput | suite_case_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: suite_case_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suite_case_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suite_case_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suite_case_maps
    **/
    _count?: true | Suite_case_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Suite_case_mapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Suite_case_mapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Suite_case_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Suite_case_mapMaxAggregateInputType
  }

  export type GetSuite_case_mapAggregateType<T extends Suite_case_mapAggregateArgs> = {
        [P in keyof T & keyof AggregateSuite_case_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuite_case_map[P]>
      : GetScalarType<T[P], AggregateSuite_case_map[P]>
  }




  export type suite_case_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suite_case_mapWhereInput
    orderBy?: suite_case_mapOrderByWithAggregationInput | suite_case_mapOrderByWithAggregationInput[]
    by: Suite_case_mapScalarFieldEnum[] | Suite_case_mapScalarFieldEnum
    having?: suite_case_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Suite_case_mapCountAggregateInputType | true
    _avg?: Suite_case_mapAvgAggregateInputType
    _sum?: Suite_case_mapSumAggregateInputType
    _min?: Suite_case_mapMinAggregateInputType
    _max?: Suite_case_mapMaxAggregateInputType
  }

  export type Suite_case_mapGroupByOutputType = {
    suite_id: number
    case_id: number
    _count: Suite_case_mapCountAggregateOutputType | null
    _avg: Suite_case_mapAvgAggregateOutputType | null
    _sum: Suite_case_mapSumAggregateOutputType | null
    _min: Suite_case_mapMinAggregateOutputType | null
    _max: Suite_case_mapMaxAggregateOutputType | null
  }

  type GetSuite_case_mapGroupByPayload<T extends suite_case_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Suite_case_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Suite_case_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Suite_case_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Suite_case_mapGroupByOutputType[P]>
        }
      >
    >


  export type suite_case_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    suite_id?: boolean
    case_id?: boolean
    test_suites?: boolean | test_suitesDefaultArgs<ExtArgs>
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suite_case_map"]>



  export type suite_case_mapSelectScalar = {
    suite_id?: boolean
    case_id?: boolean
  }

  export type suite_case_mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"suite_id" | "case_id", ExtArgs["result"]["suite_case_map"]>
  export type suite_case_mapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_suites?: boolean | test_suitesDefaultArgs<ExtArgs>
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
  }

  export type $suite_case_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "suite_case_map"
    objects: {
      test_suites: Prisma.$test_suitesPayload<ExtArgs>
      test_cases: Prisma.$test_casesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      suite_id: number
      case_id: number
    }, ExtArgs["result"]["suite_case_map"]>
    composites: {}
  }

  type suite_case_mapGetPayload<S extends boolean | null | undefined | suite_case_mapDefaultArgs> = $Result.GetResult<Prisma.$suite_case_mapPayload, S>

  type suite_case_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<suite_case_mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Suite_case_mapCountAggregateInputType | true
    }

  export interface suite_case_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['suite_case_map'], meta: { name: 'suite_case_map' } }
    /**
     * Find zero or one Suite_case_map that matches the filter.
     * @param {suite_case_mapFindUniqueArgs} args - Arguments to find a Suite_case_map
     * @example
     * // Get one Suite_case_map
     * const suite_case_map = await prisma.suite_case_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends suite_case_mapFindUniqueArgs>(args: SelectSubset<T, suite_case_mapFindUniqueArgs<ExtArgs>>): Prisma__suite_case_mapClient<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Suite_case_map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {suite_case_mapFindUniqueOrThrowArgs} args - Arguments to find a Suite_case_map
     * @example
     * // Get one Suite_case_map
     * const suite_case_map = await prisma.suite_case_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends suite_case_mapFindUniqueOrThrowArgs>(args: SelectSubset<T, suite_case_mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__suite_case_mapClient<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suite_case_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suite_case_mapFindFirstArgs} args - Arguments to find a Suite_case_map
     * @example
     * // Get one Suite_case_map
     * const suite_case_map = await prisma.suite_case_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends suite_case_mapFindFirstArgs>(args?: SelectSubset<T, suite_case_mapFindFirstArgs<ExtArgs>>): Prisma__suite_case_mapClient<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suite_case_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suite_case_mapFindFirstOrThrowArgs} args - Arguments to find a Suite_case_map
     * @example
     * // Get one Suite_case_map
     * const suite_case_map = await prisma.suite_case_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends suite_case_mapFindFirstOrThrowArgs>(args?: SelectSubset<T, suite_case_mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__suite_case_mapClient<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suite_case_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suite_case_mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suite_case_maps
     * const suite_case_maps = await prisma.suite_case_map.findMany()
     * 
     * // Get first 10 Suite_case_maps
     * const suite_case_maps = await prisma.suite_case_map.findMany({ take: 10 })
     * 
     * // Only select the `suite_id`
     * const suite_case_mapWithSuite_idOnly = await prisma.suite_case_map.findMany({ select: { suite_id: true } })
     * 
     */
    findMany<T extends suite_case_mapFindManyArgs>(args?: SelectSubset<T, suite_case_mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Suite_case_map.
     * @param {suite_case_mapCreateArgs} args - Arguments to create a Suite_case_map.
     * @example
     * // Create one Suite_case_map
     * const Suite_case_map = await prisma.suite_case_map.create({
     *   data: {
     *     // ... data to create a Suite_case_map
     *   }
     * })
     * 
     */
    create<T extends suite_case_mapCreateArgs>(args: SelectSubset<T, suite_case_mapCreateArgs<ExtArgs>>): Prisma__suite_case_mapClient<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suite_case_maps.
     * @param {suite_case_mapCreateManyArgs} args - Arguments to create many Suite_case_maps.
     * @example
     * // Create many Suite_case_maps
     * const suite_case_map = await prisma.suite_case_map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends suite_case_mapCreateManyArgs>(args?: SelectSubset<T, suite_case_mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Suite_case_map.
     * @param {suite_case_mapDeleteArgs} args - Arguments to delete one Suite_case_map.
     * @example
     * // Delete one Suite_case_map
     * const Suite_case_map = await prisma.suite_case_map.delete({
     *   where: {
     *     // ... filter to delete one Suite_case_map
     *   }
     * })
     * 
     */
    delete<T extends suite_case_mapDeleteArgs>(args: SelectSubset<T, suite_case_mapDeleteArgs<ExtArgs>>): Prisma__suite_case_mapClient<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Suite_case_map.
     * @param {suite_case_mapUpdateArgs} args - Arguments to update one Suite_case_map.
     * @example
     * // Update one Suite_case_map
     * const suite_case_map = await prisma.suite_case_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends suite_case_mapUpdateArgs>(args: SelectSubset<T, suite_case_mapUpdateArgs<ExtArgs>>): Prisma__suite_case_mapClient<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suite_case_maps.
     * @param {suite_case_mapDeleteManyArgs} args - Arguments to filter Suite_case_maps to delete.
     * @example
     * // Delete a few Suite_case_maps
     * const { count } = await prisma.suite_case_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends suite_case_mapDeleteManyArgs>(args?: SelectSubset<T, suite_case_mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suite_case_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suite_case_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suite_case_maps
     * const suite_case_map = await prisma.suite_case_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends suite_case_mapUpdateManyArgs>(args: SelectSubset<T, suite_case_mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Suite_case_map.
     * @param {suite_case_mapUpsertArgs} args - Arguments to update or create a Suite_case_map.
     * @example
     * // Update or create a Suite_case_map
     * const suite_case_map = await prisma.suite_case_map.upsert({
     *   create: {
     *     // ... data to create a Suite_case_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suite_case_map we want to update
     *   }
     * })
     */
    upsert<T extends suite_case_mapUpsertArgs>(args: SelectSubset<T, suite_case_mapUpsertArgs<ExtArgs>>): Prisma__suite_case_mapClient<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suite_case_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suite_case_mapCountArgs} args - Arguments to filter Suite_case_maps to count.
     * @example
     * // Count the number of Suite_case_maps
     * const count = await prisma.suite_case_map.count({
     *   where: {
     *     // ... the filter for the Suite_case_maps we want to count
     *   }
     * })
    **/
    count<T extends suite_case_mapCountArgs>(
      args?: Subset<T, suite_case_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Suite_case_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suite_case_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Suite_case_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Suite_case_mapAggregateArgs>(args: Subset<T, Suite_case_mapAggregateArgs>): Prisma.PrismaPromise<GetSuite_case_mapAggregateType<T>>

    /**
     * Group by Suite_case_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suite_case_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends suite_case_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: suite_case_mapGroupByArgs['orderBy'] }
        : { orderBy?: suite_case_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, suite_case_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuite_case_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the suite_case_map model
   */
  readonly fields: suite_case_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for suite_case_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__suite_case_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_suites<T extends test_suitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_suitesDefaultArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    test_cases<T extends test_casesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_casesDefaultArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the suite_case_map model
   */
  interface suite_case_mapFieldRefs {
    readonly suite_id: FieldRef<"suite_case_map", 'Int'>
    readonly case_id: FieldRef<"suite_case_map", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * suite_case_map findUnique
   */
  export type suite_case_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * Filter, which suite_case_map to fetch.
     */
    where: suite_case_mapWhereUniqueInput
  }

  /**
   * suite_case_map findUniqueOrThrow
   */
  export type suite_case_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * Filter, which suite_case_map to fetch.
     */
    where: suite_case_mapWhereUniqueInput
  }

  /**
   * suite_case_map findFirst
   */
  export type suite_case_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * Filter, which suite_case_map to fetch.
     */
    where?: suite_case_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suite_case_maps to fetch.
     */
    orderBy?: suite_case_mapOrderByWithRelationInput | suite_case_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suite_case_maps.
     */
    cursor?: suite_case_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suite_case_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suite_case_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suite_case_maps.
     */
    distinct?: Suite_case_mapScalarFieldEnum | Suite_case_mapScalarFieldEnum[]
  }

  /**
   * suite_case_map findFirstOrThrow
   */
  export type suite_case_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * Filter, which suite_case_map to fetch.
     */
    where?: suite_case_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suite_case_maps to fetch.
     */
    orderBy?: suite_case_mapOrderByWithRelationInput | suite_case_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suite_case_maps.
     */
    cursor?: suite_case_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suite_case_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suite_case_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suite_case_maps.
     */
    distinct?: Suite_case_mapScalarFieldEnum | Suite_case_mapScalarFieldEnum[]
  }

  /**
   * suite_case_map findMany
   */
  export type suite_case_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * Filter, which suite_case_maps to fetch.
     */
    where?: suite_case_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suite_case_maps to fetch.
     */
    orderBy?: suite_case_mapOrderByWithRelationInput | suite_case_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suite_case_maps.
     */
    cursor?: suite_case_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suite_case_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suite_case_maps.
     */
    skip?: number
    distinct?: Suite_case_mapScalarFieldEnum | Suite_case_mapScalarFieldEnum[]
  }

  /**
   * suite_case_map create
   */
  export type suite_case_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * The data needed to create a suite_case_map.
     */
    data: XOR<suite_case_mapCreateInput, suite_case_mapUncheckedCreateInput>
  }

  /**
   * suite_case_map createMany
   */
  export type suite_case_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suite_case_maps.
     */
    data: suite_case_mapCreateManyInput | suite_case_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * suite_case_map update
   */
  export type suite_case_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * The data needed to update a suite_case_map.
     */
    data: XOR<suite_case_mapUpdateInput, suite_case_mapUncheckedUpdateInput>
    /**
     * Choose, which suite_case_map to update.
     */
    where: suite_case_mapWhereUniqueInput
  }

  /**
   * suite_case_map updateMany
   */
  export type suite_case_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suite_case_maps.
     */
    data: XOR<suite_case_mapUpdateManyMutationInput, suite_case_mapUncheckedUpdateManyInput>
    /**
     * Filter which suite_case_maps to update
     */
    where?: suite_case_mapWhereInput
    /**
     * Limit how many suite_case_maps to update.
     */
    limit?: number
  }

  /**
   * suite_case_map upsert
   */
  export type suite_case_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * The filter to search for the suite_case_map to update in case it exists.
     */
    where: suite_case_mapWhereUniqueInput
    /**
     * In case the suite_case_map found by the `where` argument doesn't exist, create a new suite_case_map with this data.
     */
    create: XOR<suite_case_mapCreateInput, suite_case_mapUncheckedCreateInput>
    /**
     * In case the suite_case_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<suite_case_mapUpdateInput, suite_case_mapUncheckedUpdateInput>
  }

  /**
   * suite_case_map delete
   */
  export type suite_case_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    /**
     * Filter which suite_case_map to delete.
     */
    where: suite_case_mapWhereUniqueInput
  }

  /**
   * suite_case_map deleteMany
   */
  export type suite_case_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suite_case_maps to delete
     */
    where?: suite_case_mapWhereInput
    /**
     * Limit how many suite_case_maps to delete.
     */
    limit?: number
  }

  /**
   * suite_case_map without action
   */
  export type suite_case_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
  }


  /**
   * Model test_cases
   */

  export type AggregateTest_cases = {
    _count: Test_casesCountAggregateOutputType | null
    _avg: Test_casesAvgAggregateOutputType | null
    _sum: Test_casesSumAggregateOutputType | null
    _min: Test_casesMinAggregateOutputType | null
    _max: Test_casesMaxAggregateOutputType | null
  }

  export type Test_casesAvgAggregateOutputType = {
    id: number | null
  }

  export type Test_casesSumAggregateOutputType = {
    id: number | null
  }

  export type Test_casesMinAggregateOutputType = {
    id: number | null
    title: string | null
    system: string | null
    module: string | null
    project: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Test_casesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    system: string | null
    module: string | null
    project: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Test_casesCountAggregateOutputType = {
    id: number
    title: number
    steps: number
    tags: number
    system: number
    module: number
    project: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Test_casesAvgAggregateInputType = {
    id?: true
  }

  export type Test_casesSumAggregateInputType = {
    id?: true
  }

  export type Test_casesMinAggregateInputType = {
    id?: true
    title?: true
    system?: true
    module?: true
    project?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Test_casesMaxAggregateInputType = {
    id?: true
    title?: true
    system?: true
    module?: true
    project?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Test_casesCountAggregateInputType = {
    id?: true
    title?: true
    steps?: true
    tags?: true
    system?: true
    module?: true
    project?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Test_casesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_cases to aggregate.
     */
    where?: test_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_cases to fetch.
     */
    orderBy?: test_casesOrderByWithRelationInput | test_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_cases
    **/
    _count?: true | Test_casesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_casesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_casesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_casesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_casesMaxAggregateInputType
  }

  export type GetTest_casesAggregateType<T extends Test_casesAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_cases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_cases[P]>
      : GetScalarType<T[P], AggregateTest_cases[P]>
  }




  export type test_casesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_casesWhereInput
    orderBy?: test_casesOrderByWithAggregationInput | test_casesOrderByWithAggregationInput[]
    by: Test_casesScalarFieldEnum[] | Test_casesScalarFieldEnum
    having?: test_casesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_casesCountAggregateInputType | true
    _avg?: Test_casesAvgAggregateInputType
    _sum?: Test_casesSumAggregateInputType
    _min?: Test_casesMinAggregateInputType
    _max?: Test_casesMaxAggregateInputType
  }

  export type Test_casesGroupByOutputType = {
    id: number
    title: string
    steps: JsonValue | null
    tags: JsonValue | null
    system: string | null
    module: string | null
    project: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Test_casesCountAggregateOutputType | null
    _avg: Test_casesAvgAggregateOutputType | null
    _sum: Test_casesSumAggregateOutputType | null
    _min: Test_casesMinAggregateOutputType | null
    _max: Test_casesMaxAggregateOutputType | null
  }

  type GetTest_casesGroupByPayload<T extends test_casesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_casesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_casesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_casesGroupByOutputType[P]>
            : GetScalarType<T[P], Test_casesGroupByOutputType[P]>
        }
      >
    >


  export type test_casesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    steps?: boolean
    tags?: boolean
    system?: boolean
    module?: boolean
    project?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    patch_proposals?: boolean | test_cases$patch_proposalsArgs<ExtArgs>
    case_versions?: boolean | test_cases$case_versionsArgs<ExtArgs>
    step_screenshots?: boolean | test_cases$step_screenshotsArgs<ExtArgs>
    suite_case_map?: boolean | test_cases$suite_case_mapArgs<ExtArgs>
    test_case_executions?: boolean | test_cases$test_case_executionsArgs<ExtArgs>
    test_run_results?: boolean | test_cases$test_run_resultsArgs<ExtArgs>
    _count?: boolean | Test_casesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_cases"]>



  export type test_casesSelectScalar = {
    id?: boolean
    title?: boolean
    steps?: boolean
    tags?: boolean
    system?: boolean
    module?: boolean
    project?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type test_casesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "steps" | "tags" | "system" | "module" | "project" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["test_cases"]>
  export type test_casesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patch_proposals?: boolean | test_cases$patch_proposalsArgs<ExtArgs>
    case_versions?: boolean | test_cases$case_versionsArgs<ExtArgs>
    step_screenshots?: boolean | test_cases$step_screenshotsArgs<ExtArgs>
    suite_case_map?: boolean | test_cases$suite_case_mapArgs<ExtArgs>
    test_case_executions?: boolean | test_cases$test_case_executionsArgs<ExtArgs>
    test_run_results?: boolean | test_cases$test_run_resultsArgs<ExtArgs>
    _count?: boolean | Test_casesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $test_casesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_cases"
    objects: {
      patch_proposals: Prisma.$case_patch_proposalsPayload<ExtArgs>[]
      case_versions: Prisma.$case_versionsPayload<ExtArgs>[]
      step_screenshots: Prisma.$step_screenshotsPayload<ExtArgs>[]
      suite_case_map: Prisma.$suite_case_mapPayload<ExtArgs>[]
      test_case_executions: Prisma.$test_case_executionsPayload<ExtArgs>[]
      test_run_results: Prisma.$test_run_resultsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      steps: Prisma.JsonValue | null
      tags: Prisma.JsonValue | null
      system: string | null
      module: string | null
      project: string | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["test_cases"]>
    composites: {}
  }

  type test_casesGetPayload<S extends boolean | null | undefined | test_casesDefaultArgs> = $Result.GetResult<Prisma.$test_casesPayload, S>

  type test_casesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_casesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_casesCountAggregateInputType | true
    }

  export interface test_casesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_cases'], meta: { name: 'test_cases' } }
    /**
     * Find zero or one Test_cases that matches the filter.
     * @param {test_casesFindUniqueArgs} args - Arguments to find a Test_cases
     * @example
     * // Get one Test_cases
     * const test_cases = await prisma.test_cases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_casesFindUniqueArgs>(args: SelectSubset<T, test_casesFindUniqueArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_cases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_casesFindUniqueOrThrowArgs} args - Arguments to find a Test_cases
     * @example
     * // Get one Test_cases
     * const test_cases = await prisma.test_cases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_casesFindUniqueOrThrowArgs>(args: SelectSubset<T, test_casesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_casesFindFirstArgs} args - Arguments to find a Test_cases
     * @example
     * // Get one Test_cases
     * const test_cases = await prisma.test_cases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_casesFindFirstArgs>(args?: SelectSubset<T, test_casesFindFirstArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_cases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_casesFindFirstOrThrowArgs} args - Arguments to find a Test_cases
     * @example
     * // Get one Test_cases
     * const test_cases = await prisma.test_cases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_casesFindFirstOrThrowArgs>(args?: SelectSubset<T, test_casesFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_casesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_cases
     * const test_cases = await prisma.test_cases.findMany()
     * 
     * // Get first 10 Test_cases
     * const test_cases = await prisma.test_cases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const test_casesWithIdOnly = await prisma.test_cases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends test_casesFindManyArgs>(args?: SelectSubset<T, test_casesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_cases.
     * @param {test_casesCreateArgs} args - Arguments to create a Test_cases.
     * @example
     * // Create one Test_cases
     * const Test_cases = await prisma.test_cases.create({
     *   data: {
     *     // ... data to create a Test_cases
     *   }
     * })
     * 
     */
    create<T extends test_casesCreateArgs>(args: SelectSubset<T, test_casesCreateArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_cases.
     * @param {test_casesCreateManyArgs} args - Arguments to create many Test_cases.
     * @example
     * // Create many Test_cases
     * const test_cases = await prisma.test_cases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_casesCreateManyArgs>(args?: SelectSubset<T, test_casesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_cases.
     * @param {test_casesDeleteArgs} args - Arguments to delete one Test_cases.
     * @example
     * // Delete one Test_cases
     * const Test_cases = await prisma.test_cases.delete({
     *   where: {
     *     // ... filter to delete one Test_cases
     *   }
     * })
     * 
     */
    delete<T extends test_casesDeleteArgs>(args: SelectSubset<T, test_casesDeleteArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_cases.
     * @param {test_casesUpdateArgs} args - Arguments to update one Test_cases.
     * @example
     * // Update one Test_cases
     * const test_cases = await prisma.test_cases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_casesUpdateArgs>(args: SelectSubset<T, test_casesUpdateArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_cases.
     * @param {test_casesDeleteManyArgs} args - Arguments to filter Test_cases to delete.
     * @example
     * // Delete a few Test_cases
     * const { count } = await prisma.test_cases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_casesDeleteManyArgs>(args?: SelectSubset<T, test_casesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_casesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_cases
     * const test_cases = await prisma.test_cases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_casesUpdateManyArgs>(args: SelectSubset<T, test_casesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_cases.
     * @param {test_casesUpsertArgs} args - Arguments to update or create a Test_cases.
     * @example
     * // Update or create a Test_cases
     * const test_cases = await prisma.test_cases.upsert({
     *   create: {
     *     // ... data to create a Test_cases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_cases we want to update
     *   }
     * })
     */
    upsert<T extends test_casesUpsertArgs>(args: SelectSubset<T, test_casesUpsertArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_casesCountArgs} args - Arguments to filter Test_cases to count.
     * @example
     * // Count the number of Test_cases
     * const count = await prisma.test_cases.count({
     *   where: {
     *     // ... the filter for the Test_cases we want to count
     *   }
     * })
    **/
    count<T extends test_casesCountArgs>(
      args?: Subset<T, test_casesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_casesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_casesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_casesAggregateArgs>(args: Subset<T, Test_casesAggregateArgs>): Prisma.PrismaPromise<GetTest_casesAggregateType<T>>

    /**
     * Group by Test_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_casesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_casesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_casesGroupByArgs['orderBy'] }
        : { orderBy?: test_casesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_casesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_casesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_cases model
   */
  readonly fields: test_casesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_cases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_casesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patch_proposals<T extends test_cases$patch_proposalsArgs<ExtArgs> = {}>(args?: Subset<T, test_cases$patch_proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    case_versions<T extends test_cases$case_versionsArgs<ExtArgs> = {}>(args?: Subset<T, test_cases$case_versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    step_screenshots<T extends test_cases$step_screenshotsArgs<ExtArgs> = {}>(args?: Subset<T, test_cases$step_screenshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$step_screenshotsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suite_case_map<T extends test_cases$suite_case_mapArgs<ExtArgs> = {}>(args?: Subset<T, test_cases$suite_case_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_case_executions<T extends test_cases$test_case_executionsArgs<ExtArgs> = {}>(args?: Subset<T, test_cases$test_case_executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_run_results<T extends test_cases$test_run_resultsArgs<ExtArgs> = {}>(args?: Subset<T, test_cases$test_run_resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_cases model
   */
  interface test_casesFieldRefs {
    readonly id: FieldRef<"test_cases", 'Int'>
    readonly title: FieldRef<"test_cases", 'String'>
    readonly steps: FieldRef<"test_cases", 'Json'>
    readonly tags: FieldRef<"test_cases", 'Json'>
    readonly system: FieldRef<"test_cases", 'String'>
    readonly module: FieldRef<"test_cases", 'String'>
    readonly project: FieldRef<"test_cases", 'String'>
    readonly created_at: FieldRef<"test_cases", 'DateTime'>
    readonly updated_at: FieldRef<"test_cases", 'DateTime'>
    readonly deleted_at: FieldRef<"test_cases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_cases findUnique
   */
  export type test_casesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_cases to fetch.
     */
    where: test_casesWhereUniqueInput
  }

  /**
   * test_cases findUniqueOrThrow
   */
  export type test_casesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_cases to fetch.
     */
    where: test_casesWhereUniqueInput
  }

  /**
   * test_cases findFirst
   */
  export type test_casesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_cases to fetch.
     */
    where?: test_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_cases to fetch.
     */
    orderBy?: test_casesOrderByWithRelationInput | test_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_cases.
     */
    cursor?: test_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_cases.
     */
    distinct?: Test_casesScalarFieldEnum | Test_casesScalarFieldEnum[]
  }

  /**
   * test_cases findFirstOrThrow
   */
  export type test_casesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_cases to fetch.
     */
    where?: test_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_cases to fetch.
     */
    orderBy?: test_casesOrderByWithRelationInput | test_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_cases.
     */
    cursor?: test_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_cases.
     */
    distinct?: Test_casesScalarFieldEnum | Test_casesScalarFieldEnum[]
  }

  /**
   * test_cases findMany
   */
  export type test_casesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_cases to fetch.
     */
    where?: test_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_cases to fetch.
     */
    orderBy?: test_casesOrderByWithRelationInput | test_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_cases.
     */
    cursor?: test_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_cases.
     */
    skip?: number
    distinct?: Test_casesScalarFieldEnum | Test_casesScalarFieldEnum[]
  }

  /**
   * test_cases create
   */
  export type test_casesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * The data needed to create a test_cases.
     */
    data: XOR<test_casesCreateInput, test_casesUncheckedCreateInput>
  }

  /**
   * test_cases createMany
   */
  export type test_casesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_cases.
     */
    data: test_casesCreateManyInput | test_casesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_cases update
   */
  export type test_casesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * The data needed to update a test_cases.
     */
    data: XOR<test_casesUpdateInput, test_casesUncheckedUpdateInput>
    /**
     * Choose, which test_cases to update.
     */
    where: test_casesWhereUniqueInput
  }

  /**
   * test_cases updateMany
   */
  export type test_casesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_cases.
     */
    data: XOR<test_casesUpdateManyMutationInput, test_casesUncheckedUpdateManyInput>
    /**
     * Filter which test_cases to update
     */
    where?: test_casesWhereInput
    /**
     * Limit how many test_cases to update.
     */
    limit?: number
  }

  /**
   * test_cases upsert
   */
  export type test_casesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * The filter to search for the test_cases to update in case it exists.
     */
    where: test_casesWhereUniqueInput
    /**
     * In case the test_cases found by the `where` argument doesn't exist, create a new test_cases with this data.
     */
    create: XOR<test_casesCreateInput, test_casesUncheckedCreateInput>
    /**
     * In case the test_cases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_casesUpdateInput, test_casesUncheckedUpdateInput>
  }

  /**
   * test_cases delete
   */
  export type test_casesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
    /**
     * Filter which test_cases to delete.
     */
    where: test_casesWhereUniqueInput
  }

  /**
   * test_cases deleteMany
   */
  export type test_casesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_cases to delete
     */
    where?: test_casesWhereInput
    /**
     * Limit how many test_cases to delete.
     */
    limit?: number
  }

  /**
   * test_cases.patch_proposals
   */
  export type test_cases$patch_proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    where?: case_patch_proposalsWhereInput
    orderBy?: case_patch_proposalsOrderByWithRelationInput | case_patch_proposalsOrderByWithRelationInput[]
    cursor?: case_patch_proposalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Case_patch_proposalsScalarFieldEnum | Case_patch_proposalsScalarFieldEnum[]
  }

  /**
   * test_cases.case_versions
   */
  export type test_cases$case_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    where?: case_versionsWhereInput
    orderBy?: case_versionsOrderByWithRelationInput | case_versionsOrderByWithRelationInput[]
    cursor?: case_versionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Case_versionsScalarFieldEnum | Case_versionsScalarFieldEnum[]
  }

  /**
   * test_cases.step_screenshots
   */
  export type test_cases$step_screenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the step_screenshots
     */
    select?: step_screenshotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the step_screenshots
     */
    omit?: step_screenshotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: step_screenshotsInclude<ExtArgs> | null
    where?: step_screenshotsWhereInput
    orderBy?: step_screenshotsOrderByWithRelationInput | step_screenshotsOrderByWithRelationInput[]
    cursor?: step_screenshotsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Step_screenshotsScalarFieldEnum | Step_screenshotsScalarFieldEnum[]
  }

  /**
   * test_cases.suite_case_map
   */
  export type test_cases$suite_case_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    where?: suite_case_mapWhereInput
    orderBy?: suite_case_mapOrderByWithRelationInput | suite_case_mapOrderByWithRelationInput[]
    cursor?: suite_case_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Suite_case_mapScalarFieldEnum | Suite_case_mapScalarFieldEnum[]
  }

  /**
   * test_cases.test_case_executions
   */
  export type test_cases$test_case_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    where?: test_case_executionsWhereInput
    orderBy?: test_case_executionsOrderByWithRelationInput | test_case_executionsOrderByWithRelationInput[]
    cursor?: test_case_executionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_case_executionsScalarFieldEnum | Test_case_executionsScalarFieldEnum[]
  }

  /**
   * test_cases.test_run_results
   */
  export type test_cases$test_run_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    where?: test_run_resultsWhereInput
    orderBy?: test_run_resultsOrderByWithRelationInput | test_run_resultsOrderByWithRelationInput[]
    cursor?: test_run_resultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_run_resultsScalarFieldEnum | Test_run_resultsScalarFieldEnum[]
  }

  /**
   * test_cases without action
   */
  export type test_casesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_cases
     */
    select?: test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_cases
     */
    omit?: test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_casesInclude<ExtArgs> | null
  }


  /**
   * Model test_run_results
   */

  export type AggregateTest_run_results = {
    _count: Test_run_resultsCountAggregateOutputType | null
    _avg: Test_run_resultsAvgAggregateOutputType | null
    _sum: Test_run_resultsSumAggregateOutputType | null
    _min: Test_run_resultsMinAggregateOutputType | null
    _max: Test_run_resultsMaxAggregateOutputType | null
  }

  export type Test_run_resultsAvgAggregateOutputType = {
    id: number | null
    run_id: number | null
    case_id: number | null
    duration_ms: number | null
  }

  export type Test_run_resultsSumAggregateOutputType = {
    id: number | null
    run_id: number | null
    case_id: number | null
    duration_ms: number | null
  }

  export type Test_run_resultsMinAggregateOutputType = {
    id: number | null
    run_id: number | null
    case_id: number | null
    status: $Enums.test_run_results_status | null
    duration_ms: number | null
    screenshot_url: string | null
    executed_at: Date | null
  }

  export type Test_run_resultsMaxAggregateOutputType = {
    id: number | null
    run_id: number | null
    case_id: number | null
    status: $Enums.test_run_results_status | null
    duration_ms: number | null
    screenshot_url: string | null
    executed_at: Date | null
  }

  export type Test_run_resultsCountAggregateOutputType = {
    id: number
    run_id: number
    case_id: number
    status: number
    duration_ms: number
    screenshot_url: number
    executed_at: number
    _all: number
  }


  export type Test_run_resultsAvgAggregateInputType = {
    id?: true
    run_id?: true
    case_id?: true
    duration_ms?: true
  }

  export type Test_run_resultsSumAggregateInputType = {
    id?: true
    run_id?: true
    case_id?: true
    duration_ms?: true
  }

  export type Test_run_resultsMinAggregateInputType = {
    id?: true
    run_id?: true
    case_id?: true
    status?: true
    duration_ms?: true
    screenshot_url?: true
    executed_at?: true
  }

  export type Test_run_resultsMaxAggregateInputType = {
    id?: true
    run_id?: true
    case_id?: true
    status?: true
    duration_ms?: true
    screenshot_url?: true
    executed_at?: true
  }

  export type Test_run_resultsCountAggregateInputType = {
    id?: true
    run_id?: true
    case_id?: true
    status?: true
    duration_ms?: true
    screenshot_url?: true
    executed_at?: true
    _all?: true
  }

  export type Test_run_resultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_run_results to aggregate.
     */
    where?: test_run_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_run_results to fetch.
     */
    orderBy?: test_run_resultsOrderByWithRelationInput | test_run_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_run_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_run_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_run_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_run_results
    **/
    _count?: true | Test_run_resultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_run_resultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_run_resultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_run_resultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_run_resultsMaxAggregateInputType
  }

  export type GetTest_run_resultsAggregateType<T extends Test_run_resultsAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_run_results]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_run_results[P]>
      : GetScalarType<T[P], AggregateTest_run_results[P]>
  }




  export type test_run_resultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_run_resultsWhereInput
    orderBy?: test_run_resultsOrderByWithAggregationInput | test_run_resultsOrderByWithAggregationInput[]
    by: Test_run_resultsScalarFieldEnum[] | Test_run_resultsScalarFieldEnum
    having?: test_run_resultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_run_resultsCountAggregateInputType | true
    _avg?: Test_run_resultsAvgAggregateInputType
    _sum?: Test_run_resultsSumAggregateInputType
    _min?: Test_run_resultsMinAggregateInputType
    _max?: Test_run_resultsMaxAggregateInputType
  }

  export type Test_run_resultsGroupByOutputType = {
    id: number
    run_id: number
    case_id: number
    status: $Enums.test_run_results_status
    duration_ms: number | null
    screenshot_url: string | null
    executed_at: Date | null
    _count: Test_run_resultsCountAggregateOutputType | null
    _avg: Test_run_resultsAvgAggregateOutputType | null
    _sum: Test_run_resultsSumAggregateOutputType | null
    _min: Test_run_resultsMinAggregateOutputType | null
    _max: Test_run_resultsMaxAggregateOutputType | null
  }

  type GetTest_run_resultsGroupByPayload<T extends test_run_resultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_run_resultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_run_resultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_run_resultsGroupByOutputType[P]>
            : GetScalarType<T[P], Test_run_resultsGroupByOutputType[P]>
        }
      >
    >


  export type test_run_resultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    run_id?: boolean
    case_id?: boolean
    status?: boolean
    duration_ms?: boolean
    screenshot_url?: boolean
    executed_at?: boolean
    attachments?: boolean | test_run_results$attachmentsArgs<ExtArgs>
    test_runs?: boolean | test_runsDefaultArgs<ExtArgs>
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
    _count?: boolean | Test_run_resultsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_run_results"]>



  export type test_run_resultsSelectScalar = {
    id?: boolean
    run_id?: boolean
    case_id?: boolean
    status?: boolean
    duration_ms?: boolean
    screenshot_url?: boolean
    executed_at?: boolean
  }

  export type test_run_resultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "run_id" | "case_id" | "status" | "duration_ms" | "screenshot_url" | "executed_at", ExtArgs["result"]["test_run_results"]>
  export type test_run_resultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | test_run_results$attachmentsArgs<ExtArgs>
    test_runs?: boolean | test_runsDefaultArgs<ExtArgs>
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
    _count?: boolean | Test_run_resultsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $test_run_resultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_run_results"
    objects: {
      attachments: Prisma.$attachmentsPayload<ExtArgs>[]
      test_runs: Prisma.$test_runsPayload<ExtArgs>
      test_cases: Prisma.$test_casesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      run_id: number
      case_id: number
      status: $Enums.test_run_results_status
      duration_ms: number | null
      screenshot_url: string | null
      executed_at: Date | null
    }, ExtArgs["result"]["test_run_results"]>
    composites: {}
  }

  type test_run_resultsGetPayload<S extends boolean | null | undefined | test_run_resultsDefaultArgs> = $Result.GetResult<Prisma.$test_run_resultsPayload, S>

  type test_run_resultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_run_resultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_run_resultsCountAggregateInputType | true
    }

  export interface test_run_resultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_run_results'], meta: { name: 'test_run_results' } }
    /**
     * Find zero or one Test_run_results that matches the filter.
     * @param {test_run_resultsFindUniqueArgs} args - Arguments to find a Test_run_results
     * @example
     * // Get one Test_run_results
     * const test_run_results = await prisma.test_run_results.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_run_resultsFindUniqueArgs>(args: SelectSubset<T, test_run_resultsFindUniqueArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_run_results that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_run_resultsFindUniqueOrThrowArgs} args - Arguments to find a Test_run_results
     * @example
     * // Get one Test_run_results
     * const test_run_results = await prisma.test_run_results.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_run_resultsFindUniqueOrThrowArgs>(args: SelectSubset<T, test_run_resultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_run_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_run_resultsFindFirstArgs} args - Arguments to find a Test_run_results
     * @example
     * // Get one Test_run_results
     * const test_run_results = await prisma.test_run_results.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_run_resultsFindFirstArgs>(args?: SelectSubset<T, test_run_resultsFindFirstArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_run_results that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_run_resultsFindFirstOrThrowArgs} args - Arguments to find a Test_run_results
     * @example
     * // Get one Test_run_results
     * const test_run_results = await prisma.test_run_results.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_run_resultsFindFirstOrThrowArgs>(args?: SelectSubset<T, test_run_resultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_run_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_run_resultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_run_results
     * const test_run_results = await prisma.test_run_results.findMany()
     * 
     * // Get first 10 Test_run_results
     * const test_run_results = await prisma.test_run_results.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const test_run_resultsWithIdOnly = await prisma.test_run_results.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends test_run_resultsFindManyArgs>(args?: SelectSubset<T, test_run_resultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_run_results.
     * @param {test_run_resultsCreateArgs} args - Arguments to create a Test_run_results.
     * @example
     * // Create one Test_run_results
     * const Test_run_results = await prisma.test_run_results.create({
     *   data: {
     *     // ... data to create a Test_run_results
     *   }
     * })
     * 
     */
    create<T extends test_run_resultsCreateArgs>(args: SelectSubset<T, test_run_resultsCreateArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_run_results.
     * @param {test_run_resultsCreateManyArgs} args - Arguments to create many Test_run_results.
     * @example
     * // Create many Test_run_results
     * const test_run_results = await prisma.test_run_results.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_run_resultsCreateManyArgs>(args?: SelectSubset<T, test_run_resultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_run_results.
     * @param {test_run_resultsDeleteArgs} args - Arguments to delete one Test_run_results.
     * @example
     * // Delete one Test_run_results
     * const Test_run_results = await prisma.test_run_results.delete({
     *   where: {
     *     // ... filter to delete one Test_run_results
     *   }
     * })
     * 
     */
    delete<T extends test_run_resultsDeleteArgs>(args: SelectSubset<T, test_run_resultsDeleteArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_run_results.
     * @param {test_run_resultsUpdateArgs} args - Arguments to update one Test_run_results.
     * @example
     * // Update one Test_run_results
     * const test_run_results = await prisma.test_run_results.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_run_resultsUpdateArgs>(args: SelectSubset<T, test_run_resultsUpdateArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_run_results.
     * @param {test_run_resultsDeleteManyArgs} args - Arguments to filter Test_run_results to delete.
     * @example
     * // Delete a few Test_run_results
     * const { count } = await prisma.test_run_results.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_run_resultsDeleteManyArgs>(args?: SelectSubset<T, test_run_resultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_run_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_run_resultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_run_results
     * const test_run_results = await prisma.test_run_results.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_run_resultsUpdateManyArgs>(args: SelectSubset<T, test_run_resultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_run_results.
     * @param {test_run_resultsUpsertArgs} args - Arguments to update or create a Test_run_results.
     * @example
     * // Update or create a Test_run_results
     * const test_run_results = await prisma.test_run_results.upsert({
     *   create: {
     *     // ... data to create a Test_run_results
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_run_results we want to update
     *   }
     * })
     */
    upsert<T extends test_run_resultsUpsertArgs>(args: SelectSubset<T, test_run_resultsUpsertArgs<ExtArgs>>): Prisma__test_run_resultsClient<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_run_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_run_resultsCountArgs} args - Arguments to filter Test_run_results to count.
     * @example
     * // Count the number of Test_run_results
     * const count = await prisma.test_run_results.count({
     *   where: {
     *     // ... the filter for the Test_run_results we want to count
     *   }
     * })
    **/
    count<T extends test_run_resultsCountArgs>(
      args?: Subset<T, test_run_resultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_run_resultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_run_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_run_resultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_run_resultsAggregateArgs>(args: Subset<T, Test_run_resultsAggregateArgs>): Prisma.PrismaPromise<GetTest_run_resultsAggregateType<T>>

    /**
     * Group by Test_run_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_run_resultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_run_resultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_run_resultsGroupByArgs['orderBy'] }
        : { orderBy?: test_run_resultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_run_resultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_run_resultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_run_results model
   */
  readonly fields: test_run_resultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_run_results.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_run_resultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachments<T extends test_run_results$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, test_run_results$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_runs<T extends test_runsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_runsDefaultArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    test_cases<T extends test_casesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_casesDefaultArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_run_results model
   */
  interface test_run_resultsFieldRefs {
    readonly id: FieldRef<"test_run_results", 'Int'>
    readonly run_id: FieldRef<"test_run_results", 'Int'>
    readonly case_id: FieldRef<"test_run_results", 'Int'>
    readonly status: FieldRef<"test_run_results", 'test_run_results_status'>
    readonly duration_ms: FieldRef<"test_run_results", 'Int'>
    readonly screenshot_url: FieldRef<"test_run_results", 'String'>
    readonly executed_at: FieldRef<"test_run_results", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_run_results findUnique
   */
  export type test_run_resultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * Filter, which test_run_results to fetch.
     */
    where: test_run_resultsWhereUniqueInput
  }

  /**
   * test_run_results findUniqueOrThrow
   */
  export type test_run_resultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * Filter, which test_run_results to fetch.
     */
    where: test_run_resultsWhereUniqueInput
  }

  /**
   * test_run_results findFirst
   */
  export type test_run_resultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * Filter, which test_run_results to fetch.
     */
    where?: test_run_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_run_results to fetch.
     */
    orderBy?: test_run_resultsOrderByWithRelationInput | test_run_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_run_results.
     */
    cursor?: test_run_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_run_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_run_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_run_results.
     */
    distinct?: Test_run_resultsScalarFieldEnum | Test_run_resultsScalarFieldEnum[]
  }

  /**
   * test_run_results findFirstOrThrow
   */
  export type test_run_resultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * Filter, which test_run_results to fetch.
     */
    where?: test_run_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_run_results to fetch.
     */
    orderBy?: test_run_resultsOrderByWithRelationInput | test_run_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_run_results.
     */
    cursor?: test_run_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_run_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_run_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_run_results.
     */
    distinct?: Test_run_resultsScalarFieldEnum | Test_run_resultsScalarFieldEnum[]
  }

  /**
   * test_run_results findMany
   */
  export type test_run_resultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * Filter, which test_run_results to fetch.
     */
    where?: test_run_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_run_results to fetch.
     */
    orderBy?: test_run_resultsOrderByWithRelationInput | test_run_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_run_results.
     */
    cursor?: test_run_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_run_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_run_results.
     */
    skip?: number
    distinct?: Test_run_resultsScalarFieldEnum | Test_run_resultsScalarFieldEnum[]
  }

  /**
   * test_run_results create
   */
  export type test_run_resultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * The data needed to create a test_run_results.
     */
    data: XOR<test_run_resultsCreateInput, test_run_resultsUncheckedCreateInput>
  }

  /**
   * test_run_results createMany
   */
  export type test_run_resultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_run_results.
     */
    data: test_run_resultsCreateManyInput | test_run_resultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_run_results update
   */
  export type test_run_resultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * The data needed to update a test_run_results.
     */
    data: XOR<test_run_resultsUpdateInput, test_run_resultsUncheckedUpdateInput>
    /**
     * Choose, which test_run_results to update.
     */
    where: test_run_resultsWhereUniqueInput
  }

  /**
   * test_run_results updateMany
   */
  export type test_run_resultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_run_results.
     */
    data: XOR<test_run_resultsUpdateManyMutationInput, test_run_resultsUncheckedUpdateManyInput>
    /**
     * Filter which test_run_results to update
     */
    where?: test_run_resultsWhereInput
    /**
     * Limit how many test_run_results to update.
     */
    limit?: number
  }

  /**
   * test_run_results upsert
   */
  export type test_run_resultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * The filter to search for the test_run_results to update in case it exists.
     */
    where: test_run_resultsWhereUniqueInput
    /**
     * In case the test_run_results found by the `where` argument doesn't exist, create a new test_run_results with this data.
     */
    create: XOR<test_run_resultsCreateInput, test_run_resultsUncheckedCreateInput>
    /**
     * In case the test_run_results was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_run_resultsUpdateInput, test_run_resultsUncheckedUpdateInput>
  }

  /**
   * test_run_results delete
   */
  export type test_run_resultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    /**
     * Filter which test_run_results to delete.
     */
    where: test_run_resultsWhereUniqueInput
  }

  /**
   * test_run_results deleteMany
   */
  export type test_run_resultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_run_results to delete
     */
    where?: test_run_resultsWhereInput
    /**
     * Limit how many test_run_results to delete.
     */
    limit?: number
  }

  /**
   * test_run_results.attachments
   */
  export type test_run_results$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    where?: attachmentsWhereInput
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    cursor?: attachmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * test_run_results without action
   */
  export type test_run_resultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
  }


  /**
   * Model test_runs
   */

  export type AggregateTest_runs = {
    _count: Test_runsCountAggregateOutputType | null
    _avg: Test_runsAvgAggregateOutputType | null
    _sum: Test_runsSumAggregateOutputType | null
    _min: Test_runsMinAggregateOutputType | null
    _max: Test_runsMaxAggregateOutputType | null
  }

  export type Test_runsAvgAggregateOutputType = {
    id: number | null
    suite_id: number | null
    trigger_user_id: number | null
  }

  export type Test_runsSumAggregateOutputType = {
    id: number | null
    suite_id: number | null
    trigger_user_id: number | null
  }

  export type Test_runsMinAggregateOutputType = {
    id: number | null
    suite_id: number | null
    trigger_user_id: number | null
    status: $Enums.test_runs_status | null
    started_at: Date | null
    finished_at: Date | null
  }

  export type Test_runsMaxAggregateOutputType = {
    id: number | null
    suite_id: number | null
    trigger_user_id: number | null
    status: $Enums.test_runs_status | null
    started_at: Date | null
    finished_at: Date | null
  }

  export type Test_runsCountAggregateOutputType = {
    id: number
    suite_id: number
    trigger_user_id: number
    status: number
    started_at: number
    finished_at: number
    _all: number
  }


  export type Test_runsAvgAggregateInputType = {
    id?: true
    suite_id?: true
    trigger_user_id?: true
  }

  export type Test_runsSumAggregateInputType = {
    id?: true
    suite_id?: true
    trigger_user_id?: true
  }

  export type Test_runsMinAggregateInputType = {
    id?: true
    suite_id?: true
    trigger_user_id?: true
    status?: true
    started_at?: true
    finished_at?: true
  }

  export type Test_runsMaxAggregateInputType = {
    id?: true
    suite_id?: true
    trigger_user_id?: true
    status?: true
    started_at?: true
    finished_at?: true
  }

  export type Test_runsCountAggregateInputType = {
    id?: true
    suite_id?: true
    trigger_user_id?: true
    status?: true
    started_at?: true
    finished_at?: true
    _all?: true
  }

  export type Test_runsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_runs to aggregate.
     */
    where?: test_runsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_runs to fetch.
     */
    orderBy?: test_runsOrderByWithRelationInput | test_runsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_runsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_runs
    **/
    _count?: true | Test_runsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_runsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_runsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_runsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_runsMaxAggregateInputType
  }

  export type GetTest_runsAggregateType<T extends Test_runsAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_runs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_runs[P]>
      : GetScalarType<T[P], AggregateTest_runs[P]>
  }




  export type test_runsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_runsWhereInput
    orderBy?: test_runsOrderByWithAggregationInput | test_runsOrderByWithAggregationInput[]
    by: Test_runsScalarFieldEnum[] | Test_runsScalarFieldEnum
    having?: test_runsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_runsCountAggregateInputType | true
    _avg?: Test_runsAvgAggregateInputType
    _sum?: Test_runsSumAggregateInputType
    _min?: Test_runsMinAggregateInputType
    _max?: Test_runsMaxAggregateInputType
  }

  export type Test_runsGroupByOutputType = {
    id: number
    suite_id: number
    trigger_user_id: number
    status: $Enums.test_runs_status
    started_at: Date | null
    finished_at: Date | null
    _count: Test_runsCountAggregateOutputType | null
    _avg: Test_runsAvgAggregateOutputType | null
    _sum: Test_runsSumAggregateOutputType | null
    _min: Test_runsMinAggregateOutputType | null
    _max: Test_runsMaxAggregateOutputType | null
  }

  type GetTest_runsGroupByPayload<T extends test_runsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_runsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_runsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_runsGroupByOutputType[P]>
            : GetScalarType<T[P], Test_runsGroupByOutputType[P]>
        }
      >
    >


  export type test_runsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suite_id?: boolean
    trigger_user_id?: boolean
    status?: boolean
    started_at?: boolean
    finished_at?: boolean
    ai_runs?: boolean | test_runs$ai_runsArgs<ExtArgs>
    reports?: boolean | test_runs$reportsArgs<ExtArgs>
    test_run_results?: boolean | test_runs$test_run_resultsArgs<ExtArgs>
    test_suites?: boolean | test_suitesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Test_runsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_runs"]>



  export type test_runsSelectScalar = {
    id?: boolean
    suite_id?: boolean
    trigger_user_id?: boolean
    status?: boolean
    started_at?: boolean
    finished_at?: boolean
  }

  export type test_runsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "suite_id" | "trigger_user_id" | "status" | "started_at" | "finished_at", ExtArgs["result"]["test_runs"]>
  export type test_runsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_runs?: boolean | test_runs$ai_runsArgs<ExtArgs>
    reports?: boolean | test_runs$reportsArgs<ExtArgs>
    test_run_results?: boolean | test_runs$test_run_resultsArgs<ExtArgs>
    test_suites?: boolean | test_suitesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Test_runsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $test_runsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_runs"
    objects: {
      ai_runs: Prisma.$ai_runsPayload<ExtArgs>[]
      reports: Prisma.$reportsPayload<ExtArgs>[]
      test_run_results: Prisma.$test_run_resultsPayload<ExtArgs>[]
      test_suites: Prisma.$test_suitesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      suite_id: number
      trigger_user_id: number
      status: $Enums.test_runs_status
      started_at: Date | null
      finished_at: Date | null
    }, ExtArgs["result"]["test_runs"]>
    composites: {}
  }

  type test_runsGetPayload<S extends boolean | null | undefined | test_runsDefaultArgs> = $Result.GetResult<Prisma.$test_runsPayload, S>

  type test_runsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_runsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_runsCountAggregateInputType | true
    }

  export interface test_runsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_runs'], meta: { name: 'test_runs' } }
    /**
     * Find zero or one Test_runs that matches the filter.
     * @param {test_runsFindUniqueArgs} args - Arguments to find a Test_runs
     * @example
     * // Get one Test_runs
     * const test_runs = await prisma.test_runs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_runsFindUniqueArgs>(args: SelectSubset<T, test_runsFindUniqueArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_runs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_runsFindUniqueOrThrowArgs} args - Arguments to find a Test_runs
     * @example
     * // Get one Test_runs
     * const test_runs = await prisma.test_runs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_runsFindUniqueOrThrowArgs>(args: SelectSubset<T, test_runsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_runs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_runsFindFirstArgs} args - Arguments to find a Test_runs
     * @example
     * // Get one Test_runs
     * const test_runs = await prisma.test_runs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_runsFindFirstArgs>(args?: SelectSubset<T, test_runsFindFirstArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_runs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_runsFindFirstOrThrowArgs} args - Arguments to find a Test_runs
     * @example
     * // Get one Test_runs
     * const test_runs = await prisma.test_runs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_runsFindFirstOrThrowArgs>(args?: SelectSubset<T, test_runsFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_runs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_runsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_runs
     * const test_runs = await prisma.test_runs.findMany()
     * 
     * // Get first 10 Test_runs
     * const test_runs = await prisma.test_runs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const test_runsWithIdOnly = await prisma.test_runs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends test_runsFindManyArgs>(args?: SelectSubset<T, test_runsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_runs.
     * @param {test_runsCreateArgs} args - Arguments to create a Test_runs.
     * @example
     * // Create one Test_runs
     * const Test_runs = await prisma.test_runs.create({
     *   data: {
     *     // ... data to create a Test_runs
     *   }
     * })
     * 
     */
    create<T extends test_runsCreateArgs>(args: SelectSubset<T, test_runsCreateArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_runs.
     * @param {test_runsCreateManyArgs} args - Arguments to create many Test_runs.
     * @example
     * // Create many Test_runs
     * const test_runs = await prisma.test_runs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_runsCreateManyArgs>(args?: SelectSubset<T, test_runsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_runs.
     * @param {test_runsDeleteArgs} args - Arguments to delete one Test_runs.
     * @example
     * // Delete one Test_runs
     * const Test_runs = await prisma.test_runs.delete({
     *   where: {
     *     // ... filter to delete one Test_runs
     *   }
     * })
     * 
     */
    delete<T extends test_runsDeleteArgs>(args: SelectSubset<T, test_runsDeleteArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_runs.
     * @param {test_runsUpdateArgs} args - Arguments to update one Test_runs.
     * @example
     * // Update one Test_runs
     * const test_runs = await prisma.test_runs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_runsUpdateArgs>(args: SelectSubset<T, test_runsUpdateArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_runs.
     * @param {test_runsDeleteManyArgs} args - Arguments to filter Test_runs to delete.
     * @example
     * // Delete a few Test_runs
     * const { count } = await prisma.test_runs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_runsDeleteManyArgs>(args?: SelectSubset<T, test_runsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_runsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_runs
     * const test_runs = await prisma.test_runs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_runsUpdateManyArgs>(args: SelectSubset<T, test_runsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_runs.
     * @param {test_runsUpsertArgs} args - Arguments to update or create a Test_runs.
     * @example
     * // Update or create a Test_runs
     * const test_runs = await prisma.test_runs.upsert({
     *   create: {
     *     // ... data to create a Test_runs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_runs we want to update
     *   }
     * })
     */
    upsert<T extends test_runsUpsertArgs>(args: SelectSubset<T, test_runsUpsertArgs<ExtArgs>>): Prisma__test_runsClient<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_runsCountArgs} args - Arguments to filter Test_runs to count.
     * @example
     * // Count the number of Test_runs
     * const count = await prisma.test_runs.count({
     *   where: {
     *     // ... the filter for the Test_runs we want to count
     *   }
     * })
    **/
    count<T extends test_runsCountArgs>(
      args?: Subset<T, test_runsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_runsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_runsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_runsAggregateArgs>(args: Subset<T, Test_runsAggregateArgs>): Prisma.PrismaPromise<GetTest_runsAggregateType<T>>

    /**
     * Group by Test_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_runsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_runsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_runsGroupByArgs['orderBy'] }
        : { orderBy?: test_runsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_runsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_runsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_runs model
   */
  readonly fields: test_runsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_runs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_runsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ai_runs<T extends test_runs$ai_runsArgs<ExtArgs> = {}>(args?: Subset<T, test_runs$ai_runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_runsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends test_runs$reportsArgs<ExtArgs> = {}>(args?: Subset<T, test_runs$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_run_results<T extends test_runs$test_run_resultsArgs<ExtArgs> = {}>(args?: Subset<T, test_runs$test_run_resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_run_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_suites<T extends test_suitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_suitesDefaultArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_runs model
   */
  interface test_runsFieldRefs {
    readonly id: FieldRef<"test_runs", 'Int'>
    readonly suite_id: FieldRef<"test_runs", 'Int'>
    readonly trigger_user_id: FieldRef<"test_runs", 'Int'>
    readonly status: FieldRef<"test_runs", 'test_runs_status'>
    readonly started_at: FieldRef<"test_runs", 'DateTime'>
    readonly finished_at: FieldRef<"test_runs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_runs findUnique
   */
  export type test_runsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * Filter, which test_runs to fetch.
     */
    where: test_runsWhereUniqueInput
  }

  /**
   * test_runs findUniqueOrThrow
   */
  export type test_runsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * Filter, which test_runs to fetch.
     */
    where: test_runsWhereUniqueInput
  }

  /**
   * test_runs findFirst
   */
  export type test_runsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * Filter, which test_runs to fetch.
     */
    where?: test_runsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_runs to fetch.
     */
    orderBy?: test_runsOrderByWithRelationInput | test_runsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_runs.
     */
    cursor?: test_runsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_runs.
     */
    distinct?: Test_runsScalarFieldEnum | Test_runsScalarFieldEnum[]
  }

  /**
   * test_runs findFirstOrThrow
   */
  export type test_runsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * Filter, which test_runs to fetch.
     */
    where?: test_runsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_runs to fetch.
     */
    orderBy?: test_runsOrderByWithRelationInput | test_runsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_runs.
     */
    cursor?: test_runsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_runs.
     */
    distinct?: Test_runsScalarFieldEnum | Test_runsScalarFieldEnum[]
  }

  /**
   * test_runs findMany
   */
  export type test_runsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * Filter, which test_runs to fetch.
     */
    where?: test_runsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_runs to fetch.
     */
    orderBy?: test_runsOrderByWithRelationInput | test_runsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_runs.
     */
    cursor?: test_runsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_runs.
     */
    skip?: number
    distinct?: Test_runsScalarFieldEnum | Test_runsScalarFieldEnum[]
  }

  /**
   * test_runs create
   */
  export type test_runsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * The data needed to create a test_runs.
     */
    data: XOR<test_runsCreateInput, test_runsUncheckedCreateInput>
  }

  /**
   * test_runs createMany
   */
  export type test_runsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_runs.
     */
    data: test_runsCreateManyInput | test_runsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_runs update
   */
  export type test_runsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * The data needed to update a test_runs.
     */
    data: XOR<test_runsUpdateInput, test_runsUncheckedUpdateInput>
    /**
     * Choose, which test_runs to update.
     */
    where: test_runsWhereUniqueInput
  }

  /**
   * test_runs updateMany
   */
  export type test_runsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_runs.
     */
    data: XOR<test_runsUpdateManyMutationInput, test_runsUncheckedUpdateManyInput>
    /**
     * Filter which test_runs to update
     */
    where?: test_runsWhereInput
    /**
     * Limit how many test_runs to update.
     */
    limit?: number
  }

  /**
   * test_runs upsert
   */
  export type test_runsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * The filter to search for the test_runs to update in case it exists.
     */
    where: test_runsWhereUniqueInput
    /**
     * In case the test_runs found by the `where` argument doesn't exist, create a new test_runs with this data.
     */
    create: XOR<test_runsCreateInput, test_runsUncheckedCreateInput>
    /**
     * In case the test_runs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_runsUpdateInput, test_runsUncheckedUpdateInput>
  }

  /**
   * test_runs delete
   */
  export type test_runsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    /**
     * Filter which test_runs to delete.
     */
    where: test_runsWhereUniqueInput
  }

  /**
   * test_runs deleteMany
   */
  export type test_runsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_runs to delete
     */
    where?: test_runsWhereInput
    /**
     * Limit how many test_runs to delete.
     */
    limit?: number
  }

  /**
   * test_runs.ai_runs
   */
  export type test_runs$ai_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_runs
     */
    select?: ai_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_runs
     */
    omit?: ai_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_runsInclude<ExtArgs> | null
    where?: ai_runsWhereInput
    orderBy?: ai_runsOrderByWithRelationInput | ai_runsOrderByWithRelationInput[]
    cursor?: ai_runsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_runsScalarFieldEnum | Ai_runsScalarFieldEnum[]
  }

  /**
   * test_runs.reports
   */
  export type test_runs$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    where?: reportsWhereInput
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    cursor?: reportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * test_runs.test_run_results
   */
  export type test_runs$test_run_resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_run_results
     */
    select?: test_run_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_run_results
     */
    omit?: test_run_resultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_run_resultsInclude<ExtArgs> | null
    where?: test_run_resultsWhereInput
    orderBy?: test_run_resultsOrderByWithRelationInput | test_run_resultsOrderByWithRelationInput[]
    cursor?: test_run_resultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_run_resultsScalarFieldEnum | Test_run_resultsScalarFieldEnum[]
  }

  /**
   * test_runs without action
   */
  export type test_runsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
  }


  /**
   * Model test_suites
   */

  export type AggregateTest_suites = {
    _count: Test_suitesCountAggregateOutputType | null
    _avg: Test_suitesAvgAggregateOutputType | null
    _sum: Test_suitesSumAggregateOutputType | null
    _min: Test_suitesMinAggregateOutputType | null
    _max: Test_suitesMaxAggregateOutputType | null
  }

  export type Test_suitesAvgAggregateOutputType = {
    id: number | null
    owner_id: number | null
  }

  export type Test_suitesSumAggregateOutputType = {
    id: number | null
    owner_id: number | null
  }

  export type Test_suitesMinAggregateOutputType = {
    id: number | null
    name: string | null
    owner_id: number | null
    project: string | null
    created_at: Date | null
  }

  export type Test_suitesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    owner_id: number | null
    project: string | null
    created_at: Date | null
  }

  export type Test_suitesCountAggregateOutputType = {
    id: number
    name: number
    owner_id: number
    project: number
    metadata: number
    created_at: number
    _all: number
  }


  export type Test_suitesAvgAggregateInputType = {
    id?: true
    owner_id?: true
  }

  export type Test_suitesSumAggregateInputType = {
    id?: true
    owner_id?: true
  }

  export type Test_suitesMinAggregateInputType = {
    id?: true
    name?: true
    owner_id?: true
    project?: true
    created_at?: true
  }

  export type Test_suitesMaxAggregateInputType = {
    id?: true
    name?: true
    owner_id?: true
    project?: true
    created_at?: true
  }

  export type Test_suitesCountAggregateInputType = {
    id?: true
    name?: true
    owner_id?: true
    project?: true
    metadata?: true
    created_at?: true
    _all?: true
  }

  export type Test_suitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_suites to aggregate.
     */
    where?: test_suitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_suites to fetch.
     */
    orderBy?: test_suitesOrderByWithRelationInput | test_suitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_suitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_suites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_suites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_suites
    **/
    _count?: true | Test_suitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_suitesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_suitesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_suitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_suitesMaxAggregateInputType
  }

  export type GetTest_suitesAggregateType<T extends Test_suitesAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_suites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_suites[P]>
      : GetScalarType<T[P], AggregateTest_suites[P]>
  }




  export type test_suitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_suitesWhereInput
    orderBy?: test_suitesOrderByWithAggregationInput | test_suitesOrderByWithAggregationInput[]
    by: Test_suitesScalarFieldEnum[] | Test_suitesScalarFieldEnum
    having?: test_suitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_suitesCountAggregateInputType | true
    _avg?: Test_suitesAvgAggregateInputType
    _sum?: Test_suitesSumAggregateInputType
    _min?: Test_suitesMinAggregateInputType
    _max?: Test_suitesMaxAggregateInputType
  }

  export type Test_suitesGroupByOutputType = {
    id: number
    name: string
    owner_id: number
    project: string | null
    metadata: JsonValue | null
    created_at: Date | null
    _count: Test_suitesCountAggregateOutputType | null
    _avg: Test_suitesAvgAggregateOutputType | null
    _sum: Test_suitesSumAggregateOutputType | null
    _min: Test_suitesMinAggregateOutputType | null
    _max: Test_suitesMaxAggregateOutputType | null
  }

  type GetTest_suitesGroupByPayload<T extends test_suitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_suitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_suitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_suitesGroupByOutputType[P]>
            : GetScalarType<T[P], Test_suitesGroupByOutputType[P]>
        }
      >
    >


  export type test_suitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    owner_id?: boolean
    project?: boolean
    metadata?: boolean
    created_at?: boolean
    suite_case_map?: boolean | test_suites$suite_case_mapArgs<ExtArgs>
    test_runs?: boolean | test_suites$test_runsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Test_suitesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_suites"]>



  export type test_suitesSelectScalar = {
    id?: boolean
    name?: boolean
    owner_id?: boolean
    project?: boolean
    metadata?: boolean
    created_at?: boolean
  }

  export type test_suitesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "owner_id" | "project" | "metadata" | "created_at", ExtArgs["result"]["test_suites"]>
  export type test_suitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suite_case_map?: boolean | test_suites$suite_case_mapArgs<ExtArgs>
    test_runs?: boolean | test_suites$test_runsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Test_suitesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $test_suitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_suites"
    objects: {
      suite_case_map: Prisma.$suite_case_mapPayload<ExtArgs>[]
      test_runs: Prisma.$test_runsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      owner_id: number
      project: string | null
      metadata: Prisma.JsonValue | null
      created_at: Date | null
    }, ExtArgs["result"]["test_suites"]>
    composites: {}
  }

  type test_suitesGetPayload<S extends boolean | null | undefined | test_suitesDefaultArgs> = $Result.GetResult<Prisma.$test_suitesPayload, S>

  type test_suitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_suitesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_suitesCountAggregateInputType | true
    }

  export interface test_suitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_suites'], meta: { name: 'test_suites' } }
    /**
     * Find zero or one Test_suites that matches the filter.
     * @param {test_suitesFindUniqueArgs} args - Arguments to find a Test_suites
     * @example
     * // Get one Test_suites
     * const test_suites = await prisma.test_suites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_suitesFindUniqueArgs>(args: SelectSubset<T, test_suitesFindUniqueArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_suites that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_suitesFindUniqueOrThrowArgs} args - Arguments to find a Test_suites
     * @example
     * // Get one Test_suites
     * const test_suites = await prisma.test_suites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_suitesFindUniqueOrThrowArgs>(args: SelectSubset<T, test_suitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_suites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_suitesFindFirstArgs} args - Arguments to find a Test_suites
     * @example
     * // Get one Test_suites
     * const test_suites = await prisma.test_suites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_suitesFindFirstArgs>(args?: SelectSubset<T, test_suitesFindFirstArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_suites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_suitesFindFirstOrThrowArgs} args - Arguments to find a Test_suites
     * @example
     * // Get one Test_suites
     * const test_suites = await prisma.test_suites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_suitesFindFirstOrThrowArgs>(args?: SelectSubset<T, test_suitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_suites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_suitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_suites
     * const test_suites = await prisma.test_suites.findMany()
     * 
     * // Get first 10 Test_suites
     * const test_suites = await prisma.test_suites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const test_suitesWithIdOnly = await prisma.test_suites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends test_suitesFindManyArgs>(args?: SelectSubset<T, test_suitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_suites.
     * @param {test_suitesCreateArgs} args - Arguments to create a Test_suites.
     * @example
     * // Create one Test_suites
     * const Test_suites = await prisma.test_suites.create({
     *   data: {
     *     // ... data to create a Test_suites
     *   }
     * })
     * 
     */
    create<T extends test_suitesCreateArgs>(args: SelectSubset<T, test_suitesCreateArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_suites.
     * @param {test_suitesCreateManyArgs} args - Arguments to create many Test_suites.
     * @example
     * // Create many Test_suites
     * const test_suites = await prisma.test_suites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_suitesCreateManyArgs>(args?: SelectSubset<T, test_suitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_suites.
     * @param {test_suitesDeleteArgs} args - Arguments to delete one Test_suites.
     * @example
     * // Delete one Test_suites
     * const Test_suites = await prisma.test_suites.delete({
     *   where: {
     *     // ... filter to delete one Test_suites
     *   }
     * })
     * 
     */
    delete<T extends test_suitesDeleteArgs>(args: SelectSubset<T, test_suitesDeleteArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_suites.
     * @param {test_suitesUpdateArgs} args - Arguments to update one Test_suites.
     * @example
     * // Update one Test_suites
     * const test_suites = await prisma.test_suites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_suitesUpdateArgs>(args: SelectSubset<T, test_suitesUpdateArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_suites.
     * @param {test_suitesDeleteManyArgs} args - Arguments to filter Test_suites to delete.
     * @example
     * // Delete a few Test_suites
     * const { count } = await prisma.test_suites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_suitesDeleteManyArgs>(args?: SelectSubset<T, test_suitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_suites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_suitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_suites
     * const test_suites = await prisma.test_suites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_suitesUpdateManyArgs>(args: SelectSubset<T, test_suitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_suites.
     * @param {test_suitesUpsertArgs} args - Arguments to update or create a Test_suites.
     * @example
     * // Update or create a Test_suites
     * const test_suites = await prisma.test_suites.upsert({
     *   create: {
     *     // ... data to create a Test_suites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_suites we want to update
     *   }
     * })
     */
    upsert<T extends test_suitesUpsertArgs>(args: SelectSubset<T, test_suitesUpsertArgs<ExtArgs>>): Prisma__test_suitesClient<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_suites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_suitesCountArgs} args - Arguments to filter Test_suites to count.
     * @example
     * // Count the number of Test_suites
     * const count = await prisma.test_suites.count({
     *   where: {
     *     // ... the filter for the Test_suites we want to count
     *   }
     * })
    **/
    count<T extends test_suitesCountArgs>(
      args?: Subset<T, test_suitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_suitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_suites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_suitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_suitesAggregateArgs>(args: Subset<T, Test_suitesAggregateArgs>): Prisma.PrismaPromise<GetTest_suitesAggregateType<T>>

    /**
     * Group by Test_suites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_suitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_suitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_suitesGroupByArgs['orderBy'] }
        : { orderBy?: test_suitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_suitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_suitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_suites model
   */
  readonly fields: test_suitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_suites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_suitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    suite_case_map<T extends test_suites$suite_case_mapArgs<ExtArgs> = {}>(args?: Subset<T, test_suites$suite_case_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suite_case_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_runs<T extends test_suites$test_runsArgs<ExtArgs> = {}>(args?: Subset<T, test_suites$test_runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_suites model
   */
  interface test_suitesFieldRefs {
    readonly id: FieldRef<"test_suites", 'Int'>
    readonly name: FieldRef<"test_suites", 'String'>
    readonly owner_id: FieldRef<"test_suites", 'Int'>
    readonly project: FieldRef<"test_suites", 'String'>
    readonly metadata: FieldRef<"test_suites", 'Json'>
    readonly created_at: FieldRef<"test_suites", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_suites findUnique
   */
  export type test_suitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * Filter, which test_suites to fetch.
     */
    where: test_suitesWhereUniqueInput
  }

  /**
   * test_suites findUniqueOrThrow
   */
  export type test_suitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * Filter, which test_suites to fetch.
     */
    where: test_suitesWhereUniqueInput
  }

  /**
   * test_suites findFirst
   */
  export type test_suitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * Filter, which test_suites to fetch.
     */
    where?: test_suitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_suites to fetch.
     */
    orderBy?: test_suitesOrderByWithRelationInput | test_suitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_suites.
     */
    cursor?: test_suitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_suites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_suites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_suites.
     */
    distinct?: Test_suitesScalarFieldEnum | Test_suitesScalarFieldEnum[]
  }

  /**
   * test_suites findFirstOrThrow
   */
  export type test_suitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * Filter, which test_suites to fetch.
     */
    where?: test_suitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_suites to fetch.
     */
    orderBy?: test_suitesOrderByWithRelationInput | test_suitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_suites.
     */
    cursor?: test_suitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_suites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_suites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_suites.
     */
    distinct?: Test_suitesScalarFieldEnum | Test_suitesScalarFieldEnum[]
  }

  /**
   * test_suites findMany
   */
  export type test_suitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * Filter, which test_suites to fetch.
     */
    where?: test_suitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_suites to fetch.
     */
    orderBy?: test_suitesOrderByWithRelationInput | test_suitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_suites.
     */
    cursor?: test_suitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_suites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_suites.
     */
    skip?: number
    distinct?: Test_suitesScalarFieldEnum | Test_suitesScalarFieldEnum[]
  }

  /**
   * test_suites create
   */
  export type test_suitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * The data needed to create a test_suites.
     */
    data: XOR<test_suitesCreateInput, test_suitesUncheckedCreateInput>
  }

  /**
   * test_suites createMany
   */
  export type test_suitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_suites.
     */
    data: test_suitesCreateManyInput | test_suitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_suites update
   */
  export type test_suitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * The data needed to update a test_suites.
     */
    data: XOR<test_suitesUpdateInput, test_suitesUncheckedUpdateInput>
    /**
     * Choose, which test_suites to update.
     */
    where: test_suitesWhereUniqueInput
  }

  /**
   * test_suites updateMany
   */
  export type test_suitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_suites.
     */
    data: XOR<test_suitesUpdateManyMutationInput, test_suitesUncheckedUpdateManyInput>
    /**
     * Filter which test_suites to update
     */
    where?: test_suitesWhereInput
    /**
     * Limit how many test_suites to update.
     */
    limit?: number
  }

  /**
   * test_suites upsert
   */
  export type test_suitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * The filter to search for the test_suites to update in case it exists.
     */
    where: test_suitesWhereUniqueInput
    /**
     * In case the test_suites found by the `where` argument doesn't exist, create a new test_suites with this data.
     */
    create: XOR<test_suitesCreateInput, test_suitesUncheckedCreateInput>
    /**
     * In case the test_suites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_suitesUpdateInput, test_suitesUncheckedUpdateInput>
  }

  /**
   * test_suites delete
   */
  export type test_suitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    /**
     * Filter which test_suites to delete.
     */
    where: test_suitesWhereUniqueInput
  }

  /**
   * test_suites deleteMany
   */
  export type test_suitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_suites to delete
     */
    where?: test_suitesWhereInput
    /**
     * Limit how many test_suites to delete.
     */
    limit?: number
  }

  /**
   * test_suites.suite_case_map
   */
  export type test_suites$suite_case_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suite_case_map
     */
    select?: suite_case_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suite_case_map
     */
    omit?: suite_case_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suite_case_mapInclude<ExtArgs> | null
    where?: suite_case_mapWhereInput
    orderBy?: suite_case_mapOrderByWithRelationInput | suite_case_mapOrderByWithRelationInput[]
    cursor?: suite_case_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Suite_case_mapScalarFieldEnum | Suite_case_mapScalarFieldEnum[]
  }

  /**
   * test_suites.test_runs
   */
  export type test_suites$test_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    where?: test_runsWhereInput
    orderBy?: test_runsOrderByWithRelationInput | test_runsOrderByWithRelationInput[]
    cursor?: test_runsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_runsScalarFieldEnum | Test_runsScalarFieldEnum[]
  }

  /**
   * test_suites without action
   */
  export type test_suitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
  }


  /**
   * Model user_roles
   */

  export type AggregateUser_roles = {
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  export type User_rolesAvgAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type User_rolesSumAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type User_rolesMinAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type User_rolesMaxAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type User_rolesCountAggregateOutputType = {
    user_id: number
    role_id: number
    _all: number
  }


  export type User_rolesAvgAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type User_rolesSumAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type User_rolesMinAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type User_rolesMaxAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type User_rolesCountAggregateInputType = {
    user_id?: true
    role_id?: true
    _all?: true
  }

  export type User_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to aggregate.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_rolesMaxAggregateInputType
  }

  export type GetUser_rolesAggregateType<T extends User_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_roles[P]>
      : GetScalarType<T[P], AggregateUser_roles[P]>
  }




  export type user_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithAggregationInput | user_rolesOrderByWithAggregationInput[]
    by: User_rolesScalarFieldEnum[] | User_rolesScalarFieldEnum
    having?: user_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_rolesCountAggregateInputType | true
    _avg?: User_rolesAvgAggregateInputType
    _sum?: User_rolesSumAggregateInputType
    _min?: User_rolesMinAggregateInputType
    _max?: User_rolesMaxAggregateInputType
  }

  export type User_rolesGroupByOutputType = {
    user_id: number
    role_id: number
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  type GetUser_rolesGroupByPayload<T extends user_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
        }
      >
    >


  export type user_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>



  export type user_rolesSelectScalar = {
    user_id?: boolean
    role_id?: boolean
  }

  export type user_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "role_id", ExtArgs["result"]["user_roles"]>
  export type user_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $user_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_roles"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      role_id: number
    }, ExtArgs["result"]["user_roles"]>
    composites: {}
  }

  type user_rolesGetPayload<S extends boolean | null | undefined | user_rolesDefaultArgs> = $Result.GetResult<Prisma.$user_rolesPayload, S>

  type user_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_rolesCountAggregateInputType | true
    }

  export interface user_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_roles'], meta: { name: 'user_roles' } }
    /**
     * Find zero or one User_roles that matches the filter.
     * @param {user_rolesFindUniqueArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_rolesFindUniqueArgs>(args: SelectSubset<T, user_rolesFindUniqueArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_rolesFindUniqueOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_rolesFindFirstArgs>(args?: SelectSubset<T, user_rolesFindFirstArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_roles.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_roles.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_rolesWithUser_idOnly = await prisma.user_roles.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_rolesFindManyArgs>(args?: SelectSubset<T, user_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_roles.
     * @param {user_rolesCreateArgs} args - Arguments to create a User_roles.
     * @example
     * // Create one User_roles
     * const User_roles = await prisma.user_roles.create({
     *   data: {
     *     // ... data to create a User_roles
     *   }
     * })
     * 
     */
    create<T extends user_rolesCreateArgs>(args: SelectSubset<T, user_rolesCreateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_roles.
     * @param {user_rolesCreateManyArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_rolesCreateManyArgs>(args?: SelectSubset<T, user_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_roles.
     * @param {user_rolesDeleteArgs} args - Arguments to delete one User_roles.
     * @example
     * // Delete one User_roles
     * const User_roles = await prisma.user_roles.delete({
     *   where: {
     *     // ... filter to delete one User_roles
     *   }
     * })
     * 
     */
    delete<T extends user_rolesDeleteArgs>(args: SelectSubset<T, user_rolesDeleteArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_roles.
     * @param {user_rolesUpdateArgs} args - Arguments to update one User_roles.
     * @example
     * // Update one User_roles
     * const user_roles = await prisma.user_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_rolesUpdateArgs>(args: SelectSubset<T, user_rolesUpdateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_roles.
     * @param {user_rolesDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_rolesDeleteManyArgs>(args?: SelectSubset<T, user_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_rolesUpdateManyArgs>(args: SelectSubset<T, user_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_roles.
     * @param {user_rolesUpsertArgs} args - Arguments to update or create a User_roles.
     * @example
     * // Update or create a User_roles
     * const user_roles = await prisma.user_roles.upsert({
     *   create: {
     *     // ... data to create a User_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_roles we want to update
     *   }
     * })
     */
    upsert<T extends user_rolesUpsertArgs>(args: SelectSubset<T, user_rolesUpsertArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_roles.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_rolesCountArgs>(
      args?: Subset<T, user_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_rolesAggregateArgs>(args: Subset<T, User_rolesAggregateArgs>): Prisma.PrismaPromise<GetUser_rolesAggregateType<T>>

    /**
     * Group by User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_rolesGroupByArgs['orderBy'] }
        : { orderBy?: user_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_roles model
   */
  readonly fields: user_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_roles model
   */
  interface user_rolesFieldRefs {
    readonly user_id: FieldRef<"user_roles", 'Int'>
    readonly role_id: FieldRef<"user_roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * user_roles findUnique
   */
  export type user_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findUniqueOrThrow
   */
  export type user_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findFirst
   */
  export type user_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findFirstOrThrow
   */
  export type user_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findMany
   */
  export type user_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles create
   */
  export type user_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_roles.
     */
    data: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
  }

  /**
   * user_roles createMany
   */
  export type user_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_roles update
   */
  export type user_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_roles.
     */
    data: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
    /**
     * Choose, which user_roles to update.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles updateMany
   */
  export type user_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
  }

  /**
   * user_roles upsert
   */
  export type user_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_roles to update in case it exists.
     */
    where: user_rolesWhereUniqueInput
    /**
     * In case the user_roles found by the `where` argument doesn't exist, create a new user_roles with this data.
     */
    create: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
    /**
     * In case the user_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
  }

  /**
   * user_roles delete
   */
  export type user_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter which user_roles to delete.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles deleteMany
   */
  export type user_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to delete
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to delete.
     */
    limit?: number
  }

  /**
   * user_roles without action
   */
  export type user_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    account_name: string | null
    password_hash: string | null
    project: string | null
    is_super_admin: boolean | null
    created_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    account_name: string | null
    password_hash: string | null
    project: string | null
    is_super_admin: boolean | null
    created_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    username: number
    account_name: number
    password_hash: number
    project: number
    is_super_admin: number
    created_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    account_name?: true
    password_hash?: true
    project?: true
    is_super_admin?: true
    created_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    account_name?: true
    password_hash?: true
    project?: true
    is_super_admin?: true
    created_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    account_name?: true
    password_hash?: true
    project?: true
    is_super_admin?: true
    created_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    email: string
    username: string
    account_name: string | null
    password_hash: string
    project: string | null
    is_super_admin: boolean
    created_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    account_name?: boolean
    password_hash?: boolean
    project?: boolean
    is_super_admin?: boolean
    created_at?: boolean
    ai_generation_sessions?: boolean | users$ai_generation_sessionsArgs<ExtArgs>
    api_tokens?: boolean | users$api_tokensArgs<ExtArgs>
    audit_logs?: boolean | users$audit_logsArgs<ExtArgs>
    bulk_edit_sessions?: boolean | users$bulk_edit_sessionsArgs<ExtArgs>
    case_versions?: boolean | users$case_versionsArgs<ExtArgs>
    functional_test_cases?: boolean | users$functional_test_casesArgs<ExtArgs>
    requirement_documents?: boolean | users$requirement_documentsArgs<ExtArgs>
    test_case_executions?: boolean | users$test_case_executionsArgs<ExtArgs>
    test_runs?: boolean | users$test_runsArgs<ExtArgs>
    test_suites?: boolean | users$test_suitesArgs<ExtArgs>
    user_roles?: boolean | users$user_rolesArgs<ExtArgs>
    functional_test_executions?: boolean | users$functional_test_executionsArgs<ExtArgs>
    test_plans?: boolean | users$test_plansArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    account_name?: boolean
    password_hash?: boolean
    project?: boolean
    is_super_admin?: boolean
    created_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "account_name" | "password_hash" | "project" | "is_super_admin" | "created_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_generation_sessions?: boolean | users$ai_generation_sessionsArgs<ExtArgs>
    api_tokens?: boolean | users$api_tokensArgs<ExtArgs>
    audit_logs?: boolean | users$audit_logsArgs<ExtArgs>
    bulk_edit_sessions?: boolean | users$bulk_edit_sessionsArgs<ExtArgs>
    case_versions?: boolean | users$case_versionsArgs<ExtArgs>
    functional_test_cases?: boolean | users$functional_test_casesArgs<ExtArgs>
    requirement_documents?: boolean | users$requirement_documentsArgs<ExtArgs>
    test_case_executions?: boolean | users$test_case_executionsArgs<ExtArgs>
    test_runs?: boolean | users$test_runsArgs<ExtArgs>
    test_suites?: boolean | users$test_suitesArgs<ExtArgs>
    user_roles?: boolean | users$user_rolesArgs<ExtArgs>
    functional_test_executions?: boolean | users$functional_test_executionsArgs<ExtArgs>
    test_plans?: boolean | users$test_plansArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      ai_generation_sessions: Prisma.$ai_generation_sessionsPayload<ExtArgs>[]
      api_tokens: Prisma.$api_tokensPayload<ExtArgs>[]
      audit_logs: Prisma.$audit_logsPayload<ExtArgs>[]
      bulk_edit_sessions: Prisma.$bulk_edit_sessionsPayload<ExtArgs>[]
      case_versions: Prisma.$case_versionsPayload<ExtArgs>[]
      functional_test_cases: Prisma.$functional_test_casesPayload<ExtArgs>[]
      requirement_documents: Prisma.$requirement_documentsPayload<ExtArgs>[]
      test_case_executions: Prisma.$test_case_executionsPayload<ExtArgs>[]
      test_runs: Prisma.$test_runsPayload<ExtArgs>[]
      test_suites: Prisma.$test_suitesPayload<ExtArgs>[]
      user_roles: Prisma.$user_rolesPayload<ExtArgs>[]
      functional_test_executions: Prisma.$functional_test_executionsPayload<ExtArgs>[]
      test_plans: Prisma.$test_plansPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      username: string
      account_name: string | null
      password_hash: string
      project: string | null
      is_super_admin: boolean
      created_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ai_generation_sessions<T extends users$ai_generation_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_generation_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    api_tokens<T extends users$api_tokensArgs<ExtArgs> = {}>(args?: Subset<T, users$api_tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audit_logs<T extends users$audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bulk_edit_sessions<T extends users$bulk_edit_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$bulk_edit_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    case_versions<T extends users$case_versionsArgs<ExtArgs> = {}>(args?: Subset<T, users$case_versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    functional_test_cases<T extends users$functional_test_casesArgs<ExtArgs> = {}>(args?: Subset<T, users$functional_test_casesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requirement_documents<T extends users$requirement_documentsArgs<ExtArgs> = {}>(args?: Subset<T, users$requirement_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_case_executions<T extends users$test_case_executionsArgs<ExtArgs> = {}>(args?: Subset<T, users$test_case_executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_runs<T extends users$test_runsArgs<ExtArgs> = {}>(args?: Subset<T, users$test_runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_runsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_suites<T extends users$test_suitesArgs<ExtArgs> = {}>(args?: Subset<T, users$test_suitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_suitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_roles<T extends users$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, users$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    functional_test_executions<T extends users$functional_test_executionsArgs<ExtArgs> = {}>(args?: Subset<T, users$functional_test_executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    test_plans<T extends users$test_plansArgs<ExtArgs> = {}>(args?: Subset<T, users$test_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly email: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly account_name: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly project: FieldRef<"users", 'String'>
    readonly is_super_admin: FieldRef<"users", 'Boolean'>
    readonly created_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.ai_generation_sessions
   */
  export type users$ai_generation_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    where?: ai_generation_sessionsWhereInput
    orderBy?: ai_generation_sessionsOrderByWithRelationInput | ai_generation_sessionsOrderByWithRelationInput[]
    cursor?: ai_generation_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_generation_sessionsScalarFieldEnum | Ai_generation_sessionsScalarFieldEnum[]
  }

  /**
   * users.api_tokens
   */
  export type users$api_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_tokens
     */
    select?: api_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_tokens
     */
    omit?: api_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_tokensInclude<ExtArgs> | null
    where?: api_tokensWhereInput
    orderBy?: api_tokensOrderByWithRelationInput | api_tokensOrderByWithRelationInput[]
    cursor?: api_tokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Api_tokensScalarFieldEnum | Api_tokensScalarFieldEnum[]
  }

  /**
   * users.audit_logs
   */
  export type users$audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    cursor?: audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * users.bulk_edit_sessions
   */
  export type users$bulk_edit_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    where?: bulk_edit_sessionsWhereInput
    orderBy?: bulk_edit_sessionsOrderByWithRelationInput | bulk_edit_sessionsOrderByWithRelationInput[]
    cursor?: bulk_edit_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bulk_edit_sessionsScalarFieldEnum | Bulk_edit_sessionsScalarFieldEnum[]
  }

  /**
   * users.case_versions
   */
  export type users$case_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    where?: case_versionsWhereInput
    orderBy?: case_versionsOrderByWithRelationInput | case_versionsOrderByWithRelationInput[]
    cursor?: case_versionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Case_versionsScalarFieldEnum | Case_versionsScalarFieldEnum[]
  }

  /**
   * users.functional_test_cases
   */
  export type users$functional_test_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    where?: functional_test_casesWhereInput
    orderBy?: functional_test_casesOrderByWithRelationInput | functional_test_casesOrderByWithRelationInput[]
    cursor?: functional_test_casesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Functional_test_casesScalarFieldEnum | Functional_test_casesScalarFieldEnum[]
  }

  /**
   * users.requirement_documents
   */
  export type users$requirement_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    where?: requirement_documentsWhereInput
    orderBy?: requirement_documentsOrderByWithRelationInput | requirement_documentsOrderByWithRelationInput[]
    cursor?: requirement_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Requirement_documentsScalarFieldEnum | Requirement_documentsScalarFieldEnum[]
  }

  /**
   * users.test_case_executions
   */
  export type users$test_case_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    where?: test_case_executionsWhereInput
    orderBy?: test_case_executionsOrderByWithRelationInput | test_case_executionsOrderByWithRelationInput[]
    cursor?: test_case_executionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_case_executionsScalarFieldEnum | Test_case_executionsScalarFieldEnum[]
  }

  /**
   * users.test_runs
   */
  export type users$test_runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_runs
     */
    select?: test_runsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_runs
     */
    omit?: test_runsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_runsInclude<ExtArgs> | null
    where?: test_runsWhereInput
    orderBy?: test_runsOrderByWithRelationInput | test_runsOrderByWithRelationInput[]
    cursor?: test_runsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_runsScalarFieldEnum | Test_runsScalarFieldEnum[]
  }

  /**
   * users.test_suites
   */
  export type users$test_suitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_suites
     */
    select?: test_suitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_suites
     */
    omit?: test_suitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_suitesInclude<ExtArgs> | null
    where?: test_suitesWhereInput
    orderBy?: test_suitesOrderByWithRelationInput | test_suitesOrderByWithRelationInput[]
    cursor?: test_suitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_suitesScalarFieldEnum | Test_suitesScalarFieldEnum[]
  }

  /**
   * users.user_roles
   */
  export type users$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * users.functional_test_executions
   */
  export type users$functional_test_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    where?: functional_test_executionsWhereInput
    orderBy?: functional_test_executionsOrderByWithRelationInput | functional_test_executionsOrderByWithRelationInput[]
    cursor?: functional_test_executionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Functional_test_executionsScalarFieldEnum | Functional_test_executionsScalarFieldEnum[]
  }

  /**
   * users.test_plans
   */
  export type users$test_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    where?: test_plansWhereInput
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    cursor?: test_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model run_artifacts
   */

  export type AggregateRun_artifacts = {
    _count: Run_artifactsCountAggregateOutputType | null
    _avg: Run_artifactsAvgAggregateOutputType | null
    _sum: Run_artifactsSumAggregateOutputType | null
    _min: Run_artifactsMinAggregateOutputType | null
    _max: Run_artifactsMaxAggregateOutputType | null
  }

  export type Run_artifactsAvgAggregateOutputType = {
    id: number | null
    size: number | null
  }

  export type Run_artifactsSumAggregateOutputType = {
    id: number | null
    size: bigint | null
  }

  export type Run_artifactsMinAggregateOutputType = {
    id: number | null
    runId: string | null
    type: string | null
    filename: string | null
    size: bigint | null
    createdAt: Date | null
  }

  export type Run_artifactsMaxAggregateOutputType = {
    id: number | null
    runId: string | null
    type: string | null
    filename: string | null
    size: bigint | null
    createdAt: Date | null
  }

  export type Run_artifactsCountAggregateOutputType = {
    id: number
    runId: number
    type: number
    filename: number
    size: number
    createdAt: number
    _all: number
  }


  export type Run_artifactsAvgAggregateInputType = {
    id?: true
    size?: true
  }

  export type Run_artifactsSumAggregateInputType = {
    id?: true
    size?: true
  }

  export type Run_artifactsMinAggregateInputType = {
    id?: true
    runId?: true
    type?: true
    filename?: true
    size?: true
    createdAt?: true
  }

  export type Run_artifactsMaxAggregateInputType = {
    id?: true
    runId?: true
    type?: true
    filename?: true
    size?: true
    createdAt?: true
  }

  export type Run_artifactsCountAggregateInputType = {
    id?: true
    runId?: true
    type?: true
    filename?: true
    size?: true
    createdAt?: true
    _all?: true
  }

  export type Run_artifactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which run_artifacts to aggregate.
     */
    where?: run_artifactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of run_artifacts to fetch.
     */
    orderBy?: run_artifactsOrderByWithRelationInput | run_artifactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: run_artifactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` run_artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` run_artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned run_artifacts
    **/
    _count?: true | Run_artifactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Run_artifactsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Run_artifactsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Run_artifactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Run_artifactsMaxAggregateInputType
  }

  export type GetRun_artifactsAggregateType<T extends Run_artifactsAggregateArgs> = {
        [P in keyof T & keyof AggregateRun_artifacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRun_artifacts[P]>
      : GetScalarType<T[P], AggregateRun_artifacts[P]>
  }




  export type run_artifactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: run_artifactsWhereInput
    orderBy?: run_artifactsOrderByWithAggregationInput | run_artifactsOrderByWithAggregationInput[]
    by: Run_artifactsScalarFieldEnum[] | Run_artifactsScalarFieldEnum
    having?: run_artifactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Run_artifactsCountAggregateInputType | true
    _avg?: Run_artifactsAvgAggregateInputType
    _sum?: Run_artifactsSumAggregateInputType
    _min?: Run_artifactsMinAggregateInputType
    _max?: Run_artifactsMaxAggregateInputType
  }

  export type Run_artifactsGroupByOutputType = {
    id: number
    runId: string
    type: string
    filename: string
    size: bigint
    createdAt: Date
    _count: Run_artifactsCountAggregateOutputType | null
    _avg: Run_artifactsAvgAggregateOutputType | null
    _sum: Run_artifactsSumAggregateOutputType | null
    _min: Run_artifactsMinAggregateOutputType | null
    _max: Run_artifactsMaxAggregateOutputType | null
  }

  type GetRun_artifactsGroupByPayload<T extends run_artifactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Run_artifactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Run_artifactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Run_artifactsGroupByOutputType[P]>
            : GetScalarType<T[P], Run_artifactsGroupByOutputType[P]>
        }
      >
    >


  export type run_artifactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    type?: boolean
    filename?: boolean
    size?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["run_artifacts"]>



  export type run_artifactsSelectScalar = {
    id?: boolean
    runId?: boolean
    type?: boolean
    filename?: boolean
    size?: boolean
    createdAt?: boolean
  }

  export type run_artifactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runId" | "type" | "filename" | "size" | "createdAt", ExtArgs["result"]["run_artifacts"]>

  export type $run_artifactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "run_artifacts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      runId: string
      type: string
      filename: string
      size: bigint
      createdAt: Date
    }, ExtArgs["result"]["run_artifacts"]>
    composites: {}
  }

  type run_artifactsGetPayload<S extends boolean | null | undefined | run_artifactsDefaultArgs> = $Result.GetResult<Prisma.$run_artifactsPayload, S>

  type run_artifactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<run_artifactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Run_artifactsCountAggregateInputType | true
    }

  export interface run_artifactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['run_artifacts'], meta: { name: 'run_artifacts' } }
    /**
     * Find zero or one Run_artifacts that matches the filter.
     * @param {run_artifactsFindUniqueArgs} args - Arguments to find a Run_artifacts
     * @example
     * // Get one Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends run_artifactsFindUniqueArgs>(args: SelectSubset<T, run_artifactsFindUniqueArgs<ExtArgs>>): Prisma__run_artifactsClient<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Run_artifacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {run_artifactsFindUniqueOrThrowArgs} args - Arguments to find a Run_artifacts
     * @example
     * // Get one Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends run_artifactsFindUniqueOrThrowArgs>(args: SelectSubset<T, run_artifactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__run_artifactsClient<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Run_artifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {run_artifactsFindFirstArgs} args - Arguments to find a Run_artifacts
     * @example
     * // Get one Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends run_artifactsFindFirstArgs>(args?: SelectSubset<T, run_artifactsFindFirstArgs<ExtArgs>>): Prisma__run_artifactsClient<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Run_artifacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {run_artifactsFindFirstOrThrowArgs} args - Arguments to find a Run_artifacts
     * @example
     * // Get one Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends run_artifactsFindFirstOrThrowArgs>(args?: SelectSubset<T, run_artifactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__run_artifactsClient<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Run_artifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {run_artifactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.findMany()
     * 
     * // Get first 10 Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const run_artifactsWithIdOnly = await prisma.run_artifacts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends run_artifactsFindManyArgs>(args?: SelectSubset<T, run_artifactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Run_artifacts.
     * @param {run_artifactsCreateArgs} args - Arguments to create a Run_artifacts.
     * @example
     * // Create one Run_artifacts
     * const Run_artifacts = await prisma.run_artifacts.create({
     *   data: {
     *     // ... data to create a Run_artifacts
     *   }
     * })
     * 
     */
    create<T extends run_artifactsCreateArgs>(args: SelectSubset<T, run_artifactsCreateArgs<ExtArgs>>): Prisma__run_artifactsClient<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Run_artifacts.
     * @param {run_artifactsCreateManyArgs} args - Arguments to create many Run_artifacts.
     * @example
     * // Create many Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends run_artifactsCreateManyArgs>(args?: SelectSubset<T, run_artifactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Run_artifacts.
     * @param {run_artifactsDeleteArgs} args - Arguments to delete one Run_artifacts.
     * @example
     * // Delete one Run_artifacts
     * const Run_artifacts = await prisma.run_artifacts.delete({
     *   where: {
     *     // ... filter to delete one Run_artifacts
     *   }
     * })
     * 
     */
    delete<T extends run_artifactsDeleteArgs>(args: SelectSubset<T, run_artifactsDeleteArgs<ExtArgs>>): Prisma__run_artifactsClient<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Run_artifacts.
     * @param {run_artifactsUpdateArgs} args - Arguments to update one Run_artifacts.
     * @example
     * // Update one Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends run_artifactsUpdateArgs>(args: SelectSubset<T, run_artifactsUpdateArgs<ExtArgs>>): Prisma__run_artifactsClient<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Run_artifacts.
     * @param {run_artifactsDeleteManyArgs} args - Arguments to filter Run_artifacts to delete.
     * @example
     * // Delete a few Run_artifacts
     * const { count } = await prisma.run_artifacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends run_artifactsDeleteManyArgs>(args?: SelectSubset<T, run_artifactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Run_artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {run_artifactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends run_artifactsUpdateManyArgs>(args: SelectSubset<T, run_artifactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Run_artifacts.
     * @param {run_artifactsUpsertArgs} args - Arguments to update or create a Run_artifacts.
     * @example
     * // Update or create a Run_artifacts
     * const run_artifacts = await prisma.run_artifacts.upsert({
     *   create: {
     *     // ... data to create a Run_artifacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Run_artifacts we want to update
     *   }
     * })
     */
    upsert<T extends run_artifactsUpsertArgs>(args: SelectSubset<T, run_artifactsUpsertArgs<ExtArgs>>): Prisma__run_artifactsClient<$Result.GetResult<Prisma.$run_artifactsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Run_artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {run_artifactsCountArgs} args - Arguments to filter Run_artifacts to count.
     * @example
     * // Count the number of Run_artifacts
     * const count = await prisma.run_artifacts.count({
     *   where: {
     *     // ... the filter for the Run_artifacts we want to count
     *   }
     * })
    **/
    count<T extends run_artifactsCountArgs>(
      args?: Subset<T, run_artifactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Run_artifactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Run_artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Run_artifactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Run_artifactsAggregateArgs>(args: Subset<T, Run_artifactsAggregateArgs>): Prisma.PrismaPromise<GetRun_artifactsAggregateType<T>>

    /**
     * Group by Run_artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {run_artifactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends run_artifactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: run_artifactsGroupByArgs['orderBy'] }
        : { orderBy?: run_artifactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, run_artifactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRun_artifactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the run_artifacts model
   */
  readonly fields: run_artifactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for run_artifacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__run_artifactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the run_artifacts model
   */
  interface run_artifactsFieldRefs {
    readonly id: FieldRef<"run_artifacts", 'Int'>
    readonly runId: FieldRef<"run_artifacts", 'String'>
    readonly type: FieldRef<"run_artifacts", 'String'>
    readonly filename: FieldRef<"run_artifacts", 'String'>
    readonly size: FieldRef<"run_artifacts", 'BigInt'>
    readonly createdAt: FieldRef<"run_artifacts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * run_artifacts findUnique
   */
  export type run_artifactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * Filter, which run_artifacts to fetch.
     */
    where: run_artifactsWhereUniqueInput
  }

  /**
   * run_artifacts findUniqueOrThrow
   */
  export type run_artifactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * Filter, which run_artifacts to fetch.
     */
    where: run_artifactsWhereUniqueInput
  }

  /**
   * run_artifacts findFirst
   */
  export type run_artifactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * Filter, which run_artifacts to fetch.
     */
    where?: run_artifactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of run_artifacts to fetch.
     */
    orderBy?: run_artifactsOrderByWithRelationInput | run_artifactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for run_artifacts.
     */
    cursor?: run_artifactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` run_artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` run_artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of run_artifacts.
     */
    distinct?: Run_artifactsScalarFieldEnum | Run_artifactsScalarFieldEnum[]
  }

  /**
   * run_artifacts findFirstOrThrow
   */
  export type run_artifactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * Filter, which run_artifacts to fetch.
     */
    where?: run_artifactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of run_artifacts to fetch.
     */
    orderBy?: run_artifactsOrderByWithRelationInput | run_artifactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for run_artifacts.
     */
    cursor?: run_artifactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` run_artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` run_artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of run_artifacts.
     */
    distinct?: Run_artifactsScalarFieldEnum | Run_artifactsScalarFieldEnum[]
  }

  /**
   * run_artifacts findMany
   */
  export type run_artifactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * Filter, which run_artifacts to fetch.
     */
    where?: run_artifactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of run_artifacts to fetch.
     */
    orderBy?: run_artifactsOrderByWithRelationInput | run_artifactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing run_artifacts.
     */
    cursor?: run_artifactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` run_artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` run_artifacts.
     */
    skip?: number
    distinct?: Run_artifactsScalarFieldEnum | Run_artifactsScalarFieldEnum[]
  }

  /**
   * run_artifacts create
   */
  export type run_artifactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * The data needed to create a run_artifacts.
     */
    data: XOR<run_artifactsCreateInput, run_artifactsUncheckedCreateInput>
  }

  /**
   * run_artifacts createMany
   */
  export type run_artifactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many run_artifacts.
     */
    data: run_artifactsCreateManyInput | run_artifactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * run_artifacts update
   */
  export type run_artifactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * The data needed to update a run_artifacts.
     */
    data: XOR<run_artifactsUpdateInput, run_artifactsUncheckedUpdateInput>
    /**
     * Choose, which run_artifacts to update.
     */
    where: run_artifactsWhereUniqueInput
  }

  /**
   * run_artifacts updateMany
   */
  export type run_artifactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update run_artifacts.
     */
    data: XOR<run_artifactsUpdateManyMutationInput, run_artifactsUncheckedUpdateManyInput>
    /**
     * Filter which run_artifacts to update
     */
    where?: run_artifactsWhereInput
    /**
     * Limit how many run_artifacts to update.
     */
    limit?: number
  }

  /**
   * run_artifacts upsert
   */
  export type run_artifactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * The filter to search for the run_artifacts to update in case it exists.
     */
    where: run_artifactsWhereUniqueInput
    /**
     * In case the run_artifacts found by the `where` argument doesn't exist, create a new run_artifacts with this data.
     */
    create: XOR<run_artifactsCreateInput, run_artifactsUncheckedCreateInput>
    /**
     * In case the run_artifacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<run_artifactsUpdateInput, run_artifactsUncheckedUpdateInput>
  }

  /**
   * run_artifacts delete
   */
  export type run_artifactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
    /**
     * Filter which run_artifacts to delete.
     */
    where: run_artifactsWhereUniqueInput
  }

  /**
   * run_artifacts deleteMany
   */
  export type run_artifactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which run_artifacts to delete
     */
    where?: run_artifactsWhereInput
    /**
     * Limit how many run_artifacts to delete.
     */
    limit?: number
  }

  /**
   * run_artifacts without action
   */
  export type run_artifactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the run_artifacts
     */
    select?: run_artifactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the run_artifacts
     */
    omit?: run_artifactsOmit<ExtArgs> | null
  }


  /**
   * Model case_versions
   */

  export type AggregateCase_versions = {
    _count: Case_versionsCountAggregateOutputType | null
    _avg: Case_versionsAvgAggregateOutputType | null
    _sum: Case_versionsSumAggregateOutputType | null
    _min: Case_versionsMinAggregateOutputType | null
    _max: Case_versionsMaxAggregateOutputType | null
  }

  export type Case_versionsAvgAggregateOutputType = {
    id: number | null
    case_id: number | null
    version: number | null
    created_by: number | null
  }

  export type Case_versionsSumAggregateOutputType = {
    id: number | null
    case_id: number | null
    version: number | null
    created_by: number | null
  }

  export type Case_versionsMinAggregateOutputType = {
    id: number | null
    case_id: number | null
    version: number | null
    system: string | null
    module: string | null
    created_by: number | null
    created_at: Date | null
  }

  export type Case_versionsMaxAggregateOutputType = {
    id: number | null
    case_id: number | null
    version: number | null
    system: string | null
    module: string | null
    created_by: number | null
    created_at: Date | null
  }

  export type Case_versionsCountAggregateOutputType = {
    id: number
    case_id: number
    version: number
    steps: number
    tags: number
    system: number
    module: number
    meta: number
    created_by: number
    created_at: number
    _all: number
  }


  export type Case_versionsAvgAggregateInputType = {
    id?: true
    case_id?: true
    version?: true
    created_by?: true
  }

  export type Case_versionsSumAggregateInputType = {
    id?: true
    case_id?: true
    version?: true
    created_by?: true
  }

  export type Case_versionsMinAggregateInputType = {
    id?: true
    case_id?: true
    version?: true
    system?: true
    module?: true
    created_by?: true
    created_at?: true
  }

  export type Case_versionsMaxAggregateInputType = {
    id?: true
    case_id?: true
    version?: true
    system?: true
    module?: true
    created_by?: true
    created_at?: true
  }

  export type Case_versionsCountAggregateInputType = {
    id?: true
    case_id?: true
    version?: true
    steps?: true
    tags?: true
    system?: true
    module?: true
    meta?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type Case_versionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which case_versions to aggregate.
     */
    where?: case_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_versions to fetch.
     */
    orderBy?: case_versionsOrderByWithRelationInput | case_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: case_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned case_versions
    **/
    _count?: true | Case_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Case_versionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Case_versionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Case_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Case_versionsMaxAggregateInputType
  }

  export type GetCase_versionsAggregateType<T extends Case_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCase_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCase_versions[P]>
      : GetScalarType<T[P], AggregateCase_versions[P]>
  }




  export type case_versionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_versionsWhereInput
    orderBy?: case_versionsOrderByWithAggregationInput | case_versionsOrderByWithAggregationInput[]
    by: Case_versionsScalarFieldEnum[] | Case_versionsScalarFieldEnum
    having?: case_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Case_versionsCountAggregateInputType | true
    _avg?: Case_versionsAvgAggregateInputType
    _sum?: Case_versionsSumAggregateInputType
    _min?: Case_versionsMinAggregateInputType
    _max?: Case_versionsMaxAggregateInputType
  }

  export type Case_versionsGroupByOutputType = {
    id: number
    case_id: number
    version: number
    steps: JsonValue | null
    tags: JsonValue | null
    system: string | null
    module: string | null
    meta: JsonValue | null
    created_by: number | null
    created_at: Date | null
    _count: Case_versionsCountAggregateOutputType | null
    _avg: Case_versionsAvgAggregateOutputType | null
    _sum: Case_versionsSumAggregateOutputType | null
    _min: Case_versionsMinAggregateOutputType | null
    _max: Case_versionsMaxAggregateOutputType | null
  }

  type GetCase_versionsGroupByPayload<T extends case_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Case_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Case_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Case_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], Case_versionsGroupByOutputType[P]>
        }
      >
    >


  export type case_versionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    case_id?: boolean
    version?: boolean
    steps?: boolean
    tags?: boolean
    system?: boolean
    module?: boolean
    meta?: boolean
    created_by?: boolean
    created_at?: boolean
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
    users?: boolean | case_versions$usersArgs<ExtArgs>
  }, ExtArgs["result"]["case_versions"]>



  export type case_versionsSelectScalar = {
    id?: boolean
    case_id?: boolean
    version?: boolean
    steps?: boolean
    tags?: boolean
    system?: boolean
    module?: boolean
    meta?: boolean
    created_by?: boolean
    created_at?: boolean
  }

  export type case_versionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "case_id" | "version" | "steps" | "tags" | "system" | "module" | "meta" | "created_by" | "created_at", ExtArgs["result"]["case_versions"]>
  export type case_versionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
    users?: boolean | case_versions$usersArgs<ExtArgs>
  }

  export type $case_versionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "case_versions"
    objects: {
      test_cases: Prisma.$test_casesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      case_id: number
      version: number
      steps: Prisma.JsonValue | null
      tags: Prisma.JsonValue | null
      system: string | null
      module: string | null
      meta: Prisma.JsonValue | null
      created_by: number | null
      created_at: Date | null
    }, ExtArgs["result"]["case_versions"]>
    composites: {}
  }

  type case_versionsGetPayload<S extends boolean | null | undefined | case_versionsDefaultArgs> = $Result.GetResult<Prisma.$case_versionsPayload, S>

  type case_versionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<case_versionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Case_versionsCountAggregateInputType | true
    }

  export interface case_versionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['case_versions'], meta: { name: 'case_versions' } }
    /**
     * Find zero or one Case_versions that matches the filter.
     * @param {case_versionsFindUniqueArgs} args - Arguments to find a Case_versions
     * @example
     * // Get one Case_versions
     * const case_versions = await prisma.case_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends case_versionsFindUniqueArgs>(args: SelectSubset<T, case_versionsFindUniqueArgs<ExtArgs>>): Prisma__case_versionsClient<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Case_versions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {case_versionsFindUniqueOrThrowArgs} args - Arguments to find a Case_versions
     * @example
     * // Get one Case_versions
     * const case_versions = await prisma.case_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends case_versionsFindUniqueOrThrowArgs>(args: SelectSubset<T, case_versionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__case_versionsClient<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_versionsFindFirstArgs} args - Arguments to find a Case_versions
     * @example
     * // Get one Case_versions
     * const case_versions = await prisma.case_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends case_versionsFindFirstArgs>(args?: SelectSubset<T, case_versionsFindFirstArgs<ExtArgs>>): Prisma__case_versionsClient<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case_versions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_versionsFindFirstOrThrowArgs} args - Arguments to find a Case_versions
     * @example
     * // Get one Case_versions
     * const case_versions = await prisma.case_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends case_versionsFindFirstOrThrowArgs>(args?: SelectSubset<T, case_versionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__case_versionsClient<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Case_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_versionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Case_versions
     * const case_versions = await prisma.case_versions.findMany()
     * 
     * // Get first 10 Case_versions
     * const case_versions = await prisma.case_versions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const case_versionsWithIdOnly = await prisma.case_versions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends case_versionsFindManyArgs>(args?: SelectSubset<T, case_versionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Case_versions.
     * @param {case_versionsCreateArgs} args - Arguments to create a Case_versions.
     * @example
     * // Create one Case_versions
     * const Case_versions = await prisma.case_versions.create({
     *   data: {
     *     // ... data to create a Case_versions
     *   }
     * })
     * 
     */
    create<T extends case_versionsCreateArgs>(args: SelectSubset<T, case_versionsCreateArgs<ExtArgs>>): Prisma__case_versionsClient<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Case_versions.
     * @param {case_versionsCreateManyArgs} args - Arguments to create many Case_versions.
     * @example
     * // Create many Case_versions
     * const case_versions = await prisma.case_versions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends case_versionsCreateManyArgs>(args?: SelectSubset<T, case_versionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Case_versions.
     * @param {case_versionsDeleteArgs} args - Arguments to delete one Case_versions.
     * @example
     * // Delete one Case_versions
     * const Case_versions = await prisma.case_versions.delete({
     *   where: {
     *     // ... filter to delete one Case_versions
     *   }
     * })
     * 
     */
    delete<T extends case_versionsDeleteArgs>(args: SelectSubset<T, case_versionsDeleteArgs<ExtArgs>>): Prisma__case_versionsClient<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Case_versions.
     * @param {case_versionsUpdateArgs} args - Arguments to update one Case_versions.
     * @example
     * // Update one Case_versions
     * const case_versions = await prisma.case_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends case_versionsUpdateArgs>(args: SelectSubset<T, case_versionsUpdateArgs<ExtArgs>>): Prisma__case_versionsClient<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Case_versions.
     * @param {case_versionsDeleteManyArgs} args - Arguments to filter Case_versions to delete.
     * @example
     * // Delete a few Case_versions
     * const { count } = await prisma.case_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends case_versionsDeleteManyArgs>(args?: SelectSubset<T, case_versionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Case_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Case_versions
     * const case_versions = await prisma.case_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends case_versionsUpdateManyArgs>(args: SelectSubset<T, case_versionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Case_versions.
     * @param {case_versionsUpsertArgs} args - Arguments to update or create a Case_versions.
     * @example
     * // Update or create a Case_versions
     * const case_versions = await prisma.case_versions.upsert({
     *   create: {
     *     // ... data to create a Case_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Case_versions we want to update
     *   }
     * })
     */
    upsert<T extends case_versionsUpsertArgs>(args: SelectSubset<T, case_versionsUpsertArgs<ExtArgs>>): Prisma__case_versionsClient<$Result.GetResult<Prisma.$case_versionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Case_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_versionsCountArgs} args - Arguments to filter Case_versions to count.
     * @example
     * // Count the number of Case_versions
     * const count = await prisma.case_versions.count({
     *   where: {
     *     // ... the filter for the Case_versions we want to count
     *   }
     * })
    **/
    count<T extends case_versionsCountArgs>(
      args?: Subset<T, case_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Case_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Case_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Case_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Case_versionsAggregateArgs>(args: Subset<T, Case_versionsAggregateArgs>): Prisma.PrismaPromise<GetCase_versionsAggregateType<T>>

    /**
     * Group by Case_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends case_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: case_versionsGroupByArgs['orderBy'] }
        : { orderBy?: case_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, case_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCase_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the case_versions model
   */
  readonly fields: case_versionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for case_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__case_versionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_cases<T extends test_casesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_casesDefaultArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends case_versions$usersArgs<ExtArgs> = {}>(args?: Subset<T, case_versions$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the case_versions model
   */
  interface case_versionsFieldRefs {
    readonly id: FieldRef<"case_versions", 'Int'>
    readonly case_id: FieldRef<"case_versions", 'Int'>
    readonly version: FieldRef<"case_versions", 'Int'>
    readonly steps: FieldRef<"case_versions", 'Json'>
    readonly tags: FieldRef<"case_versions", 'Json'>
    readonly system: FieldRef<"case_versions", 'String'>
    readonly module: FieldRef<"case_versions", 'String'>
    readonly meta: FieldRef<"case_versions", 'Json'>
    readonly created_by: FieldRef<"case_versions", 'Int'>
    readonly created_at: FieldRef<"case_versions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * case_versions findUnique
   */
  export type case_versionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * Filter, which case_versions to fetch.
     */
    where: case_versionsWhereUniqueInput
  }

  /**
   * case_versions findUniqueOrThrow
   */
  export type case_versionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * Filter, which case_versions to fetch.
     */
    where: case_versionsWhereUniqueInput
  }

  /**
   * case_versions findFirst
   */
  export type case_versionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * Filter, which case_versions to fetch.
     */
    where?: case_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_versions to fetch.
     */
    orderBy?: case_versionsOrderByWithRelationInput | case_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for case_versions.
     */
    cursor?: case_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of case_versions.
     */
    distinct?: Case_versionsScalarFieldEnum | Case_versionsScalarFieldEnum[]
  }

  /**
   * case_versions findFirstOrThrow
   */
  export type case_versionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * Filter, which case_versions to fetch.
     */
    where?: case_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_versions to fetch.
     */
    orderBy?: case_versionsOrderByWithRelationInput | case_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for case_versions.
     */
    cursor?: case_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of case_versions.
     */
    distinct?: Case_versionsScalarFieldEnum | Case_versionsScalarFieldEnum[]
  }

  /**
   * case_versions findMany
   */
  export type case_versionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * Filter, which case_versions to fetch.
     */
    where?: case_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_versions to fetch.
     */
    orderBy?: case_versionsOrderByWithRelationInput | case_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing case_versions.
     */
    cursor?: case_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_versions.
     */
    skip?: number
    distinct?: Case_versionsScalarFieldEnum | Case_versionsScalarFieldEnum[]
  }

  /**
   * case_versions create
   */
  export type case_versionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * The data needed to create a case_versions.
     */
    data: XOR<case_versionsCreateInput, case_versionsUncheckedCreateInput>
  }

  /**
   * case_versions createMany
   */
  export type case_versionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many case_versions.
     */
    data: case_versionsCreateManyInput | case_versionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * case_versions update
   */
  export type case_versionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * The data needed to update a case_versions.
     */
    data: XOR<case_versionsUpdateInput, case_versionsUncheckedUpdateInput>
    /**
     * Choose, which case_versions to update.
     */
    where: case_versionsWhereUniqueInput
  }

  /**
   * case_versions updateMany
   */
  export type case_versionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update case_versions.
     */
    data: XOR<case_versionsUpdateManyMutationInput, case_versionsUncheckedUpdateManyInput>
    /**
     * Filter which case_versions to update
     */
    where?: case_versionsWhereInput
    /**
     * Limit how many case_versions to update.
     */
    limit?: number
  }

  /**
   * case_versions upsert
   */
  export type case_versionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * The filter to search for the case_versions to update in case it exists.
     */
    where: case_versionsWhereUniqueInput
    /**
     * In case the case_versions found by the `where` argument doesn't exist, create a new case_versions with this data.
     */
    create: XOR<case_versionsCreateInput, case_versionsUncheckedCreateInput>
    /**
     * In case the case_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<case_versionsUpdateInput, case_versionsUncheckedUpdateInput>
  }

  /**
   * case_versions delete
   */
  export type case_versionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
    /**
     * Filter which case_versions to delete.
     */
    where: case_versionsWhereUniqueInput
  }

  /**
   * case_versions deleteMany
   */
  export type case_versionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which case_versions to delete
     */
    where?: case_versionsWhereInput
    /**
     * Limit how many case_versions to delete.
     */
    limit?: number
  }

  /**
   * case_versions.users
   */
  export type case_versions$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * case_versions without action
   */
  export type case_versionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_versions
     */
    select?: case_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_versions
     */
    omit?: case_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_versionsInclude<ExtArgs> | null
  }


  /**
   * Model bulk_edit_sessions
   */

  export type AggregateBulk_edit_sessions = {
    _count: Bulk_edit_sessionsCountAggregateOutputType | null
    _avg: Bulk_edit_sessionsAvgAggregateOutputType | null
    _sum: Bulk_edit_sessionsSumAggregateOutputType | null
    _min: Bulk_edit_sessionsMinAggregateOutputType | null
    _max: Bulk_edit_sessionsMaxAggregateOutputType | null
  }

  export type Bulk_edit_sessionsAvgAggregateOutputType = {
    id: number | null
    created_by: number | null
  }

  export type Bulk_edit_sessionsSumAggregateOutputType = {
    id: number | null
    created_by: number | null
  }

  export type Bulk_edit_sessionsMinAggregateOutputType = {
    id: number | null
    system: string | null
    module: string | null
    priority_filter: string | null
    change_brief: string | null
    status: $Enums.bulk_edit_sessions_status | null
    created_by: number | null
    created_at: Date | null
    applied_at: Date | null
  }

  export type Bulk_edit_sessionsMaxAggregateOutputType = {
    id: number | null
    system: string | null
    module: string | null
    priority_filter: string | null
    change_brief: string | null
    status: $Enums.bulk_edit_sessions_status | null
    created_by: number | null
    created_at: Date | null
    applied_at: Date | null
  }

  export type Bulk_edit_sessionsCountAggregateOutputType = {
    id: number
    system: number
    module: number
    tag_filter: number
    priority_filter: number
    change_brief: number
    status: number
    created_by: number
    created_at: number
    applied_at: number
    _all: number
  }


  export type Bulk_edit_sessionsAvgAggregateInputType = {
    id?: true
    created_by?: true
  }

  export type Bulk_edit_sessionsSumAggregateInputType = {
    id?: true
    created_by?: true
  }

  export type Bulk_edit_sessionsMinAggregateInputType = {
    id?: true
    system?: true
    module?: true
    priority_filter?: true
    change_brief?: true
    status?: true
    created_by?: true
    created_at?: true
    applied_at?: true
  }

  export type Bulk_edit_sessionsMaxAggregateInputType = {
    id?: true
    system?: true
    module?: true
    priority_filter?: true
    change_brief?: true
    status?: true
    created_by?: true
    created_at?: true
    applied_at?: true
  }

  export type Bulk_edit_sessionsCountAggregateInputType = {
    id?: true
    system?: true
    module?: true
    tag_filter?: true
    priority_filter?: true
    change_brief?: true
    status?: true
    created_by?: true
    created_at?: true
    applied_at?: true
    _all?: true
  }

  export type Bulk_edit_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bulk_edit_sessions to aggregate.
     */
    where?: bulk_edit_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bulk_edit_sessions to fetch.
     */
    orderBy?: bulk_edit_sessionsOrderByWithRelationInput | bulk_edit_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bulk_edit_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bulk_edit_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bulk_edit_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bulk_edit_sessions
    **/
    _count?: true | Bulk_edit_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bulk_edit_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bulk_edit_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bulk_edit_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bulk_edit_sessionsMaxAggregateInputType
  }

  export type GetBulk_edit_sessionsAggregateType<T extends Bulk_edit_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateBulk_edit_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBulk_edit_sessions[P]>
      : GetScalarType<T[P], AggregateBulk_edit_sessions[P]>
  }




  export type bulk_edit_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bulk_edit_sessionsWhereInput
    orderBy?: bulk_edit_sessionsOrderByWithAggregationInput | bulk_edit_sessionsOrderByWithAggregationInput[]
    by: Bulk_edit_sessionsScalarFieldEnum[] | Bulk_edit_sessionsScalarFieldEnum
    having?: bulk_edit_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bulk_edit_sessionsCountAggregateInputType | true
    _avg?: Bulk_edit_sessionsAvgAggregateInputType
    _sum?: Bulk_edit_sessionsSumAggregateInputType
    _min?: Bulk_edit_sessionsMinAggregateInputType
    _max?: Bulk_edit_sessionsMaxAggregateInputType
  }

  export type Bulk_edit_sessionsGroupByOutputType = {
    id: number
    system: string
    module: string
    tag_filter: JsonValue | null
    priority_filter: string | null
    change_brief: string
    status: $Enums.bulk_edit_sessions_status
    created_by: number
    created_at: Date | null
    applied_at: Date | null
    _count: Bulk_edit_sessionsCountAggregateOutputType | null
    _avg: Bulk_edit_sessionsAvgAggregateOutputType | null
    _sum: Bulk_edit_sessionsSumAggregateOutputType | null
    _min: Bulk_edit_sessionsMinAggregateOutputType | null
    _max: Bulk_edit_sessionsMaxAggregateOutputType | null
  }

  type GetBulk_edit_sessionsGroupByPayload<T extends bulk_edit_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bulk_edit_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bulk_edit_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bulk_edit_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Bulk_edit_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type bulk_edit_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    system?: boolean
    module?: boolean
    tag_filter?: boolean
    priority_filter?: boolean
    change_brief?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    applied_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    proposals?: boolean | bulk_edit_sessions$proposalsArgs<ExtArgs>
    _count?: boolean | Bulk_edit_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulk_edit_sessions"]>



  export type bulk_edit_sessionsSelectScalar = {
    id?: boolean
    system?: boolean
    module?: boolean
    tag_filter?: boolean
    priority_filter?: boolean
    change_brief?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    applied_at?: boolean
  }

  export type bulk_edit_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "system" | "module" | "tag_filter" | "priority_filter" | "change_brief" | "status" | "created_by" | "created_at" | "applied_at", ExtArgs["result"]["bulk_edit_sessions"]>
  export type bulk_edit_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    proposals?: boolean | bulk_edit_sessions$proposalsArgs<ExtArgs>
    _count?: boolean | Bulk_edit_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $bulk_edit_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bulk_edit_sessions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      proposals: Prisma.$case_patch_proposalsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      system: string
      module: string
      tag_filter: Prisma.JsonValue | null
      priority_filter: string | null
      change_brief: string
      status: $Enums.bulk_edit_sessions_status
      created_by: number
      created_at: Date | null
      applied_at: Date | null
    }, ExtArgs["result"]["bulk_edit_sessions"]>
    composites: {}
  }

  type bulk_edit_sessionsGetPayload<S extends boolean | null | undefined | bulk_edit_sessionsDefaultArgs> = $Result.GetResult<Prisma.$bulk_edit_sessionsPayload, S>

  type bulk_edit_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bulk_edit_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bulk_edit_sessionsCountAggregateInputType | true
    }

  export interface bulk_edit_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bulk_edit_sessions'], meta: { name: 'bulk_edit_sessions' } }
    /**
     * Find zero or one Bulk_edit_sessions that matches the filter.
     * @param {bulk_edit_sessionsFindUniqueArgs} args - Arguments to find a Bulk_edit_sessions
     * @example
     * // Get one Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bulk_edit_sessionsFindUniqueArgs>(args: SelectSubset<T, bulk_edit_sessionsFindUniqueArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bulk_edit_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bulk_edit_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Bulk_edit_sessions
     * @example
     * // Get one Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bulk_edit_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, bulk_edit_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bulk_edit_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bulk_edit_sessionsFindFirstArgs} args - Arguments to find a Bulk_edit_sessions
     * @example
     * // Get one Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bulk_edit_sessionsFindFirstArgs>(args?: SelectSubset<T, bulk_edit_sessionsFindFirstArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bulk_edit_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bulk_edit_sessionsFindFirstOrThrowArgs} args - Arguments to find a Bulk_edit_sessions
     * @example
     * // Get one Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bulk_edit_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, bulk_edit_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bulk_edit_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bulk_edit_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.findMany()
     * 
     * // Get first 10 Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bulk_edit_sessionsWithIdOnly = await prisma.bulk_edit_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bulk_edit_sessionsFindManyArgs>(args?: SelectSubset<T, bulk_edit_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bulk_edit_sessions.
     * @param {bulk_edit_sessionsCreateArgs} args - Arguments to create a Bulk_edit_sessions.
     * @example
     * // Create one Bulk_edit_sessions
     * const Bulk_edit_sessions = await prisma.bulk_edit_sessions.create({
     *   data: {
     *     // ... data to create a Bulk_edit_sessions
     *   }
     * })
     * 
     */
    create<T extends bulk_edit_sessionsCreateArgs>(args: SelectSubset<T, bulk_edit_sessionsCreateArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bulk_edit_sessions.
     * @param {bulk_edit_sessionsCreateManyArgs} args - Arguments to create many Bulk_edit_sessions.
     * @example
     * // Create many Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bulk_edit_sessionsCreateManyArgs>(args?: SelectSubset<T, bulk_edit_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bulk_edit_sessions.
     * @param {bulk_edit_sessionsDeleteArgs} args - Arguments to delete one Bulk_edit_sessions.
     * @example
     * // Delete one Bulk_edit_sessions
     * const Bulk_edit_sessions = await prisma.bulk_edit_sessions.delete({
     *   where: {
     *     // ... filter to delete one Bulk_edit_sessions
     *   }
     * })
     * 
     */
    delete<T extends bulk_edit_sessionsDeleteArgs>(args: SelectSubset<T, bulk_edit_sessionsDeleteArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bulk_edit_sessions.
     * @param {bulk_edit_sessionsUpdateArgs} args - Arguments to update one Bulk_edit_sessions.
     * @example
     * // Update one Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bulk_edit_sessionsUpdateArgs>(args: SelectSubset<T, bulk_edit_sessionsUpdateArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bulk_edit_sessions.
     * @param {bulk_edit_sessionsDeleteManyArgs} args - Arguments to filter Bulk_edit_sessions to delete.
     * @example
     * // Delete a few Bulk_edit_sessions
     * const { count } = await prisma.bulk_edit_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bulk_edit_sessionsDeleteManyArgs>(args?: SelectSubset<T, bulk_edit_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bulk_edit_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bulk_edit_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bulk_edit_sessionsUpdateManyArgs>(args: SelectSubset<T, bulk_edit_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bulk_edit_sessions.
     * @param {bulk_edit_sessionsUpsertArgs} args - Arguments to update or create a Bulk_edit_sessions.
     * @example
     * // Update or create a Bulk_edit_sessions
     * const bulk_edit_sessions = await prisma.bulk_edit_sessions.upsert({
     *   create: {
     *     // ... data to create a Bulk_edit_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bulk_edit_sessions we want to update
     *   }
     * })
     */
    upsert<T extends bulk_edit_sessionsUpsertArgs>(args: SelectSubset<T, bulk_edit_sessionsUpsertArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bulk_edit_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bulk_edit_sessionsCountArgs} args - Arguments to filter Bulk_edit_sessions to count.
     * @example
     * // Count the number of Bulk_edit_sessions
     * const count = await prisma.bulk_edit_sessions.count({
     *   where: {
     *     // ... the filter for the Bulk_edit_sessions we want to count
     *   }
     * })
    **/
    count<T extends bulk_edit_sessionsCountArgs>(
      args?: Subset<T, bulk_edit_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bulk_edit_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bulk_edit_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bulk_edit_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bulk_edit_sessionsAggregateArgs>(args: Subset<T, Bulk_edit_sessionsAggregateArgs>): Prisma.PrismaPromise<GetBulk_edit_sessionsAggregateType<T>>

    /**
     * Group by Bulk_edit_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bulk_edit_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bulk_edit_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bulk_edit_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: bulk_edit_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bulk_edit_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBulk_edit_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bulk_edit_sessions model
   */
  readonly fields: bulk_edit_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bulk_edit_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bulk_edit_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proposals<T extends bulk_edit_sessions$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, bulk_edit_sessions$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bulk_edit_sessions model
   */
  interface bulk_edit_sessionsFieldRefs {
    readonly id: FieldRef<"bulk_edit_sessions", 'Int'>
    readonly system: FieldRef<"bulk_edit_sessions", 'String'>
    readonly module: FieldRef<"bulk_edit_sessions", 'String'>
    readonly tag_filter: FieldRef<"bulk_edit_sessions", 'Json'>
    readonly priority_filter: FieldRef<"bulk_edit_sessions", 'String'>
    readonly change_brief: FieldRef<"bulk_edit_sessions", 'String'>
    readonly status: FieldRef<"bulk_edit_sessions", 'bulk_edit_sessions_status'>
    readonly created_by: FieldRef<"bulk_edit_sessions", 'Int'>
    readonly created_at: FieldRef<"bulk_edit_sessions", 'DateTime'>
    readonly applied_at: FieldRef<"bulk_edit_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bulk_edit_sessions findUnique
   */
  export type bulk_edit_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which bulk_edit_sessions to fetch.
     */
    where: bulk_edit_sessionsWhereUniqueInput
  }

  /**
   * bulk_edit_sessions findUniqueOrThrow
   */
  export type bulk_edit_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which bulk_edit_sessions to fetch.
     */
    where: bulk_edit_sessionsWhereUniqueInput
  }

  /**
   * bulk_edit_sessions findFirst
   */
  export type bulk_edit_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which bulk_edit_sessions to fetch.
     */
    where?: bulk_edit_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bulk_edit_sessions to fetch.
     */
    orderBy?: bulk_edit_sessionsOrderByWithRelationInput | bulk_edit_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bulk_edit_sessions.
     */
    cursor?: bulk_edit_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bulk_edit_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bulk_edit_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bulk_edit_sessions.
     */
    distinct?: Bulk_edit_sessionsScalarFieldEnum | Bulk_edit_sessionsScalarFieldEnum[]
  }

  /**
   * bulk_edit_sessions findFirstOrThrow
   */
  export type bulk_edit_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which bulk_edit_sessions to fetch.
     */
    where?: bulk_edit_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bulk_edit_sessions to fetch.
     */
    orderBy?: bulk_edit_sessionsOrderByWithRelationInput | bulk_edit_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bulk_edit_sessions.
     */
    cursor?: bulk_edit_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bulk_edit_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bulk_edit_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bulk_edit_sessions.
     */
    distinct?: Bulk_edit_sessionsScalarFieldEnum | Bulk_edit_sessionsScalarFieldEnum[]
  }

  /**
   * bulk_edit_sessions findMany
   */
  export type bulk_edit_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which bulk_edit_sessions to fetch.
     */
    where?: bulk_edit_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bulk_edit_sessions to fetch.
     */
    orderBy?: bulk_edit_sessionsOrderByWithRelationInput | bulk_edit_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bulk_edit_sessions.
     */
    cursor?: bulk_edit_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bulk_edit_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bulk_edit_sessions.
     */
    skip?: number
    distinct?: Bulk_edit_sessionsScalarFieldEnum | Bulk_edit_sessionsScalarFieldEnum[]
  }

  /**
   * bulk_edit_sessions create
   */
  export type bulk_edit_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a bulk_edit_sessions.
     */
    data: XOR<bulk_edit_sessionsCreateInput, bulk_edit_sessionsUncheckedCreateInput>
  }

  /**
   * bulk_edit_sessions createMany
   */
  export type bulk_edit_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bulk_edit_sessions.
     */
    data: bulk_edit_sessionsCreateManyInput | bulk_edit_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bulk_edit_sessions update
   */
  export type bulk_edit_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a bulk_edit_sessions.
     */
    data: XOR<bulk_edit_sessionsUpdateInput, bulk_edit_sessionsUncheckedUpdateInput>
    /**
     * Choose, which bulk_edit_sessions to update.
     */
    where: bulk_edit_sessionsWhereUniqueInput
  }

  /**
   * bulk_edit_sessions updateMany
   */
  export type bulk_edit_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bulk_edit_sessions.
     */
    data: XOR<bulk_edit_sessionsUpdateManyMutationInput, bulk_edit_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which bulk_edit_sessions to update
     */
    where?: bulk_edit_sessionsWhereInput
    /**
     * Limit how many bulk_edit_sessions to update.
     */
    limit?: number
  }

  /**
   * bulk_edit_sessions upsert
   */
  export type bulk_edit_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the bulk_edit_sessions to update in case it exists.
     */
    where: bulk_edit_sessionsWhereUniqueInput
    /**
     * In case the bulk_edit_sessions found by the `where` argument doesn't exist, create a new bulk_edit_sessions with this data.
     */
    create: XOR<bulk_edit_sessionsCreateInput, bulk_edit_sessionsUncheckedCreateInput>
    /**
     * In case the bulk_edit_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bulk_edit_sessionsUpdateInput, bulk_edit_sessionsUncheckedUpdateInput>
  }

  /**
   * bulk_edit_sessions delete
   */
  export type bulk_edit_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
    /**
     * Filter which bulk_edit_sessions to delete.
     */
    where: bulk_edit_sessionsWhereUniqueInput
  }

  /**
   * bulk_edit_sessions deleteMany
   */
  export type bulk_edit_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bulk_edit_sessions to delete
     */
    where?: bulk_edit_sessionsWhereInput
    /**
     * Limit how many bulk_edit_sessions to delete.
     */
    limit?: number
  }

  /**
   * bulk_edit_sessions.proposals
   */
  export type bulk_edit_sessions$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    where?: case_patch_proposalsWhereInput
    orderBy?: case_patch_proposalsOrderByWithRelationInput | case_patch_proposalsOrderByWithRelationInput[]
    cursor?: case_patch_proposalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Case_patch_proposalsScalarFieldEnum | Case_patch_proposalsScalarFieldEnum[]
  }

  /**
   * bulk_edit_sessions without action
   */
  export type bulk_edit_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bulk_edit_sessions
     */
    select?: bulk_edit_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bulk_edit_sessions
     */
    omit?: bulk_edit_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bulk_edit_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model case_patch_proposals
   */

  export type AggregateCase_patch_proposals = {
    _count: Case_patch_proposalsCountAggregateOutputType | null
    _avg: Case_patch_proposalsAvgAggregateOutputType | null
    _sum: Case_patch_proposalsSumAggregateOutputType | null
    _min: Case_patch_proposalsMinAggregateOutputType | null
    _max: Case_patch_proposalsMaxAggregateOutputType | null
  }

  export type Case_patch_proposalsAvgAggregateOutputType = {
    id: number | null
    session_id: number | null
    case_id: number | null
  }

  export type Case_patch_proposalsSumAggregateOutputType = {
    id: number | null
    session_id: number | null
    case_id: number | null
  }

  export type Case_patch_proposalsMinAggregateOutputType = {
    id: number | null
    session_id: number | null
    case_id: number | null
    ai_rationale: string | null
    risk_level: $Enums.proposal_risk_level | null
    recall_reason: string | null
    old_hash: string | null
    new_hash: string | null
    apply_status: $Enums.proposal_apply_status | null
    created_at: Date | null
    applied_at: Date | null
  }

  export type Case_patch_proposalsMaxAggregateOutputType = {
    id: number | null
    session_id: number | null
    case_id: number | null
    ai_rationale: string | null
    risk_level: $Enums.proposal_risk_level | null
    recall_reason: string | null
    old_hash: string | null
    new_hash: string | null
    apply_status: $Enums.proposal_apply_status | null
    created_at: Date | null
    applied_at: Date | null
  }

  export type Case_patch_proposalsCountAggregateOutputType = {
    id: number
    session_id: number
    case_id: number
    diff_json: number
    ai_rationale: number
    side_effects: number
    risk_level: number
    recall_reason: number
    old_hash: number
    new_hash: number
    apply_status: number
    created_at: number
    applied_at: number
    _all: number
  }


  export type Case_patch_proposalsAvgAggregateInputType = {
    id?: true
    session_id?: true
    case_id?: true
  }

  export type Case_patch_proposalsSumAggregateInputType = {
    id?: true
    session_id?: true
    case_id?: true
  }

  export type Case_patch_proposalsMinAggregateInputType = {
    id?: true
    session_id?: true
    case_id?: true
    ai_rationale?: true
    risk_level?: true
    recall_reason?: true
    old_hash?: true
    new_hash?: true
    apply_status?: true
    created_at?: true
    applied_at?: true
  }

  export type Case_patch_proposalsMaxAggregateInputType = {
    id?: true
    session_id?: true
    case_id?: true
    ai_rationale?: true
    risk_level?: true
    recall_reason?: true
    old_hash?: true
    new_hash?: true
    apply_status?: true
    created_at?: true
    applied_at?: true
  }

  export type Case_patch_proposalsCountAggregateInputType = {
    id?: true
    session_id?: true
    case_id?: true
    diff_json?: true
    ai_rationale?: true
    side_effects?: true
    risk_level?: true
    recall_reason?: true
    old_hash?: true
    new_hash?: true
    apply_status?: true
    created_at?: true
    applied_at?: true
    _all?: true
  }

  export type Case_patch_proposalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which case_patch_proposals to aggregate.
     */
    where?: case_patch_proposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_patch_proposals to fetch.
     */
    orderBy?: case_patch_proposalsOrderByWithRelationInput | case_patch_proposalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: case_patch_proposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_patch_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_patch_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned case_patch_proposals
    **/
    _count?: true | Case_patch_proposalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Case_patch_proposalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Case_patch_proposalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Case_patch_proposalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Case_patch_proposalsMaxAggregateInputType
  }

  export type GetCase_patch_proposalsAggregateType<T extends Case_patch_proposalsAggregateArgs> = {
        [P in keyof T & keyof AggregateCase_patch_proposals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCase_patch_proposals[P]>
      : GetScalarType<T[P], AggregateCase_patch_proposals[P]>
  }




  export type case_patch_proposalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_patch_proposalsWhereInput
    orderBy?: case_patch_proposalsOrderByWithAggregationInput | case_patch_proposalsOrderByWithAggregationInput[]
    by: Case_patch_proposalsScalarFieldEnum[] | Case_patch_proposalsScalarFieldEnum
    having?: case_patch_proposalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Case_patch_proposalsCountAggregateInputType | true
    _avg?: Case_patch_proposalsAvgAggregateInputType
    _sum?: Case_patch_proposalsSumAggregateInputType
    _min?: Case_patch_proposalsMinAggregateInputType
    _max?: Case_patch_proposalsMaxAggregateInputType
  }

  export type Case_patch_proposalsGroupByOutputType = {
    id: number
    session_id: number
    case_id: number
    diff_json: JsonValue
    ai_rationale: string | null
    side_effects: JsonValue | null
    risk_level: $Enums.proposal_risk_level
    recall_reason: string | null
    old_hash: string
    new_hash: string | null
    apply_status: $Enums.proposal_apply_status
    created_at: Date | null
    applied_at: Date | null
    _count: Case_patch_proposalsCountAggregateOutputType | null
    _avg: Case_patch_proposalsAvgAggregateOutputType | null
    _sum: Case_patch_proposalsSumAggregateOutputType | null
    _min: Case_patch_proposalsMinAggregateOutputType | null
    _max: Case_patch_proposalsMaxAggregateOutputType | null
  }

  type GetCase_patch_proposalsGroupByPayload<T extends case_patch_proposalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Case_patch_proposalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Case_patch_proposalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Case_patch_proposalsGroupByOutputType[P]>
            : GetScalarType<T[P], Case_patch_proposalsGroupByOutputType[P]>
        }
      >
    >


  export type case_patch_proposalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    case_id?: boolean
    diff_json?: boolean
    ai_rationale?: boolean
    side_effects?: boolean
    risk_level?: boolean
    recall_reason?: boolean
    old_hash?: boolean
    new_hash?: boolean
    apply_status?: boolean
    created_at?: boolean
    applied_at?: boolean
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
    session?: boolean | bulk_edit_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["case_patch_proposals"]>



  export type case_patch_proposalsSelectScalar = {
    id?: boolean
    session_id?: boolean
    case_id?: boolean
    diff_json?: boolean
    ai_rationale?: boolean
    side_effects?: boolean
    risk_level?: boolean
    recall_reason?: boolean
    old_hash?: boolean
    new_hash?: boolean
    apply_status?: boolean
    created_at?: boolean
    applied_at?: boolean
  }

  export type case_patch_proposalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "session_id" | "case_id" | "diff_json" | "ai_rationale" | "side_effects" | "risk_level" | "recall_reason" | "old_hash" | "new_hash" | "apply_status" | "created_at" | "applied_at", ExtArgs["result"]["case_patch_proposals"]>
  export type case_patch_proposalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
    session?: boolean | bulk_edit_sessionsDefaultArgs<ExtArgs>
  }

  export type $case_patch_proposalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "case_patch_proposals"
    objects: {
      test_cases: Prisma.$test_casesPayload<ExtArgs>
      session: Prisma.$bulk_edit_sessionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      session_id: number
      case_id: number
      diff_json: Prisma.JsonValue
      ai_rationale: string | null
      side_effects: Prisma.JsonValue | null
      risk_level: $Enums.proposal_risk_level
      recall_reason: string | null
      old_hash: string
      new_hash: string | null
      apply_status: $Enums.proposal_apply_status
      created_at: Date | null
      applied_at: Date | null
    }, ExtArgs["result"]["case_patch_proposals"]>
    composites: {}
  }

  type case_patch_proposalsGetPayload<S extends boolean | null | undefined | case_patch_proposalsDefaultArgs> = $Result.GetResult<Prisma.$case_patch_proposalsPayload, S>

  type case_patch_proposalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<case_patch_proposalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Case_patch_proposalsCountAggregateInputType | true
    }

  export interface case_patch_proposalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['case_patch_proposals'], meta: { name: 'case_patch_proposals' } }
    /**
     * Find zero or one Case_patch_proposals that matches the filter.
     * @param {case_patch_proposalsFindUniqueArgs} args - Arguments to find a Case_patch_proposals
     * @example
     * // Get one Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends case_patch_proposalsFindUniqueArgs>(args: SelectSubset<T, case_patch_proposalsFindUniqueArgs<ExtArgs>>): Prisma__case_patch_proposalsClient<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Case_patch_proposals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {case_patch_proposalsFindUniqueOrThrowArgs} args - Arguments to find a Case_patch_proposals
     * @example
     * // Get one Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends case_patch_proposalsFindUniqueOrThrowArgs>(args: SelectSubset<T, case_patch_proposalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__case_patch_proposalsClient<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case_patch_proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_patch_proposalsFindFirstArgs} args - Arguments to find a Case_patch_proposals
     * @example
     * // Get one Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends case_patch_proposalsFindFirstArgs>(args?: SelectSubset<T, case_patch_proposalsFindFirstArgs<ExtArgs>>): Prisma__case_patch_proposalsClient<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case_patch_proposals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_patch_proposalsFindFirstOrThrowArgs} args - Arguments to find a Case_patch_proposals
     * @example
     * // Get one Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends case_patch_proposalsFindFirstOrThrowArgs>(args?: SelectSubset<T, case_patch_proposalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__case_patch_proposalsClient<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Case_patch_proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_patch_proposalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.findMany()
     * 
     * // Get first 10 Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const case_patch_proposalsWithIdOnly = await prisma.case_patch_proposals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends case_patch_proposalsFindManyArgs>(args?: SelectSubset<T, case_patch_proposalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Case_patch_proposals.
     * @param {case_patch_proposalsCreateArgs} args - Arguments to create a Case_patch_proposals.
     * @example
     * // Create one Case_patch_proposals
     * const Case_patch_proposals = await prisma.case_patch_proposals.create({
     *   data: {
     *     // ... data to create a Case_patch_proposals
     *   }
     * })
     * 
     */
    create<T extends case_patch_proposalsCreateArgs>(args: SelectSubset<T, case_patch_proposalsCreateArgs<ExtArgs>>): Prisma__case_patch_proposalsClient<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Case_patch_proposals.
     * @param {case_patch_proposalsCreateManyArgs} args - Arguments to create many Case_patch_proposals.
     * @example
     * // Create many Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends case_patch_proposalsCreateManyArgs>(args?: SelectSubset<T, case_patch_proposalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Case_patch_proposals.
     * @param {case_patch_proposalsDeleteArgs} args - Arguments to delete one Case_patch_proposals.
     * @example
     * // Delete one Case_patch_proposals
     * const Case_patch_proposals = await prisma.case_patch_proposals.delete({
     *   where: {
     *     // ... filter to delete one Case_patch_proposals
     *   }
     * })
     * 
     */
    delete<T extends case_patch_proposalsDeleteArgs>(args: SelectSubset<T, case_patch_proposalsDeleteArgs<ExtArgs>>): Prisma__case_patch_proposalsClient<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Case_patch_proposals.
     * @param {case_patch_proposalsUpdateArgs} args - Arguments to update one Case_patch_proposals.
     * @example
     * // Update one Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends case_patch_proposalsUpdateArgs>(args: SelectSubset<T, case_patch_proposalsUpdateArgs<ExtArgs>>): Prisma__case_patch_proposalsClient<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Case_patch_proposals.
     * @param {case_patch_proposalsDeleteManyArgs} args - Arguments to filter Case_patch_proposals to delete.
     * @example
     * // Delete a few Case_patch_proposals
     * const { count } = await prisma.case_patch_proposals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends case_patch_proposalsDeleteManyArgs>(args?: SelectSubset<T, case_patch_proposalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Case_patch_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_patch_proposalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends case_patch_proposalsUpdateManyArgs>(args: SelectSubset<T, case_patch_proposalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Case_patch_proposals.
     * @param {case_patch_proposalsUpsertArgs} args - Arguments to update or create a Case_patch_proposals.
     * @example
     * // Update or create a Case_patch_proposals
     * const case_patch_proposals = await prisma.case_patch_proposals.upsert({
     *   create: {
     *     // ... data to create a Case_patch_proposals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Case_patch_proposals we want to update
     *   }
     * })
     */
    upsert<T extends case_patch_proposalsUpsertArgs>(args: SelectSubset<T, case_patch_proposalsUpsertArgs<ExtArgs>>): Prisma__case_patch_proposalsClient<$Result.GetResult<Prisma.$case_patch_proposalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Case_patch_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_patch_proposalsCountArgs} args - Arguments to filter Case_patch_proposals to count.
     * @example
     * // Count the number of Case_patch_proposals
     * const count = await prisma.case_patch_proposals.count({
     *   where: {
     *     // ... the filter for the Case_patch_proposals we want to count
     *   }
     * })
    **/
    count<T extends case_patch_proposalsCountArgs>(
      args?: Subset<T, case_patch_proposalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Case_patch_proposalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Case_patch_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Case_patch_proposalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Case_patch_proposalsAggregateArgs>(args: Subset<T, Case_patch_proposalsAggregateArgs>): Prisma.PrismaPromise<GetCase_patch_proposalsAggregateType<T>>

    /**
     * Group by Case_patch_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_patch_proposalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends case_patch_proposalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: case_patch_proposalsGroupByArgs['orderBy'] }
        : { orderBy?: case_patch_proposalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, case_patch_proposalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCase_patch_proposalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the case_patch_proposals model
   */
  readonly fields: case_patch_proposalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for case_patch_proposals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__case_patch_proposalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_cases<T extends test_casesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_casesDefaultArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends bulk_edit_sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bulk_edit_sessionsDefaultArgs<ExtArgs>>): Prisma__bulk_edit_sessionsClient<$Result.GetResult<Prisma.$bulk_edit_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the case_patch_proposals model
   */
  interface case_patch_proposalsFieldRefs {
    readonly id: FieldRef<"case_patch_proposals", 'Int'>
    readonly session_id: FieldRef<"case_patch_proposals", 'Int'>
    readonly case_id: FieldRef<"case_patch_proposals", 'Int'>
    readonly diff_json: FieldRef<"case_patch_proposals", 'Json'>
    readonly ai_rationale: FieldRef<"case_patch_proposals", 'String'>
    readonly side_effects: FieldRef<"case_patch_proposals", 'Json'>
    readonly risk_level: FieldRef<"case_patch_proposals", 'proposal_risk_level'>
    readonly recall_reason: FieldRef<"case_patch_proposals", 'String'>
    readonly old_hash: FieldRef<"case_patch_proposals", 'String'>
    readonly new_hash: FieldRef<"case_patch_proposals", 'String'>
    readonly apply_status: FieldRef<"case_patch_proposals", 'proposal_apply_status'>
    readonly created_at: FieldRef<"case_patch_proposals", 'DateTime'>
    readonly applied_at: FieldRef<"case_patch_proposals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * case_patch_proposals findUnique
   */
  export type case_patch_proposalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which case_patch_proposals to fetch.
     */
    where: case_patch_proposalsWhereUniqueInput
  }

  /**
   * case_patch_proposals findUniqueOrThrow
   */
  export type case_patch_proposalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which case_patch_proposals to fetch.
     */
    where: case_patch_proposalsWhereUniqueInput
  }

  /**
   * case_patch_proposals findFirst
   */
  export type case_patch_proposalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which case_patch_proposals to fetch.
     */
    where?: case_patch_proposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_patch_proposals to fetch.
     */
    orderBy?: case_patch_proposalsOrderByWithRelationInput | case_patch_proposalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for case_patch_proposals.
     */
    cursor?: case_patch_proposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_patch_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_patch_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of case_patch_proposals.
     */
    distinct?: Case_patch_proposalsScalarFieldEnum | Case_patch_proposalsScalarFieldEnum[]
  }

  /**
   * case_patch_proposals findFirstOrThrow
   */
  export type case_patch_proposalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which case_patch_proposals to fetch.
     */
    where?: case_patch_proposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_patch_proposals to fetch.
     */
    orderBy?: case_patch_proposalsOrderByWithRelationInput | case_patch_proposalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for case_patch_proposals.
     */
    cursor?: case_patch_proposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_patch_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_patch_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of case_patch_proposals.
     */
    distinct?: Case_patch_proposalsScalarFieldEnum | Case_patch_proposalsScalarFieldEnum[]
  }

  /**
   * case_patch_proposals findMany
   */
  export type case_patch_proposalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which case_patch_proposals to fetch.
     */
    where?: case_patch_proposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_patch_proposals to fetch.
     */
    orderBy?: case_patch_proposalsOrderByWithRelationInput | case_patch_proposalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing case_patch_proposals.
     */
    cursor?: case_patch_proposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_patch_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_patch_proposals.
     */
    skip?: number
    distinct?: Case_patch_proposalsScalarFieldEnum | Case_patch_proposalsScalarFieldEnum[]
  }

  /**
   * case_patch_proposals create
   */
  export type case_patch_proposalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * The data needed to create a case_patch_proposals.
     */
    data: XOR<case_patch_proposalsCreateInput, case_patch_proposalsUncheckedCreateInput>
  }

  /**
   * case_patch_proposals createMany
   */
  export type case_patch_proposalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many case_patch_proposals.
     */
    data: case_patch_proposalsCreateManyInput | case_patch_proposalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * case_patch_proposals update
   */
  export type case_patch_proposalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * The data needed to update a case_patch_proposals.
     */
    data: XOR<case_patch_proposalsUpdateInput, case_patch_proposalsUncheckedUpdateInput>
    /**
     * Choose, which case_patch_proposals to update.
     */
    where: case_patch_proposalsWhereUniqueInput
  }

  /**
   * case_patch_proposals updateMany
   */
  export type case_patch_proposalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update case_patch_proposals.
     */
    data: XOR<case_patch_proposalsUpdateManyMutationInput, case_patch_proposalsUncheckedUpdateManyInput>
    /**
     * Filter which case_patch_proposals to update
     */
    where?: case_patch_proposalsWhereInput
    /**
     * Limit how many case_patch_proposals to update.
     */
    limit?: number
  }

  /**
   * case_patch_proposals upsert
   */
  export type case_patch_proposalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * The filter to search for the case_patch_proposals to update in case it exists.
     */
    where: case_patch_proposalsWhereUniqueInput
    /**
     * In case the case_patch_proposals found by the `where` argument doesn't exist, create a new case_patch_proposals with this data.
     */
    create: XOR<case_patch_proposalsCreateInput, case_patch_proposalsUncheckedCreateInput>
    /**
     * In case the case_patch_proposals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<case_patch_proposalsUpdateInput, case_patch_proposalsUncheckedUpdateInput>
  }

  /**
   * case_patch_proposals delete
   */
  export type case_patch_proposalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
    /**
     * Filter which case_patch_proposals to delete.
     */
    where: case_patch_proposalsWhereUniqueInput
  }

  /**
   * case_patch_proposals deleteMany
   */
  export type case_patch_proposalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which case_patch_proposals to delete
     */
    where?: case_patch_proposalsWhereInput
    /**
     * Limit how many case_patch_proposals to delete.
     */
    limit?: number
  }

  /**
   * case_patch_proposals without action
   */
  export type case_patch_proposalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_patch_proposals
     */
    select?: case_patch_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_patch_proposals
     */
    omit?: case_patch_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_patch_proposalsInclude<ExtArgs> | null
  }


  /**
   * Model test_case_executions
   */

  export type AggregateTest_case_executions = {
    _count: Test_case_executionsCountAggregateOutputType | null
    _avg: Test_case_executionsAvgAggregateOutputType | null
    _sum: Test_case_executionsSumAggregateOutputType | null
    _min: Test_case_executionsMinAggregateOutputType | null
    _max: Test_case_executionsMaxAggregateOutputType | null
  }

  export type Test_case_executionsAvgAggregateOutputType = {
    test_case_id: number | null
    executor_user_id: number | null
    duration_ms: number | null
    total_steps: number | null
    completed_steps: number | null
    passed_steps: number | null
    failed_steps: number | null
    progress: number | null
  }

  export type Test_case_executionsSumAggregateOutputType = {
    test_case_id: number | null
    executor_user_id: number | null
    duration_ms: number | null
    total_steps: number | null
    completed_steps: number | null
    passed_steps: number | null
    failed_steps: number | null
    progress: number | null
  }

  export type Test_case_executionsMinAggregateOutputType = {
    id: string | null
    test_case_id: number | null
    test_case_title: string | null
    environment: string | null
    execution_mode: string | null
    status: $Enums.test_case_execution_status | null
    executor_user_id: number | null
    executor_project: string | null
    queued_at: Date | null
    started_at: Date | null
    finished_at: Date | null
    duration_ms: number | null
    total_steps: number | null
    completed_steps: number | null
    passed_steps: number | null
    failed_steps: number | null
    progress: number | null
    error_message: string | null
  }

  export type Test_case_executionsMaxAggregateOutputType = {
    id: string | null
    test_case_id: number | null
    test_case_title: string | null
    environment: string | null
    execution_mode: string | null
    status: $Enums.test_case_execution_status | null
    executor_user_id: number | null
    executor_project: string | null
    queued_at: Date | null
    started_at: Date | null
    finished_at: Date | null
    duration_ms: number | null
    total_steps: number | null
    completed_steps: number | null
    passed_steps: number | null
    failed_steps: number | null
    progress: number | null
    error_message: string | null
  }

  export type Test_case_executionsCountAggregateOutputType = {
    id: number
    test_case_id: number
    test_case_title: number
    environment: number
    execution_mode: number
    status: number
    executor_user_id: number
    executor_project: number
    queued_at: number
    started_at: number
    finished_at: number
    duration_ms: number
    total_steps: number
    completed_steps: number
    passed_steps: number
    failed_steps: number
    progress: number
    error_message: number
    execution_logs: number
    screenshots: number
    artifacts: number
    metadata: number
    _all: number
  }


  export type Test_case_executionsAvgAggregateInputType = {
    test_case_id?: true
    executor_user_id?: true
    duration_ms?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    progress?: true
  }

  export type Test_case_executionsSumAggregateInputType = {
    test_case_id?: true
    executor_user_id?: true
    duration_ms?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    progress?: true
  }

  export type Test_case_executionsMinAggregateInputType = {
    id?: true
    test_case_id?: true
    test_case_title?: true
    environment?: true
    execution_mode?: true
    status?: true
    executor_user_id?: true
    executor_project?: true
    queued_at?: true
    started_at?: true
    finished_at?: true
    duration_ms?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    progress?: true
    error_message?: true
  }

  export type Test_case_executionsMaxAggregateInputType = {
    id?: true
    test_case_id?: true
    test_case_title?: true
    environment?: true
    execution_mode?: true
    status?: true
    executor_user_id?: true
    executor_project?: true
    queued_at?: true
    started_at?: true
    finished_at?: true
    duration_ms?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    progress?: true
    error_message?: true
  }

  export type Test_case_executionsCountAggregateInputType = {
    id?: true
    test_case_id?: true
    test_case_title?: true
    environment?: true
    execution_mode?: true
    status?: true
    executor_user_id?: true
    executor_project?: true
    queued_at?: true
    started_at?: true
    finished_at?: true
    duration_ms?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    progress?: true
    error_message?: true
    execution_logs?: true
    screenshots?: true
    artifacts?: true
    metadata?: true
    _all?: true
  }

  export type Test_case_executionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_case_executions to aggregate.
     */
    where?: test_case_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_case_executions to fetch.
     */
    orderBy?: test_case_executionsOrderByWithRelationInput | test_case_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_case_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_case_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_case_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_case_executions
    **/
    _count?: true | Test_case_executionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_case_executionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_case_executionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_case_executionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_case_executionsMaxAggregateInputType
  }

  export type GetTest_case_executionsAggregateType<T extends Test_case_executionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_case_executions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_case_executions[P]>
      : GetScalarType<T[P], AggregateTest_case_executions[P]>
  }




  export type test_case_executionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_case_executionsWhereInput
    orderBy?: test_case_executionsOrderByWithAggregationInput | test_case_executionsOrderByWithAggregationInput[]
    by: Test_case_executionsScalarFieldEnum[] | Test_case_executionsScalarFieldEnum
    having?: test_case_executionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_case_executionsCountAggregateInputType | true
    _avg?: Test_case_executionsAvgAggregateInputType
    _sum?: Test_case_executionsSumAggregateInputType
    _min?: Test_case_executionsMinAggregateInputType
    _max?: Test_case_executionsMaxAggregateInputType
  }

  export type Test_case_executionsGroupByOutputType = {
    id: string
    test_case_id: number
    test_case_title: string
    environment: string
    execution_mode: string
    status: $Enums.test_case_execution_status
    executor_user_id: number | null
    executor_project: string | null
    queued_at: Date
    started_at: Date | null
    finished_at: Date | null
    duration_ms: number | null
    total_steps: number
    completed_steps: number
    passed_steps: number
    failed_steps: number
    progress: number
    error_message: string | null
    execution_logs: JsonValue | null
    screenshots: JsonValue | null
    artifacts: JsonValue | null
    metadata: JsonValue | null
    _count: Test_case_executionsCountAggregateOutputType | null
    _avg: Test_case_executionsAvgAggregateOutputType | null
    _sum: Test_case_executionsSumAggregateOutputType | null
    _min: Test_case_executionsMinAggregateOutputType | null
    _max: Test_case_executionsMaxAggregateOutputType | null
  }

  type GetTest_case_executionsGroupByPayload<T extends test_case_executionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_case_executionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_case_executionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_case_executionsGroupByOutputType[P]>
            : GetScalarType<T[P], Test_case_executionsGroupByOutputType[P]>
        }
      >
    >


  export type test_case_executionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    test_case_id?: boolean
    test_case_title?: boolean
    environment?: boolean
    execution_mode?: boolean
    status?: boolean
    executor_user_id?: boolean
    executor_project?: boolean
    queued_at?: boolean
    started_at?: boolean
    finished_at?: boolean
    duration_ms?: boolean
    total_steps?: boolean
    completed_steps?: boolean
    passed_steps?: boolean
    failed_steps?: boolean
    progress?: boolean
    error_message?: boolean
    execution_logs?: boolean
    screenshots?: boolean
    artifacts?: boolean
    metadata?: boolean
    users?: boolean | test_case_executions$usersArgs<ExtArgs>
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_case_executions"]>



  export type test_case_executionsSelectScalar = {
    id?: boolean
    test_case_id?: boolean
    test_case_title?: boolean
    environment?: boolean
    execution_mode?: boolean
    status?: boolean
    executor_user_id?: boolean
    executor_project?: boolean
    queued_at?: boolean
    started_at?: boolean
    finished_at?: boolean
    duration_ms?: boolean
    total_steps?: boolean
    completed_steps?: boolean
    passed_steps?: boolean
    failed_steps?: boolean
    progress?: boolean
    error_message?: boolean
    execution_logs?: boolean
    screenshots?: boolean
    artifacts?: boolean
    metadata?: boolean
  }

  export type test_case_executionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "test_case_id" | "test_case_title" | "environment" | "execution_mode" | "status" | "executor_user_id" | "executor_project" | "queued_at" | "started_at" | "finished_at" | "duration_ms" | "total_steps" | "completed_steps" | "passed_steps" | "failed_steps" | "progress" | "error_message" | "execution_logs" | "screenshots" | "artifacts" | "metadata", ExtArgs["result"]["test_case_executions"]>
  export type test_case_executionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | test_case_executions$usersArgs<ExtArgs>
    test_cases?: boolean | test_casesDefaultArgs<ExtArgs>
  }

  export type $test_case_executionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_case_executions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      test_cases: Prisma.$test_casesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      test_case_id: number
      test_case_title: string
      environment: string
      execution_mode: string
      status: $Enums.test_case_execution_status
      executor_user_id: number | null
      executor_project: string | null
      queued_at: Date
      started_at: Date | null
      finished_at: Date | null
      duration_ms: number | null
      total_steps: number
      completed_steps: number
      passed_steps: number
      failed_steps: number
      progress: number
      error_message: string | null
      execution_logs: Prisma.JsonValue | null
      screenshots: Prisma.JsonValue | null
      artifacts: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["test_case_executions"]>
    composites: {}
  }

  type test_case_executionsGetPayload<S extends boolean | null | undefined | test_case_executionsDefaultArgs> = $Result.GetResult<Prisma.$test_case_executionsPayload, S>

  type test_case_executionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_case_executionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_case_executionsCountAggregateInputType | true
    }

  export interface test_case_executionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_case_executions'], meta: { name: 'test_case_executions' } }
    /**
     * Find zero or one Test_case_executions that matches the filter.
     * @param {test_case_executionsFindUniqueArgs} args - Arguments to find a Test_case_executions
     * @example
     * // Get one Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_case_executionsFindUniqueArgs>(args: SelectSubset<T, test_case_executionsFindUniqueArgs<ExtArgs>>): Prisma__test_case_executionsClient<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_case_executions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_case_executionsFindUniqueOrThrowArgs} args - Arguments to find a Test_case_executions
     * @example
     * // Get one Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_case_executionsFindUniqueOrThrowArgs>(args: SelectSubset<T, test_case_executionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_case_executionsClient<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_case_executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_case_executionsFindFirstArgs} args - Arguments to find a Test_case_executions
     * @example
     * // Get one Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_case_executionsFindFirstArgs>(args?: SelectSubset<T, test_case_executionsFindFirstArgs<ExtArgs>>): Prisma__test_case_executionsClient<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_case_executions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_case_executionsFindFirstOrThrowArgs} args - Arguments to find a Test_case_executions
     * @example
     * // Get one Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_case_executionsFindFirstOrThrowArgs>(args?: SelectSubset<T, test_case_executionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_case_executionsClient<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_case_executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_case_executionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.findMany()
     * 
     * // Get first 10 Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const test_case_executionsWithIdOnly = await prisma.test_case_executions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends test_case_executionsFindManyArgs>(args?: SelectSubset<T, test_case_executionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_case_executions.
     * @param {test_case_executionsCreateArgs} args - Arguments to create a Test_case_executions.
     * @example
     * // Create one Test_case_executions
     * const Test_case_executions = await prisma.test_case_executions.create({
     *   data: {
     *     // ... data to create a Test_case_executions
     *   }
     * })
     * 
     */
    create<T extends test_case_executionsCreateArgs>(args: SelectSubset<T, test_case_executionsCreateArgs<ExtArgs>>): Prisma__test_case_executionsClient<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_case_executions.
     * @param {test_case_executionsCreateManyArgs} args - Arguments to create many Test_case_executions.
     * @example
     * // Create many Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_case_executionsCreateManyArgs>(args?: SelectSubset<T, test_case_executionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_case_executions.
     * @param {test_case_executionsDeleteArgs} args - Arguments to delete one Test_case_executions.
     * @example
     * // Delete one Test_case_executions
     * const Test_case_executions = await prisma.test_case_executions.delete({
     *   where: {
     *     // ... filter to delete one Test_case_executions
     *   }
     * })
     * 
     */
    delete<T extends test_case_executionsDeleteArgs>(args: SelectSubset<T, test_case_executionsDeleteArgs<ExtArgs>>): Prisma__test_case_executionsClient<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_case_executions.
     * @param {test_case_executionsUpdateArgs} args - Arguments to update one Test_case_executions.
     * @example
     * // Update one Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_case_executionsUpdateArgs>(args: SelectSubset<T, test_case_executionsUpdateArgs<ExtArgs>>): Prisma__test_case_executionsClient<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_case_executions.
     * @param {test_case_executionsDeleteManyArgs} args - Arguments to filter Test_case_executions to delete.
     * @example
     * // Delete a few Test_case_executions
     * const { count } = await prisma.test_case_executions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_case_executionsDeleteManyArgs>(args?: SelectSubset<T, test_case_executionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_case_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_case_executionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_case_executionsUpdateManyArgs>(args: SelectSubset<T, test_case_executionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_case_executions.
     * @param {test_case_executionsUpsertArgs} args - Arguments to update or create a Test_case_executions.
     * @example
     * // Update or create a Test_case_executions
     * const test_case_executions = await prisma.test_case_executions.upsert({
     *   create: {
     *     // ... data to create a Test_case_executions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_case_executions we want to update
     *   }
     * })
     */
    upsert<T extends test_case_executionsUpsertArgs>(args: SelectSubset<T, test_case_executionsUpsertArgs<ExtArgs>>): Prisma__test_case_executionsClient<$Result.GetResult<Prisma.$test_case_executionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_case_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_case_executionsCountArgs} args - Arguments to filter Test_case_executions to count.
     * @example
     * // Count the number of Test_case_executions
     * const count = await prisma.test_case_executions.count({
     *   where: {
     *     // ... the filter for the Test_case_executions we want to count
     *   }
     * })
    **/
    count<T extends test_case_executionsCountArgs>(
      args?: Subset<T, test_case_executionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_case_executionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_case_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_case_executionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_case_executionsAggregateArgs>(args: Subset<T, Test_case_executionsAggregateArgs>): Prisma.PrismaPromise<GetTest_case_executionsAggregateType<T>>

    /**
     * Group by Test_case_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_case_executionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_case_executionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_case_executionsGroupByArgs['orderBy'] }
        : { orderBy?: test_case_executionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_case_executionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_case_executionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_case_executions model
   */
  readonly fields: test_case_executionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_case_executions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_case_executionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends test_case_executions$usersArgs<ExtArgs> = {}>(args?: Subset<T, test_case_executions$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    test_cases<T extends test_casesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_casesDefaultArgs<ExtArgs>>): Prisma__test_casesClient<$Result.GetResult<Prisma.$test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_case_executions model
   */
  interface test_case_executionsFieldRefs {
    readonly id: FieldRef<"test_case_executions", 'String'>
    readonly test_case_id: FieldRef<"test_case_executions", 'Int'>
    readonly test_case_title: FieldRef<"test_case_executions", 'String'>
    readonly environment: FieldRef<"test_case_executions", 'String'>
    readonly execution_mode: FieldRef<"test_case_executions", 'String'>
    readonly status: FieldRef<"test_case_executions", 'test_case_execution_status'>
    readonly executor_user_id: FieldRef<"test_case_executions", 'Int'>
    readonly executor_project: FieldRef<"test_case_executions", 'String'>
    readonly queued_at: FieldRef<"test_case_executions", 'DateTime'>
    readonly started_at: FieldRef<"test_case_executions", 'DateTime'>
    readonly finished_at: FieldRef<"test_case_executions", 'DateTime'>
    readonly duration_ms: FieldRef<"test_case_executions", 'Int'>
    readonly total_steps: FieldRef<"test_case_executions", 'Int'>
    readonly completed_steps: FieldRef<"test_case_executions", 'Int'>
    readonly passed_steps: FieldRef<"test_case_executions", 'Int'>
    readonly failed_steps: FieldRef<"test_case_executions", 'Int'>
    readonly progress: FieldRef<"test_case_executions", 'Int'>
    readonly error_message: FieldRef<"test_case_executions", 'String'>
    readonly execution_logs: FieldRef<"test_case_executions", 'Json'>
    readonly screenshots: FieldRef<"test_case_executions", 'Json'>
    readonly artifacts: FieldRef<"test_case_executions", 'Json'>
    readonly metadata: FieldRef<"test_case_executions", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * test_case_executions findUnique
   */
  export type test_case_executionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_case_executions to fetch.
     */
    where: test_case_executionsWhereUniqueInput
  }

  /**
   * test_case_executions findUniqueOrThrow
   */
  export type test_case_executionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_case_executions to fetch.
     */
    where: test_case_executionsWhereUniqueInput
  }

  /**
   * test_case_executions findFirst
   */
  export type test_case_executionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_case_executions to fetch.
     */
    where?: test_case_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_case_executions to fetch.
     */
    orderBy?: test_case_executionsOrderByWithRelationInput | test_case_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_case_executions.
     */
    cursor?: test_case_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_case_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_case_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_case_executions.
     */
    distinct?: Test_case_executionsScalarFieldEnum | Test_case_executionsScalarFieldEnum[]
  }

  /**
   * test_case_executions findFirstOrThrow
   */
  export type test_case_executionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_case_executions to fetch.
     */
    where?: test_case_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_case_executions to fetch.
     */
    orderBy?: test_case_executionsOrderByWithRelationInput | test_case_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_case_executions.
     */
    cursor?: test_case_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_case_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_case_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_case_executions.
     */
    distinct?: Test_case_executionsScalarFieldEnum | Test_case_executionsScalarFieldEnum[]
  }

  /**
   * test_case_executions findMany
   */
  export type test_case_executionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_case_executions to fetch.
     */
    where?: test_case_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_case_executions to fetch.
     */
    orderBy?: test_case_executionsOrderByWithRelationInput | test_case_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_case_executions.
     */
    cursor?: test_case_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_case_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_case_executions.
     */
    skip?: number
    distinct?: Test_case_executionsScalarFieldEnum | Test_case_executionsScalarFieldEnum[]
  }

  /**
   * test_case_executions create
   */
  export type test_case_executionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * The data needed to create a test_case_executions.
     */
    data: XOR<test_case_executionsCreateInput, test_case_executionsUncheckedCreateInput>
  }

  /**
   * test_case_executions createMany
   */
  export type test_case_executionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_case_executions.
     */
    data: test_case_executionsCreateManyInput | test_case_executionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_case_executions update
   */
  export type test_case_executionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * The data needed to update a test_case_executions.
     */
    data: XOR<test_case_executionsUpdateInput, test_case_executionsUncheckedUpdateInput>
    /**
     * Choose, which test_case_executions to update.
     */
    where: test_case_executionsWhereUniqueInput
  }

  /**
   * test_case_executions updateMany
   */
  export type test_case_executionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_case_executions.
     */
    data: XOR<test_case_executionsUpdateManyMutationInput, test_case_executionsUncheckedUpdateManyInput>
    /**
     * Filter which test_case_executions to update
     */
    where?: test_case_executionsWhereInput
    /**
     * Limit how many test_case_executions to update.
     */
    limit?: number
  }

  /**
   * test_case_executions upsert
   */
  export type test_case_executionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * The filter to search for the test_case_executions to update in case it exists.
     */
    where: test_case_executionsWhereUniqueInput
    /**
     * In case the test_case_executions found by the `where` argument doesn't exist, create a new test_case_executions with this data.
     */
    create: XOR<test_case_executionsCreateInput, test_case_executionsUncheckedCreateInput>
    /**
     * In case the test_case_executions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_case_executionsUpdateInput, test_case_executionsUncheckedUpdateInput>
  }

  /**
   * test_case_executions delete
   */
  export type test_case_executionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
    /**
     * Filter which test_case_executions to delete.
     */
    where: test_case_executionsWhereUniqueInput
  }

  /**
   * test_case_executions deleteMany
   */
  export type test_case_executionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_case_executions to delete
     */
    where?: test_case_executionsWhereInput
    /**
     * Limit how many test_case_executions to delete.
     */
    limit?: number
  }

  /**
   * test_case_executions.users
   */
  export type test_case_executions$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * test_case_executions without action
   */
  export type test_case_executionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_case_executions
     */
    select?: test_case_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_case_executions
     */
    omit?: test_case_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_case_executionsInclude<ExtArgs> | null
  }


  /**
   * Model functional_test_cases
   */

  export type AggregateFunctional_test_cases = {
    _count: Functional_test_casesCountAggregateOutputType | null
    _avg: Functional_test_casesAvgAggregateOutputType | null
    _sum: Functional_test_casesSumAggregateOutputType | null
    _min: Functional_test_casesMinAggregateOutputType | null
    _max: Functional_test_casesMaxAggregateOutputType | null
  }

  export type Functional_test_casesAvgAggregateOutputType = {
    id: number | null
    creator_id: number | null
    batch_number: number | null
    project_version_id: number | null
    requirement_doc_id: number | null
  }

  export type Functional_test_casesSumAggregateOutputType = {
    id: number | null
    creator_id: number | null
    batch_number: number | null
    project_version_id: number | null
    requirement_doc_id: number | null
  }

  export type Functional_test_casesMinAggregateOutputType = {
    id: number | null
    case_id: string | null
    name: string | null
    description: string | null
    system: string | null
    module: string | null
    priority: $Enums.functional_test_priority | null
    tags: string | null
    status: $Enums.functional_test_status | null
    source: $Enums.functional_test_source | null
    ai_session_id: string | null
    creator_id: number | null
    test_type: string | null
    preconditions: string | null
    test_data: string | null
    section_id: string | null
    section_name: string | null
    scenario_name: string | null
    scenario_description: string | null
    batch_number: number | null
    coverage_areas: string | null
    created_at: Date | null
    updated_at: Date | null
    case_type: $Enums.functional_case_type | null
    project_version_id: number | null
    requirement_source: string | null
    section_description: string | null
    expected_result: string | null
    risk_level: $Enums.functional_risk_level | null
    steps: string | null
    test_point_name: string | null
    test_purpose: string | null
    requirement_doc_id: number | null
    deleted_at: Date | null
  }

  export type Functional_test_casesMaxAggregateOutputType = {
    id: number | null
    case_id: string | null
    name: string | null
    description: string | null
    system: string | null
    module: string | null
    priority: $Enums.functional_test_priority | null
    tags: string | null
    status: $Enums.functional_test_status | null
    source: $Enums.functional_test_source | null
    ai_session_id: string | null
    creator_id: number | null
    test_type: string | null
    preconditions: string | null
    test_data: string | null
    section_id: string | null
    section_name: string | null
    scenario_name: string | null
    scenario_description: string | null
    batch_number: number | null
    coverage_areas: string | null
    created_at: Date | null
    updated_at: Date | null
    case_type: $Enums.functional_case_type | null
    project_version_id: number | null
    requirement_source: string | null
    section_description: string | null
    expected_result: string | null
    risk_level: $Enums.functional_risk_level | null
    steps: string | null
    test_point_name: string | null
    test_purpose: string | null
    requirement_doc_id: number | null
    deleted_at: Date | null
  }

  export type Functional_test_casesCountAggregateOutputType = {
    id: number
    case_id: number
    name: number
    description: number
    system: number
    module: number
    priority: number
    tags: number
    status: number
    source: number
    ai_session_id: number
    creator_id: number
    test_type: number
    preconditions: number
    test_data: number
    section_id: number
    section_name: number
    scenario_name: number
    scenario_description: number
    batch_number: number
    coverage_areas: number
    created_at: number
    updated_at: number
    case_type: number
    project_version_id: number
    requirement_source: number
    section_description: number
    expected_result: number
    risk_level: number
    steps: number
    test_point_name: number
    test_purpose: number
    requirement_doc_id: number
    deleted_at: number
    _all: number
  }


  export type Functional_test_casesAvgAggregateInputType = {
    id?: true
    creator_id?: true
    batch_number?: true
    project_version_id?: true
    requirement_doc_id?: true
  }

  export type Functional_test_casesSumAggregateInputType = {
    id?: true
    creator_id?: true
    batch_number?: true
    project_version_id?: true
    requirement_doc_id?: true
  }

  export type Functional_test_casesMinAggregateInputType = {
    id?: true
    case_id?: true
    name?: true
    description?: true
    system?: true
    module?: true
    priority?: true
    tags?: true
    status?: true
    source?: true
    ai_session_id?: true
    creator_id?: true
    test_type?: true
    preconditions?: true
    test_data?: true
    section_id?: true
    section_name?: true
    scenario_name?: true
    scenario_description?: true
    batch_number?: true
    coverage_areas?: true
    created_at?: true
    updated_at?: true
    case_type?: true
    project_version_id?: true
    requirement_source?: true
    section_description?: true
    expected_result?: true
    risk_level?: true
    steps?: true
    test_point_name?: true
    test_purpose?: true
    requirement_doc_id?: true
    deleted_at?: true
  }

  export type Functional_test_casesMaxAggregateInputType = {
    id?: true
    case_id?: true
    name?: true
    description?: true
    system?: true
    module?: true
    priority?: true
    tags?: true
    status?: true
    source?: true
    ai_session_id?: true
    creator_id?: true
    test_type?: true
    preconditions?: true
    test_data?: true
    section_id?: true
    section_name?: true
    scenario_name?: true
    scenario_description?: true
    batch_number?: true
    coverage_areas?: true
    created_at?: true
    updated_at?: true
    case_type?: true
    project_version_id?: true
    requirement_source?: true
    section_description?: true
    expected_result?: true
    risk_level?: true
    steps?: true
    test_point_name?: true
    test_purpose?: true
    requirement_doc_id?: true
    deleted_at?: true
  }

  export type Functional_test_casesCountAggregateInputType = {
    id?: true
    case_id?: true
    name?: true
    description?: true
    system?: true
    module?: true
    priority?: true
    tags?: true
    status?: true
    source?: true
    ai_session_id?: true
    creator_id?: true
    test_type?: true
    preconditions?: true
    test_data?: true
    section_id?: true
    section_name?: true
    scenario_name?: true
    scenario_description?: true
    batch_number?: true
    coverage_areas?: true
    created_at?: true
    updated_at?: true
    case_type?: true
    project_version_id?: true
    requirement_source?: true
    section_description?: true
    expected_result?: true
    risk_level?: true
    steps?: true
    test_point_name?: true
    test_purpose?: true
    requirement_doc_id?: true
    deleted_at?: true
    _all?: true
  }

  export type Functional_test_casesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which functional_test_cases to aggregate.
     */
    where?: functional_test_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functional_test_cases to fetch.
     */
    orderBy?: functional_test_casesOrderByWithRelationInput | functional_test_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: functional_test_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functional_test_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functional_test_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned functional_test_cases
    **/
    _count?: true | Functional_test_casesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Functional_test_casesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Functional_test_casesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Functional_test_casesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Functional_test_casesMaxAggregateInputType
  }

  export type GetFunctional_test_casesAggregateType<T extends Functional_test_casesAggregateArgs> = {
        [P in keyof T & keyof AggregateFunctional_test_cases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunctional_test_cases[P]>
      : GetScalarType<T[P], AggregateFunctional_test_cases[P]>
  }




  export type functional_test_casesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: functional_test_casesWhereInput
    orderBy?: functional_test_casesOrderByWithAggregationInput | functional_test_casesOrderByWithAggregationInput[]
    by: Functional_test_casesScalarFieldEnum[] | Functional_test_casesScalarFieldEnum
    having?: functional_test_casesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Functional_test_casesCountAggregateInputType | true
    _avg?: Functional_test_casesAvgAggregateInputType
    _sum?: Functional_test_casesSumAggregateInputType
    _min?: Functional_test_casesMinAggregateInputType
    _max?: Functional_test_casesMaxAggregateInputType
  }

  export type Functional_test_casesGroupByOutputType = {
    id: number
    case_id: string | null
    name: string
    description: string | null
    system: string | null
    module: string | null
    priority: $Enums.functional_test_priority
    tags: string | null
    status: $Enums.functional_test_status
    source: $Enums.functional_test_source
    ai_session_id: string | null
    creator_id: number
    test_type: string | null
    preconditions: string | null
    test_data: string | null
    section_id: string | null
    section_name: string | null
    scenario_name: string | null
    scenario_description: string | null
    batch_number: number | null
    coverage_areas: string | null
    created_at: Date
    updated_at: Date
    case_type: $Enums.functional_case_type
    project_version_id: number | null
    requirement_source: string | null
    section_description: string | null
    expected_result: string | null
    risk_level: $Enums.functional_risk_level
    steps: string | null
    test_point_name: string | null
    test_purpose: string | null
    requirement_doc_id: number | null
    deleted_at: Date | null
    _count: Functional_test_casesCountAggregateOutputType | null
    _avg: Functional_test_casesAvgAggregateOutputType | null
    _sum: Functional_test_casesSumAggregateOutputType | null
    _min: Functional_test_casesMinAggregateOutputType | null
    _max: Functional_test_casesMaxAggregateOutputType | null
  }

  type GetFunctional_test_casesGroupByPayload<T extends functional_test_casesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Functional_test_casesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Functional_test_casesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Functional_test_casesGroupByOutputType[P]>
            : GetScalarType<T[P], Functional_test_casesGroupByOutputType[P]>
        }
      >
    >


  export type functional_test_casesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    case_id?: boolean
    name?: boolean
    description?: boolean
    system?: boolean
    module?: boolean
    priority?: boolean
    tags?: boolean
    status?: boolean
    source?: boolean
    ai_session_id?: boolean
    creator_id?: boolean
    test_type?: boolean
    preconditions?: boolean
    test_data?: boolean
    section_id?: boolean
    section_name?: boolean
    scenario_name?: boolean
    scenario_description?: boolean
    batch_number?: boolean
    coverage_areas?: boolean
    created_at?: boolean
    updated_at?: boolean
    case_type?: boolean
    project_version_id?: boolean
    requirement_source?: boolean
    section_description?: boolean
    expected_result?: boolean
    risk_level?: boolean
    steps?: boolean
    test_point_name?: boolean
    test_purpose?: boolean
    requirement_doc_id?: boolean
    deleted_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    project_version?: boolean | functional_test_cases$project_versionArgs<ExtArgs>
    requirement_doc?: boolean | functional_test_cases$requirement_docArgs<ExtArgs>
    executions?: boolean | functional_test_cases$executionsArgs<ExtArgs>
    _count?: boolean | Functional_test_casesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["functional_test_cases"]>



  export type functional_test_casesSelectScalar = {
    id?: boolean
    case_id?: boolean
    name?: boolean
    description?: boolean
    system?: boolean
    module?: boolean
    priority?: boolean
    tags?: boolean
    status?: boolean
    source?: boolean
    ai_session_id?: boolean
    creator_id?: boolean
    test_type?: boolean
    preconditions?: boolean
    test_data?: boolean
    section_id?: boolean
    section_name?: boolean
    scenario_name?: boolean
    scenario_description?: boolean
    batch_number?: boolean
    coverage_areas?: boolean
    created_at?: boolean
    updated_at?: boolean
    case_type?: boolean
    project_version_id?: boolean
    requirement_source?: boolean
    section_description?: boolean
    expected_result?: boolean
    risk_level?: boolean
    steps?: boolean
    test_point_name?: boolean
    test_purpose?: boolean
    requirement_doc_id?: boolean
    deleted_at?: boolean
  }

  export type functional_test_casesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "case_id" | "name" | "description" | "system" | "module" | "priority" | "tags" | "status" | "source" | "ai_session_id" | "creator_id" | "test_type" | "preconditions" | "test_data" | "section_id" | "section_name" | "scenario_name" | "scenario_description" | "batch_number" | "coverage_areas" | "created_at" | "updated_at" | "case_type" | "project_version_id" | "requirement_source" | "section_description" | "expected_result" | "risk_level" | "steps" | "test_point_name" | "test_purpose" | "requirement_doc_id" | "deleted_at", ExtArgs["result"]["functional_test_cases"]>
  export type functional_test_casesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    project_version?: boolean | functional_test_cases$project_versionArgs<ExtArgs>
    requirement_doc?: boolean | functional_test_cases$requirement_docArgs<ExtArgs>
    executions?: boolean | functional_test_cases$executionsArgs<ExtArgs>
    _count?: boolean | Functional_test_casesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $functional_test_casesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "functional_test_cases"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      project_version: Prisma.$project_versionsPayload<ExtArgs> | null
      requirement_doc: Prisma.$requirement_documentsPayload<ExtArgs> | null
      executions: Prisma.$functional_test_executionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      case_id: string | null
      name: string
      description: string | null
      system: string | null
      module: string | null
      priority: $Enums.functional_test_priority
      tags: string | null
      status: $Enums.functional_test_status
      source: $Enums.functional_test_source
      ai_session_id: string | null
      creator_id: number
      test_type: string | null
      preconditions: string | null
      test_data: string | null
      section_id: string | null
      section_name: string | null
      scenario_name: string | null
      scenario_description: string | null
      batch_number: number | null
      coverage_areas: string | null
      created_at: Date
      updated_at: Date
      case_type: $Enums.functional_case_type
      project_version_id: number | null
      requirement_source: string | null
      section_description: string | null
      expected_result: string | null
      risk_level: $Enums.functional_risk_level
      steps: string | null
      test_point_name: string | null
      test_purpose: string | null
      requirement_doc_id: number | null
      deleted_at: Date | null
    }, ExtArgs["result"]["functional_test_cases"]>
    composites: {}
  }

  type functional_test_casesGetPayload<S extends boolean | null | undefined | functional_test_casesDefaultArgs> = $Result.GetResult<Prisma.$functional_test_casesPayload, S>

  type functional_test_casesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<functional_test_casesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Functional_test_casesCountAggregateInputType | true
    }

  export interface functional_test_casesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['functional_test_cases'], meta: { name: 'functional_test_cases' } }
    /**
     * Find zero or one Functional_test_cases that matches the filter.
     * @param {functional_test_casesFindUniqueArgs} args - Arguments to find a Functional_test_cases
     * @example
     * // Get one Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends functional_test_casesFindUniqueArgs>(args: SelectSubset<T, functional_test_casesFindUniqueArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Functional_test_cases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {functional_test_casesFindUniqueOrThrowArgs} args - Arguments to find a Functional_test_cases
     * @example
     * // Get one Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends functional_test_casesFindUniqueOrThrowArgs>(args: SelectSubset<T, functional_test_casesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Functional_test_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_casesFindFirstArgs} args - Arguments to find a Functional_test_cases
     * @example
     * // Get one Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends functional_test_casesFindFirstArgs>(args?: SelectSubset<T, functional_test_casesFindFirstArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Functional_test_cases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_casesFindFirstOrThrowArgs} args - Arguments to find a Functional_test_cases
     * @example
     * // Get one Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends functional_test_casesFindFirstOrThrowArgs>(args?: SelectSubset<T, functional_test_casesFindFirstOrThrowArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Functional_test_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_casesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.findMany()
     * 
     * // Get first 10 Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const functional_test_casesWithIdOnly = await prisma.functional_test_cases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends functional_test_casesFindManyArgs>(args?: SelectSubset<T, functional_test_casesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Functional_test_cases.
     * @param {functional_test_casesCreateArgs} args - Arguments to create a Functional_test_cases.
     * @example
     * // Create one Functional_test_cases
     * const Functional_test_cases = await prisma.functional_test_cases.create({
     *   data: {
     *     // ... data to create a Functional_test_cases
     *   }
     * })
     * 
     */
    create<T extends functional_test_casesCreateArgs>(args: SelectSubset<T, functional_test_casesCreateArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Functional_test_cases.
     * @param {functional_test_casesCreateManyArgs} args - Arguments to create many Functional_test_cases.
     * @example
     * // Create many Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends functional_test_casesCreateManyArgs>(args?: SelectSubset<T, functional_test_casesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Functional_test_cases.
     * @param {functional_test_casesDeleteArgs} args - Arguments to delete one Functional_test_cases.
     * @example
     * // Delete one Functional_test_cases
     * const Functional_test_cases = await prisma.functional_test_cases.delete({
     *   where: {
     *     // ... filter to delete one Functional_test_cases
     *   }
     * })
     * 
     */
    delete<T extends functional_test_casesDeleteArgs>(args: SelectSubset<T, functional_test_casesDeleteArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Functional_test_cases.
     * @param {functional_test_casesUpdateArgs} args - Arguments to update one Functional_test_cases.
     * @example
     * // Update one Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends functional_test_casesUpdateArgs>(args: SelectSubset<T, functional_test_casesUpdateArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Functional_test_cases.
     * @param {functional_test_casesDeleteManyArgs} args - Arguments to filter Functional_test_cases to delete.
     * @example
     * // Delete a few Functional_test_cases
     * const { count } = await prisma.functional_test_cases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends functional_test_casesDeleteManyArgs>(args?: SelectSubset<T, functional_test_casesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Functional_test_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_casesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends functional_test_casesUpdateManyArgs>(args: SelectSubset<T, functional_test_casesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Functional_test_cases.
     * @param {functional_test_casesUpsertArgs} args - Arguments to update or create a Functional_test_cases.
     * @example
     * // Update or create a Functional_test_cases
     * const functional_test_cases = await prisma.functional_test_cases.upsert({
     *   create: {
     *     // ... data to create a Functional_test_cases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Functional_test_cases we want to update
     *   }
     * })
     */
    upsert<T extends functional_test_casesUpsertArgs>(args: SelectSubset<T, functional_test_casesUpsertArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Functional_test_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_casesCountArgs} args - Arguments to filter Functional_test_cases to count.
     * @example
     * // Count the number of Functional_test_cases
     * const count = await prisma.functional_test_cases.count({
     *   where: {
     *     // ... the filter for the Functional_test_cases we want to count
     *   }
     * })
    **/
    count<T extends functional_test_casesCountArgs>(
      args?: Subset<T, functional_test_casesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Functional_test_casesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Functional_test_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Functional_test_casesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Functional_test_casesAggregateArgs>(args: Subset<T, Functional_test_casesAggregateArgs>): Prisma.PrismaPromise<GetFunctional_test_casesAggregateType<T>>

    /**
     * Group by Functional_test_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_casesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends functional_test_casesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: functional_test_casesGroupByArgs['orderBy'] }
        : { orderBy?: functional_test_casesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, functional_test_casesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunctional_test_casesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the functional_test_cases model
   */
  readonly fields: functional_test_casesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for functional_test_cases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__functional_test_casesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project_version<T extends functional_test_cases$project_versionArgs<ExtArgs> = {}>(args?: Subset<T, functional_test_cases$project_versionArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requirement_doc<T extends functional_test_cases$requirement_docArgs<ExtArgs> = {}>(args?: Subset<T, functional_test_cases$requirement_docArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    executions<T extends functional_test_cases$executionsArgs<ExtArgs> = {}>(args?: Subset<T, functional_test_cases$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the functional_test_cases model
   */
  interface functional_test_casesFieldRefs {
    readonly id: FieldRef<"functional_test_cases", 'Int'>
    readonly case_id: FieldRef<"functional_test_cases", 'String'>
    readonly name: FieldRef<"functional_test_cases", 'String'>
    readonly description: FieldRef<"functional_test_cases", 'String'>
    readonly system: FieldRef<"functional_test_cases", 'String'>
    readonly module: FieldRef<"functional_test_cases", 'String'>
    readonly priority: FieldRef<"functional_test_cases", 'functional_test_priority'>
    readonly tags: FieldRef<"functional_test_cases", 'String'>
    readonly status: FieldRef<"functional_test_cases", 'functional_test_status'>
    readonly source: FieldRef<"functional_test_cases", 'functional_test_source'>
    readonly ai_session_id: FieldRef<"functional_test_cases", 'String'>
    readonly creator_id: FieldRef<"functional_test_cases", 'Int'>
    readonly test_type: FieldRef<"functional_test_cases", 'String'>
    readonly preconditions: FieldRef<"functional_test_cases", 'String'>
    readonly test_data: FieldRef<"functional_test_cases", 'String'>
    readonly section_id: FieldRef<"functional_test_cases", 'String'>
    readonly section_name: FieldRef<"functional_test_cases", 'String'>
    readonly scenario_name: FieldRef<"functional_test_cases", 'String'>
    readonly scenario_description: FieldRef<"functional_test_cases", 'String'>
    readonly batch_number: FieldRef<"functional_test_cases", 'Int'>
    readonly coverage_areas: FieldRef<"functional_test_cases", 'String'>
    readonly created_at: FieldRef<"functional_test_cases", 'DateTime'>
    readonly updated_at: FieldRef<"functional_test_cases", 'DateTime'>
    readonly case_type: FieldRef<"functional_test_cases", 'functional_case_type'>
    readonly project_version_id: FieldRef<"functional_test_cases", 'Int'>
    readonly requirement_source: FieldRef<"functional_test_cases", 'String'>
    readonly section_description: FieldRef<"functional_test_cases", 'String'>
    readonly expected_result: FieldRef<"functional_test_cases", 'String'>
    readonly risk_level: FieldRef<"functional_test_cases", 'functional_risk_level'>
    readonly steps: FieldRef<"functional_test_cases", 'String'>
    readonly test_point_name: FieldRef<"functional_test_cases", 'String'>
    readonly test_purpose: FieldRef<"functional_test_cases", 'String'>
    readonly requirement_doc_id: FieldRef<"functional_test_cases", 'Int'>
    readonly deleted_at: FieldRef<"functional_test_cases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * functional_test_cases findUnique
   */
  export type functional_test_casesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_cases to fetch.
     */
    where: functional_test_casesWhereUniqueInput
  }

  /**
   * functional_test_cases findUniqueOrThrow
   */
  export type functional_test_casesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_cases to fetch.
     */
    where: functional_test_casesWhereUniqueInput
  }

  /**
   * functional_test_cases findFirst
   */
  export type functional_test_casesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_cases to fetch.
     */
    where?: functional_test_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functional_test_cases to fetch.
     */
    orderBy?: functional_test_casesOrderByWithRelationInput | functional_test_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for functional_test_cases.
     */
    cursor?: functional_test_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functional_test_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functional_test_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of functional_test_cases.
     */
    distinct?: Functional_test_casesScalarFieldEnum | Functional_test_casesScalarFieldEnum[]
  }

  /**
   * functional_test_cases findFirstOrThrow
   */
  export type functional_test_casesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_cases to fetch.
     */
    where?: functional_test_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functional_test_cases to fetch.
     */
    orderBy?: functional_test_casesOrderByWithRelationInput | functional_test_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for functional_test_cases.
     */
    cursor?: functional_test_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functional_test_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functional_test_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of functional_test_cases.
     */
    distinct?: Functional_test_casesScalarFieldEnum | Functional_test_casesScalarFieldEnum[]
  }

  /**
   * functional_test_cases findMany
   */
  export type functional_test_casesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_cases to fetch.
     */
    where?: functional_test_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functional_test_cases to fetch.
     */
    orderBy?: functional_test_casesOrderByWithRelationInput | functional_test_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing functional_test_cases.
     */
    cursor?: functional_test_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functional_test_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functional_test_cases.
     */
    skip?: number
    distinct?: Functional_test_casesScalarFieldEnum | Functional_test_casesScalarFieldEnum[]
  }

  /**
   * functional_test_cases create
   */
  export type functional_test_casesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * The data needed to create a functional_test_cases.
     */
    data: XOR<functional_test_casesCreateInput, functional_test_casesUncheckedCreateInput>
  }

  /**
   * functional_test_cases createMany
   */
  export type functional_test_casesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many functional_test_cases.
     */
    data: functional_test_casesCreateManyInput | functional_test_casesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * functional_test_cases update
   */
  export type functional_test_casesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * The data needed to update a functional_test_cases.
     */
    data: XOR<functional_test_casesUpdateInput, functional_test_casesUncheckedUpdateInput>
    /**
     * Choose, which functional_test_cases to update.
     */
    where: functional_test_casesWhereUniqueInput
  }

  /**
   * functional_test_cases updateMany
   */
  export type functional_test_casesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update functional_test_cases.
     */
    data: XOR<functional_test_casesUpdateManyMutationInput, functional_test_casesUncheckedUpdateManyInput>
    /**
     * Filter which functional_test_cases to update
     */
    where?: functional_test_casesWhereInput
    /**
     * Limit how many functional_test_cases to update.
     */
    limit?: number
  }

  /**
   * functional_test_cases upsert
   */
  export type functional_test_casesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * The filter to search for the functional_test_cases to update in case it exists.
     */
    where: functional_test_casesWhereUniqueInput
    /**
     * In case the functional_test_cases found by the `where` argument doesn't exist, create a new functional_test_cases with this data.
     */
    create: XOR<functional_test_casesCreateInput, functional_test_casesUncheckedCreateInput>
    /**
     * In case the functional_test_cases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<functional_test_casesUpdateInput, functional_test_casesUncheckedUpdateInput>
  }

  /**
   * functional_test_cases delete
   */
  export type functional_test_casesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    /**
     * Filter which functional_test_cases to delete.
     */
    where: functional_test_casesWhereUniqueInput
  }

  /**
   * functional_test_cases deleteMany
   */
  export type functional_test_casesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which functional_test_cases to delete
     */
    where?: functional_test_casesWhereInput
    /**
     * Limit how many functional_test_cases to delete.
     */
    limit?: number
  }

  /**
   * functional_test_cases.project_version
   */
  export type functional_test_cases$project_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    where?: project_versionsWhereInput
  }

  /**
   * functional_test_cases.requirement_doc
   */
  export type functional_test_cases$requirement_docArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    where?: requirement_documentsWhereInput
  }

  /**
   * functional_test_cases.executions
   */
  export type functional_test_cases$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    where?: functional_test_executionsWhereInput
    orderBy?: functional_test_executionsOrderByWithRelationInput | functional_test_executionsOrderByWithRelationInput[]
    cursor?: functional_test_executionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Functional_test_executionsScalarFieldEnum | Functional_test_executionsScalarFieldEnum[]
  }

  /**
   * functional_test_cases without action
   */
  export type functional_test_casesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
  }


  /**
   * Model ai_generation_sessions
   */

  export type AggregateAi_generation_sessions = {
    _count: Ai_generation_sessionsCountAggregateOutputType | null
    _avg: Ai_generation_sessionsAvgAggregateOutputType | null
    _sum: Ai_generation_sessionsSumAggregateOutputType | null
    _min: Ai_generation_sessionsMinAggregateOutputType | null
    _max: Ai_generation_sessionsMaxAggregateOutputType | null
  }

  export type Ai_generation_sessionsAvgAggregateOutputType = {
    user_id: number | null
    axure_file_size: number | null
    page_count: number | null
    element_count: number | null
    interaction_count: number | null
    total_generated: number | null
    total_saved: number | null
  }

  export type Ai_generation_sessionsSumAggregateOutputType = {
    user_id: number | null
    axure_file_size: number | null
    page_count: number | null
    element_count: number | null
    interaction_count: number | null
    total_generated: number | null
    total_saved: number | null
  }

  export type Ai_generation_sessionsMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    axure_filename: string | null
    axure_file_size: number | null
    project_name: string | null
    system_type: string | null
    business_domain: string | null
    requirement_doc: string | null
    page_count: number | null
    element_count: number | null
    interaction_count: number | null
    total_generated: number | null
    total_saved: number | null
    created_at: Date | null
  }

  export type Ai_generation_sessionsMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    axure_filename: string | null
    axure_file_size: number | null
    project_name: string | null
    system_type: string | null
    business_domain: string | null
    requirement_doc: string | null
    page_count: number | null
    element_count: number | null
    interaction_count: number | null
    total_generated: number | null
    total_saved: number | null
    created_at: Date | null
  }

  export type Ai_generation_sessionsCountAggregateOutputType = {
    id: number
    user_id: number
    axure_filename: number
    axure_file_size: number
    project_name: number
    system_type: number
    business_domain: number
    requirement_doc: number
    page_count: number
    element_count: number
    interaction_count: number
    total_generated: number
    total_saved: number
    batches: number
    pre_analysis_result: number
    enhanced_data: number
    created_at: number
    _all: number
  }


  export type Ai_generation_sessionsAvgAggregateInputType = {
    user_id?: true
    axure_file_size?: true
    page_count?: true
    element_count?: true
    interaction_count?: true
    total_generated?: true
    total_saved?: true
  }

  export type Ai_generation_sessionsSumAggregateInputType = {
    user_id?: true
    axure_file_size?: true
    page_count?: true
    element_count?: true
    interaction_count?: true
    total_generated?: true
    total_saved?: true
  }

  export type Ai_generation_sessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    axure_filename?: true
    axure_file_size?: true
    project_name?: true
    system_type?: true
    business_domain?: true
    requirement_doc?: true
    page_count?: true
    element_count?: true
    interaction_count?: true
    total_generated?: true
    total_saved?: true
    created_at?: true
  }

  export type Ai_generation_sessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    axure_filename?: true
    axure_file_size?: true
    project_name?: true
    system_type?: true
    business_domain?: true
    requirement_doc?: true
    page_count?: true
    element_count?: true
    interaction_count?: true
    total_generated?: true
    total_saved?: true
    created_at?: true
  }

  export type Ai_generation_sessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    axure_filename?: true
    axure_file_size?: true
    project_name?: true
    system_type?: true
    business_domain?: true
    requirement_doc?: true
    page_count?: true
    element_count?: true
    interaction_count?: true
    total_generated?: true
    total_saved?: true
    batches?: true
    pre_analysis_result?: true
    enhanced_data?: true
    created_at?: true
    _all?: true
  }

  export type Ai_generation_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_generation_sessions to aggregate.
     */
    where?: ai_generation_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_generation_sessions to fetch.
     */
    orderBy?: ai_generation_sessionsOrderByWithRelationInput | ai_generation_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_generation_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_generation_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_generation_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_generation_sessions
    **/
    _count?: true | Ai_generation_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_generation_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_generation_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_generation_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_generation_sessionsMaxAggregateInputType
  }

  export type GetAi_generation_sessionsAggregateType<T extends Ai_generation_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_generation_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_generation_sessions[P]>
      : GetScalarType<T[P], AggregateAi_generation_sessions[P]>
  }




  export type ai_generation_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_generation_sessionsWhereInput
    orderBy?: ai_generation_sessionsOrderByWithAggregationInput | ai_generation_sessionsOrderByWithAggregationInput[]
    by: Ai_generation_sessionsScalarFieldEnum[] | Ai_generation_sessionsScalarFieldEnum
    having?: ai_generation_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_generation_sessionsCountAggregateInputType | true
    _avg?: Ai_generation_sessionsAvgAggregateInputType
    _sum?: Ai_generation_sessionsSumAggregateInputType
    _min?: Ai_generation_sessionsMinAggregateInputType
    _max?: Ai_generation_sessionsMaxAggregateInputType
  }

  export type Ai_generation_sessionsGroupByOutputType = {
    id: string
    user_id: number
    axure_filename: string
    axure_file_size: number
    project_name: string | null
    system_type: string | null
    business_domain: string | null
    requirement_doc: string | null
    page_count: number
    element_count: number
    interaction_count: number
    total_generated: number
    total_saved: number
    batches: JsonValue | null
    pre_analysis_result: JsonValue | null
    enhanced_data: JsonValue | null
    created_at: Date
    _count: Ai_generation_sessionsCountAggregateOutputType | null
    _avg: Ai_generation_sessionsAvgAggregateOutputType | null
    _sum: Ai_generation_sessionsSumAggregateOutputType | null
    _min: Ai_generation_sessionsMinAggregateOutputType | null
    _max: Ai_generation_sessionsMaxAggregateOutputType | null
  }

  type GetAi_generation_sessionsGroupByPayload<T extends ai_generation_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_generation_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_generation_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_generation_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_generation_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type ai_generation_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    axure_filename?: boolean
    axure_file_size?: boolean
    project_name?: boolean
    system_type?: boolean
    business_domain?: boolean
    requirement_doc?: boolean
    page_count?: boolean
    element_count?: boolean
    interaction_count?: boolean
    total_generated?: boolean
    total_saved?: boolean
    batches?: boolean
    pre_analysis_result?: boolean
    enhanced_data?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    requirement_documents?: boolean | ai_generation_sessions$requirement_documentsArgs<ExtArgs>
    _count?: boolean | Ai_generation_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_generation_sessions"]>



  export type ai_generation_sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    axure_filename?: boolean
    axure_file_size?: boolean
    project_name?: boolean
    system_type?: boolean
    business_domain?: boolean
    requirement_doc?: boolean
    page_count?: boolean
    element_count?: boolean
    interaction_count?: boolean
    total_generated?: boolean
    total_saved?: boolean
    batches?: boolean
    pre_analysis_result?: boolean
    enhanced_data?: boolean
    created_at?: boolean
  }

  export type ai_generation_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "axure_filename" | "axure_file_size" | "project_name" | "system_type" | "business_domain" | "requirement_doc" | "page_count" | "element_count" | "interaction_count" | "total_generated" | "total_saved" | "batches" | "pre_analysis_result" | "enhanced_data" | "created_at", ExtArgs["result"]["ai_generation_sessions"]>
  export type ai_generation_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    requirement_documents?: boolean | ai_generation_sessions$requirement_documentsArgs<ExtArgs>
    _count?: boolean | Ai_generation_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ai_generation_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_generation_sessions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      requirement_documents: Prisma.$requirement_documentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      axure_filename: string
      axure_file_size: number
      project_name: string | null
      system_type: string | null
      business_domain: string | null
      requirement_doc: string | null
      page_count: number
      element_count: number
      interaction_count: number
      total_generated: number
      total_saved: number
      batches: Prisma.JsonValue | null
      pre_analysis_result: Prisma.JsonValue | null
      enhanced_data: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["ai_generation_sessions"]>
    composites: {}
  }

  type ai_generation_sessionsGetPayload<S extends boolean | null | undefined | ai_generation_sessionsDefaultArgs> = $Result.GetResult<Prisma.$ai_generation_sessionsPayload, S>

  type ai_generation_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_generation_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_generation_sessionsCountAggregateInputType | true
    }

  export interface ai_generation_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_generation_sessions'], meta: { name: 'ai_generation_sessions' } }
    /**
     * Find zero or one Ai_generation_sessions that matches the filter.
     * @param {ai_generation_sessionsFindUniqueArgs} args - Arguments to find a Ai_generation_sessions
     * @example
     * // Get one Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_generation_sessionsFindUniqueArgs>(args: SelectSubset<T, ai_generation_sessionsFindUniqueArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_generation_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_generation_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Ai_generation_sessions
     * @example
     * // Get one Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_generation_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_generation_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_generation_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_generation_sessionsFindFirstArgs} args - Arguments to find a Ai_generation_sessions
     * @example
     * // Get one Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_generation_sessionsFindFirstArgs>(args?: SelectSubset<T, ai_generation_sessionsFindFirstArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_generation_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_generation_sessionsFindFirstOrThrowArgs} args - Arguments to find a Ai_generation_sessions
     * @example
     * // Get one Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_generation_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_generation_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_generation_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_generation_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.findMany()
     * 
     * // Get first 10 Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_generation_sessionsWithIdOnly = await prisma.ai_generation_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_generation_sessionsFindManyArgs>(args?: SelectSubset<T, ai_generation_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_generation_sessions.
     * @param {ai_generation_sessionsCreateArgs} args - Arguments to create a Ai_generation_sessions.
     * @example
     * // Create one Ai_generation_sessions
     * const Ai_generation_sessions = await prisma.ai_generation_sessions.create({
     *   data: {
     *     // ... data to create a Ai_generation_sessions
     *   }
     * })
     * 
     */
    create<T extends ai_generation_sessionsCreateArgs>(args: SelectSubset<T, ai_generation_sessionsCreateArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_generation_sessions.
     * @param {ai_generation_sessionsCreateManyArgs} args - Arguments to create many Ai_generation_sessions.
     * @example
     * // Create many Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_generation_sessionsCreateManyArgs>(args?: SelectSubset<T, ai_generation_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ai_generation_sessions.
     * @param {ai_generation_sessionsDeleteArgs} args - Arguments to delete one Ai_generation_sessions.
     * @example
     * // Delete one Ai_generation_sessions
     * const Ai_generation_sessions = await prisma.ai_generation_sessions.delete({
     *   where: {
     *     // ... filter to delete one Ai_generation_sessions
     *   }
     * })
     * 
     */
    delete<T extends ai_generation_sessionsDeleteArgs>(args: SelectSubset<T, ai_generation_sessionsDeleteArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_generation_sessions.
     * @param {ai_generation_sessionsUpdateArgs} args - Arguments to update one Ai_generation_sessions.
     * @example
     * // Update one Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_generation_sessionsUpdateArgs>(args: SelectSubset<T, ai_generation_sessionsUpdateArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_generation_sessions.
     * @param {ai_generation_sessionsDeleteManyArgs} args - Arguments to filter Ai_generation_sessions to delete.
     * @example
     * // Delete a few Ai_generation_sessions
     * const { count } = await prisma.ai_generation_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_generation_sessionsDeleteManyArgs>(args?: SelectSubset<T, ai_generation_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_generation_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_generation_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_generation_sessionsUpdateManyArgs>(args: SelectSubset<T, ai_generation_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_generation_sessions.
     * @param {ai_generation_sessionsUpsertArgs} args - Arguments to update or create a Ai_generation_sessions.
     * @example
     * // Update or create a Ai_generation_sessions
     * const ai_generation_sessions = await prisma.ai_generation_sessions.upsert({
     *   create: {
     *     // ... data to create a Ai_generation_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_generation_sessions we want to update
     *   }
     * })
     */
    upsert<T extends ai_generation_sessionsUpsertArgs>(args: SelectSubset<T, ai_generation_sessionsUpsertArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_generation_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_generation_sessionsCountArgs} args - Arguments to filter Ai_generation_sessions to count.
     * @example
     * // Count the number of Ai_generation_sessions
     * const count = await prisma.ai_generation_sessions.count({
     *   where: {
     *     // ... the filter for the Ai_generation_sessions we want to count
     *   }
     * })
    **/
    count<T extends ai_generation_sessionsCountArgs>(
      args?: Subset<T, ai_generation_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_generation_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_generation_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_generation_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_generation_sessionsAggregateArgs>(args: Subset<T, Ai_generation_sessionsAggregateArgs>): Prisma.PrismaPromise<GetAi_generation_sessionsAggregateType<T>>

    /**
     * Group by Ai_generation_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_generation_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_generation_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_generation_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: ai_generation_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_generation_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_generation_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_generation_sessions model
   */
  readonly fields: ai_generation_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_generation_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_generation_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirement_documents<T extends ai_generation_sessions$requirement_documentsArgs<ExtArgs> = {}>(args?: Subset<T, ai_generation_sessions$requirement_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_generation_sessions model
   */
  interface ai_generation_sessionsFieldRefs {
    readonly id: FieldRef<"ai_generation_sessions", 'String'>
    readonly user_id: FieldRef<"ai_generation_sessions", 'Int'>
    readonly axure_filename: FieldRef<"ai_generation_sessions", 'String'>
    readonly axure_file_size: FieldRef<"ai_generation_sessions", 'Int'>
    readonly project_name: FieldRef<"ai_generation_sessions", 'String'>
    readonly system_type: FieldRef<"ai_generation_sessions", 'String'>
    readonly business_domain: FieldRef<"ai_generation_sessions", 'String'>
    readonly requirement_doc: FieldRef<"ai_generation_sessions", 'String'>
    readonly page_count: FieldRef<"ai_generation_sessions", 'Int'>
    readonly element_count: FieldRef<"ai_generation_sessions", 'Int'>
    readonly interaction_count: FieldRef<"ai_generation_sessions", 'Int'>
    readonly total_generated: FieldRef<"ai_generation_sessions", 'Int'>
    readonly total_saved: FieldRef<"ai_generation_sessions", 'Int'>
    readonly batches: FieldRef<"ai_generation_sessions", 'Json'>
    readonly pre_analysis_result: FieldRef<"ai_generation_sessions", 'Json'>
    readonly enhanced_data: FieldRef<"ai_generation_sessions", 'Json'>
    readonly created_at: FieldRef<"ai_generation_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_generation_sessions findUnique
   */
  export type ai_generation_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_generation_sessions to fetch.
     */
    where: ai_generation_sessionsWhereUniqueInput
  }

  /**
   * ai_generation_sessions findUniqueOrThrow
   */
  export type ai_generation_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_generation_sessions to fetch.
     */
    where: ai_generation_sessionsWhereUniqueInput
  }

  /**
   * ai_generation_sessions findFirst
   */
  export type ai_generation_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_generation_sessions to fetch.
     */
    where?: ai_generation_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_generation_sessions to fetch.
     */
    orderBy?: ai_generation_sessionsOrderByWithRelationInput | ai_generation_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_generation_sessions.
     */
    cursor?: ai_generation_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_generation_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_generation_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_generation_sessions.
     */
    distinct?: Ai_generation_sessionsScalarFieldEnum | Ai_generation_sessionsScalarFieldEnum[]
  }

  /**
   * ai_generation_sessions findFirstOrThrow
   */
  export type ai_generation_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_generation_sessions to fetch.
     */
    where?: ai_generation_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_generation_sessions to fetch.
     */
    orderBy?: ai_generation_sessionsOrderByWithRelationInput | ai_generation_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_generation_sessions.
     */
    cursor?: ai_generation_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_generation_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_generation_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_generation_sessions.
     */
    distinct?: Ai_generation_sessionsScalarFieldEnum | Ai_generation_sessionsScalarFieldEnum[]
  }

  /**
   * ai_generation_sessions findMany
   */
  export type ai_generation_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which ai_generation_sessions to fetch.
     */
    where?: ai_generation_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_generation_sessions to fetch.
     */
    orderBy?: ai_generation_sessionsOrderByWithRelationInput | ai_generation_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_generation_sessions.
     */
    cursor?: ai_generation_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_generation_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_generation_sessions.
     */
    skip?: number
    distinct?: Ai_generation_sessionsScalarFieldEnum | Ai_generation_sessionsScalarFieldEnum[]
  }

  /**
   * ai_generation_sessions create
   */
  export type ai_generation_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_generation_sessions.
     */
    data: XOR<ai_generation_sessionsCreateInput, ai_generation_sessionsUncheckedCreateInput>
  }

  /**
   * ai_generation_sessions createMany
   */
  export type ai_generation_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_generation_sessions.
     */
    data: ai_generation_sessionsCreateManyInput | ai_generation_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_generation_sessions update
   */
  export type ai_generation_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_generation_sessions.
     */
    data: XOR<ai_generation_sessionsUpdateInput, ai_generation_sessionsUncheckedUpdateInput>
    /**
     * Choose, which ai_generation_sessions to update.
     */
    where: ai_generation_sessionsWhereUniqueInput
  }

  /**
   * ai_generation_sessions updateMany
   */
  export type ai_generation_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_generation_sessions.
     */
    data: XOR<ai_generation_sessionsUpdateManyMutationInput, ai_generation_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which ai_generation_sessions to update
     */
    where?: ai_generation_sessionsWhereInput
    /**
     * Limit how many ai_generation_sessions to update.
     */
    limit?: number
  }

  /**
   * ai_generation_sessions upsert
   */
  export type ai_generation_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_generation_sessions to update in case it exists.
     */
    where: ai_generation_sessionsWhereUniqueInput
    /**
     * In case the ai_generation_sessions found by the `where` argument doesn't exist, create a new ai_generation_sessions with this data.
     */
    create: XOR<ai_generation_sessionsCreateInput, ai_generation_sessionsUncheckedCreateInput>
    /**
     * In case the ai_generation_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_generation_sessionsUpdateInput, ai_generation_sessionsUncheckedUpdateInput>
  }

  /**
   * ai_generation_sessions delete
   */
  export type ai_generation_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    /**
     * Filter which ai_generation_sessions to delete.
     */
    where: ai_generation_sessionsWhereUniqueInput
  }

  /**
   * ai_generation_sessions deleteMany
   */
  export type ai_generation_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_generation_sessions to delete
     */
    where?: ai_generation_sessionsWhereInput
    /**
     * Limit how many ai_generation_sessions to delete.
     */
    limit?: number
  }

  /**
   * ai_generation_sessions.requirement_documents
   */
  export type ai_generation_sessions$requirement_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    where?: requirement_documentsWhereInput
    orderBy?: requirement_documentsOrderByWithRelationInput | requirement_documentsOrderByWithRelationInput[]
    cursor?: requirement_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Requirement_documentsScalarFieldEnum | Requirement_documentsScalarFieldEnum[]
  }

  /**
   * ai_generation_sessions without action
   */
  export type ai_generation_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model requirement_documents
   */

  export type AggregateRequirement_documents = {
    _count: Requirement_documentsCountAggregateOutputType | null
    _avg: Requirement_documentsAvgAggregateOutputType | null
    _sum: Requirement_documentsSumAggregateOutputType | null
    _min: Requirement_documentsMinAggregateOutputType | null
    _max: Requirement_documentsMaxAggregateOutputType | null
  }

  export type Requirement_documentsAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
    project_version_id: number | null
    creator_id: number | null
    scenario_count: number | null
    test_case_count: number | null
  }

  export type Requirement_documentsSumAggregateOutputType = {
    id: number | null
    project_id: number | null
    project_version_id: number | null
    creator_id: number | null
    scenario_count: number | null
    test_case_count: number | null
  }

  export type Requirement_documentsMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    summary: string | null
    source_filename: string | null
    ai_session_id: string | null
    project_id: number | null
    project_version_id: number | null
    creator_id: number | null
    scenario_count: number | null
    test_case_count: number | null
    status: $Enums.requirement_doc_status | null
    created_at: Date | null
    updated_at: Date | null
    module: string | null
    system: string | null
  }

  export type Requirement_documentsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    summary: string | null
    source_filename: string | null
    ai_session_id: string | null
    project_id: number | null
    project_version_id: number | null
    creator_id: number | null
    scenario_count: number | null
    test_case_count: number | null
    status: $Enums.requirement_doc_status | null
    created_at: Date | null
    updated_at: Date | null
    module: string | null
    system: string | null
  }

  export type Requirement_documentsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    summary: number
    source_filename: number
    ai_session_id: number
    project_id: number
    project_version_id: number
    creator_id: number
    scenario_count: number
    test_case_count: number
    status: number
    created_at: number
    updated_at: number
    module: number
    system: number
    _all: number
  }


  export type Requirement_documentsAvgAggregateInputType = {
    id?: true
    project_id?: true
    project_version_id?: true
    creator_id?: true
    scenario_count?: true
    test_case_count?: true
  }

  export type Requirement_documentsSumAggregateInputType = {
    id?: true
    project_id?: true
    project_version_id?: true
    creator_id?: true
    scenario_count?: true
    test_case_count?: true
  }

  export type Requirement_documentsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    summary?: true
    source_filename?: true
    ai_session_id?: true
    project_id?: true
    project_version_id?: true
    creator_id?: true
    scenario_count?: true
    test_case_count?: true
    status?: true
    created_at?: true
    updated_at?: true
    module?: true
    system?: true
  }

  export type Requirement_documentsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    summary?: true
    source_filename?: true
    ai_session_id?: true
    project_id?: true
    project_version_id?: true
    creator_id?: true
    scenario_count?: true
    test_case_count?: true
    status?: true
    created_at?: true
    updated_at?: true
    module?: true
    system?: true
  }

  export type Requirement_documentsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    summary?: true
    source_filename?: true
    ai_session_id?: true
    project_id?: true
    project_version_id?: true
    creator_id?: true
    scenario_count?: true
    test_case_count?: true
    status?: true
    created_at?: true
    updated_at?: true
    module?: true
    system?: true
    _all?: true
  }

  export type Requirement_documentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requirement_documents to aggregate.
     */
    where?: requirement_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requirement_documents to fetch.
     */
    orderBy?: requirement_documentsOrderByWithRelationInput | requirement_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: requirement_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requirement_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requirement_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requirement_documents
    **/
    _count?: true | Requirement_documentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Requirement_documentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Requirement_documentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Requirement_documentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Requirement_documentsMaxAggregateInputType
  }

  export type GetRequirement_documentsAggregateType<T extends Requirement_documentsAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirement_documents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirement_documents[P]>
      : GetScalarType<T[P], AggregateRequirement_documents[P]>
  }




  export type requirement_documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requirement_documentsWhereInput
    orderBy?: requirement_documentsOrderByWithAggregationInput | requirement_documentsOrderByWithAggregationInput[]
    by: Requirement_documentsScalarFieldEnum[] | Requirement_documentsScalarFieldEnum
    having?: requirement_documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Requirement_documentsCountAggregateInputType | true
    _avg?: Requirement_documentsAvgAggregateInputType
    _sum?: Requirement_documentsSumAggregateInputType
    _min?: Requirement_documentsMinAggregateInputType
    _max?: Requirement_documentsMaxAggregateInputType
  }

  export type Requirement_documentsGroupByOutputType = {
    id: number
    title: string
    content: string
    summary: string | null
    source_filename: string | null
    ai_session_id: string | null
    project_id: number | null
    project_version_id: number | null
    creator_id: number
    scenario_count: number
    test_case_count: number
    status: $Enums.requirement_doc_status
    created_at: Date
    updated_at: Date
    module: string | null
    system: string | null
    _count: Requirement_documentsCountAggregateOutputType | null
    _avg: Requirement_documentsAvgAggregateOutputType | null
    _sum: Requirement_documentsSumAggregateOutputType | null
    _min: Requirement_documentsMinAggregateOutputType | null
    _max: Requirement_documentsMaxAggregateOutputType | null
  }

  type GetRequirement_documentsGroupByPayload<T extends requirement_documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Requirement_documentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Requirement_documentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Requirement_documentsGroupByOutputType[P]>
            : GetScalarType<T[P], Requirement_documentsGroupByOutputType[P]>
        }
      >
    >


  export type requirement_documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    source_filename?: boolean
    ai_session_id?: boolean
    project_id?: boolean
    project_version_id?: boolean
    creator_id?: boolean
    scenario_count?: boolean
    test_case_count?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    module?: boolean
    system?: boolean
    test_cases?: boolean | requirement_documents$test_casesArgs<ExtArgs>
    ai_session?: boolean | requirement_documents$ai_sessionArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    project?: boolean | requirement_documents$projectArgs<ExtArgs>
    project_version?: boolean | requirement_documents$project_versionArgs<ExtArgs>
    _count?: boolean | Requirement_documentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement_documents"]>



  export type requirement_documentsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    source_filename?: boolean
    ai_session_id?: boolean
    project_id?: boolean
    project_version_id?: boolean
    creator_id?: boolean
    scenario_count?: boolean
    test_case_count?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    module?: boolean
    system?: boolean
  }

  export type requirement_documentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "summary" | "source_filename" | "ai_session_id" | "project_id" | "project_version_id" | "creator_id" | "scenario_count" | "test_case_count" | "status" | "created_at" | "updated_at" | "module" | "system", ExtArgs["result"]["requirement_documents"]>
  export type requirement_documentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_cases?: boolean | requirement_documents$test_casesArgs<ExtArgs>
    ai_session?: boolean | requirement_documents$ai_sessionArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    project?: boolean | requirement_documents$projectArgs<ExtArgs>
    project_version?: boolean | requirement_documents$project_versionArgs<ExtArgs>
    _count?: boolean | Requirement_documentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $requirement_documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "requirement_documents"
    objects: {
      test_cases: Prisma.$functional_test_casesPayload<ExtArgs>[]
      ai_session: Prisma.$ai_generation_sessionsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      project: Prisma.$systemsPayload<ExtArgs> | null
      project_version: Prisma.$project_versionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      summary: string | null
      source_filename: string | null
      ai_session_id: string | null
      project_id: number | null
      project_version_id: number | null
      creator_id: number
      scenario_count: number
      test_case_count: number
      status: $Enums.requirement_doc_status
      created_at: Date
      updated_at: Date
      module: string | null
      system: string | null
    }, ExtArgs["result"]["requirement_documents"]>
    composites: {}
  }

  type requirement_documentsGetPayload<S extends boolean | null | undefined | requirement_documentsDefaultArgs> = $Result.GetResult<Prisma.$requirement_documentsPayload, S>

  type requirement_documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<requirement_documentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Requirement_documentsCountAggregateInputType | true
    }

  export interface requirement_documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['requirement_documents'], meta: { name: 'requirement_documents' } }
    /**
     * Find zero or one Requirement_documents that matches the filter.
     * @param {requirement_documentsFindUniqueArgs} args - Arguments to find a Requirement_documents
     * @example
     * // Get one Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends requirement_documentsFindUniqueArgs>(args: SelectSubset<T, requirement_documentsFindUniqueArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requirement_documents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {requirement_documentsFindUniqueOrThrowArgs} args - Arguments to find a Requirement_documents
     * @example
     * // Get one Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends requirement_documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, requirement_documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirement_documentsFindFirstArgs} args - Arguments to find a Requirement_documents
     * @example
     * // Get one Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends requirement_documentsFindFirstArgs>(args?: SelectSubset<T, requirement_documentsFindFirstArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement_documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirement_documentsFindFirstOrThrowArgs} args - Arguments to find a Requirement_documents
     * @example
     * // Get one Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends requirement_documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, requirement_documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requirement_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirement_documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.findMany()
     * 
     * // Get first 10 Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirement_documentsWithIdOnly = await prisma.requirement_documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends requirement_documentsFindManyArgs>(args?: SelectSubset<T, requirement_documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requirement_documents.
     * @param {requirement_documentsCreateArgs} args - Arguments to create a Requirement_documents.
     * @example
     * // Create one Requirement_documents
     * const Requirement_documents = await prisma.requirement_documents.create({
     *   data: {
     *     // ... data to create a Requirement_documents
     *   }
     * })
     * 
     */
    create<T extends requirement_documentsCreateArgs>(args: SelectSubset<T, requirement_documentsCreateArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requirement_documents.
     * @param {requirement_documentsCreateManyArgs} args - Arguments to create many Requirement_documents.
     * @example
     * // Create many Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends requirement_documentsCreateManyArgs>(args?: SelectSubset<T, requirement_documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Requirement_documents.
     * @param {requirement_documentsDeleteArgs} args - Arguments to delete one Requirement_documents.
     * @example
     * // Delete one Requirement_documents
     * const Requirement_documents = await prisma.requirement_documents.delete({
     *   where: {
     *     // ... filter to delete one Requirement_documents
     *   }
     * })
     * 
     */
    delete<T extends requirement_documentsDeleteArgs>(args: SelectSubset<T, requirement_documentsDeleteArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requirement_documents.
     * @param {requirement_documentsUpdateArgs} args - Arguments to update one Requirement_documents.
     * @example
     * // Update one Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends requirement_documentsUpdateArgs>(args: SelectSubset<T, requirement_documentsUpdateArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requirement_documents.
     * @param {requirement_documentsDeleteManyArgs} args - Arguments to filter Requirement_documents to delete.
     * @example
     * // Delete a few Requirement_documents
     * const { count } = await prisma.requirement_documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends requirement_documentsDeleteManyArgs>(args?: SelectSubset<T, requirement_documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirement_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirement_documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends requirement_documentsUpdateManyArgs>(args: SelectSubset<T, requirement_documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Requirement_documents.
     * @param {requirement_documentsUpsertArgs} args - Arguments to update or create a Requirement_documents.
     * @example
     * // Update or create a Requirement_documents
     * const requirement_documents = await prisma.requirement_documents.upsert({
     *   create: {
     *     // ... data to create a Requirement_documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requirement_documents we want to update
     *   }
     * })
     */
    upsert<T extends requirement_documentsUpsertArgs>(args: SelectSubset<T, requirement_documentsUpsertArgs<ExtArgs>>): Prisma__requirement_documentsClient<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requirement_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirement_documentsCountArgs} args - Arguments to filter Requirement_documents to count.
     * @example
     * // Count the number of Requirement_documents
     * const count = await prisma.requirement_documents.count({
     *   where: {
     *     // ... the filter for the Requirement_documents we want to count
     *   }
     * })
    **/
    count<T extends requirement_documentsCountArgs>(
      args?: Subset<T, requirement_documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Requirement_documentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requirement_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Requirement_documentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Requirement_documentsAggregateArgs>(args: Subset<T, Requirement_documentsAggregateArgs>): Prisma.PrismaPromise<GetRequirement_documentsAggregateType<T>>

    /**
     * Group by Requirement_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirement_documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends requirement_documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: requirement_documentsGroupByArgs['orderBy'] }
        : { orderBy?: requirement_documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, requirement_documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirement_documentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the requirement_documents model
   */
  readonly fields: requirement_documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for requirement_documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__requirement_documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_cases<T extends requirement_documents$test_casesArgs<ExtArgs> = {}>(args?: Subset<T, requirement_documents$test_casesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ai_session<T extends requirement_documents$ai_sessionArgs<ExtArgs> = {}>(args?: Subset<T, requirement_documents$ai_sessionArgs<ExtArgs>>): Prisma__ai_generation_sessionsClient<$Result.GetResult<Prisma.$ai_generation_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends requirement_documents$projectArgs<ExtArgs> = {}>(args?: Subset<T, requirement_documents$projectArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project_version<T extends requirement_documents$project_versionArgs<ExtArgs> = {}>(args?: Subset<T, requirement_documents$project_versionArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the requirement_documents model
   */
  interface requirement_documentsFieldRefs {
    readonly id: FieldRef<"requirement_documents", 'Int'>
    readonly title: FieldRef<"requirement_documents", 'String'>
    readonly content: FieldRef<"requirement_documents", 'String'>
    readonly summary: FieldRef<"requirement_documents", 'String'>
    readonly source_filename: FieldRef<"requirement_documents", 'String'>
    readonly ai_session_id: FieldRef<"requirement_documents", 'String'>
    readonly project_id: FieldRef<"requirement_documents", 'Int'>
    readonly project_version_id: FieldRef<"requirement_documents", 'Int'>
    readonly creator_id: FieldRef<"requirement_documents", 'Int'>
    readonly scenario_count: FieldRef<"requirement_documents", 'Int'>
    readonly test_case_count: FieldRef<"requirement_documents", 'Int'>
    readonly status: FieldRef<"requirement_documents", 'requirement_doc_status'>
    readonly created_at: FieldRef<"requirement_documents", 'DateTime'>
    readonly updated_at: FieldRef<"requirement_documents", 'DateTime'>
    readonly module: FieldRef<"requirement_documents", 'String'>
    readonly system: FieldRef<"requirement_documents", 'String'>
  }
    

  // Custom InputTypes
  /**
   * requirement_documents findUnique
   */
  export type requirement_documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * Filter, which requirement_documents to fetch.
     */
    where: requirement_documentsWhereUniqueInput
  }

  /**
   * requirement_documents findUniqueOrThrow
   */
  export type requirement_documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * Filter, which requirement_documents to fetch.
     */
    where: requirement_documentsWhereUniqueInput
  }

  /**
   * requirement_documents findFirst
   */
  export type requirement_documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * Filter, which requirement_documents to fetch.
     */
    where?: requirement_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requirement_documents to fetch.
     */
    orderBy?: requirement_documentsOrderByWithRelationInput | requirement_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requirement_documents.
     */
    cursor?: requirement_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requirement_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requirement_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requirement_documents.
     */
    distinct?: Requirement_documentsScalarFieldEnum | Requirement_documentsScalarFieldEnum[]
  }

  /**
   * requirement_documents findFirstOrThrow
   */
  export type requirement_documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * Filter, which requirement_documents to fetch.
     */
    where?: requirement_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requirement_documents to fetch.
     */
    orderBy?: requirement_documentsOrderByWithRelationInput | requirement_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requirement_documents.
     */
    cursor?: requirement_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requirement_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requirement_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requirement_documents.
     */
    distinct?: Requirement_documentsScalarFieldEnum | Requirement_documentsScalarFieldEnum[]
  }

  /**
   * requirement_documents findMany
   */
  export type requirement_documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * Filter, which requirement_documents to fetch.
     */
    where?: requirement_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requirement_documents to fetch.
     */
    orderBy?: requirement_documentsOrderByWithRelationInput | requirement_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requirement_documents.
     */
    cursor?: requirement_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requirement_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requirement_documents.
     */
    skip?: number
    distinct?: Requirement_documentsScalarFieldEnum | Requirement_documentsScalarFieldEnum[]
  }

  /**
   * requirement_documents create
   */
  export type requirement_documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * The data needed to create a requirement_documents.
     */
    data: XOR<requirement_documentsCreateInput, requirement_documentsUncheckedCreateInput>
  }

  /**
   * requirement_documents createMany
   */
  export type requirement_documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many requirement_documents.
     */
    data: requirement_documentsCreateManyInput | requirement_documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * requirement_documents update
   */
  export type requirement_documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * The data needed to update a requirement_documents.
     */
    data: XOR<requirement_documentsUpdateInput, requirement_documentsUncheckedUpdateInput>
    /**
     * Choose, which requirement_documents to update.
     */
    where: requirement_documentsWhereUniqueInput
  }

  /**
   * requirement_documents updateMany
   */
  export type requirement_documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update requirement_documents.
     */
    data: XOR<requirement_documentsUpdateManyMutationInput, requirement_documentsUncheckedUpdateManyInput>
    /**
     * Filter which requirement_documents to update
     */
    where?: requirement_documentsWhereInput
    /**
     * Limit how many requirement_documents to update.
     */
    limit?: number
  }

  /**
   * requirement_documents upsert
   */
  export type requirement_documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * The filter to search for the requirement_documents to update in case it exists.
     */
    where: requirement_documentsWhereUniqueInput
    /**
     * In case the requirement_documents found by the `where` argument doesn't exist, create a new requirement_documents with this data.
     */
    create: XOR<requirement_documentsCreateInput, requirement_documentsUncheckedCreateInput>
    /**
     * In case the requirement_documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<requirement_documentsUpdateInput, requirement_documentsUncheckedUpdateInput>
  }

  /**
   * requirement_documents delete
   */
  export type requirement_documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    /**
     * Filter which requirement_documents to delete.
     */
    where: requirement_documentsWhereUniqueInput
  }

  /**
   * requirement_documents deleteMany
   */
  export type requirement_documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requirement_documents to delete
     */
    where?: requirement_documentsWhereInput
    /**
     * Limit how many requirement_documents to delete.
     */
    limit?: number
  }

  /**
   * requirement_documents.test_cases
   */
  export type requirement_documents$test_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    where?: functional_test_casesWhereInput
    orderBy?: functional_test_casesOrderByWithRelationInput | functional_test_casesOrderByWithRelationInput[]
    cursor?: functional_test_casesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Functional_test_casesScalarFieldEnum | Functional_test_casesScalarFieldEnum[]
  }

  /**
   * requirement_documents.ai_session
   */
  export type requirement_documents$ai_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_generation_sessions
     */
    select?: ai_generation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_generation_sessions
     */
    omit?: ai_generation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_generation_sessionsInclude<ExtArgs> | null
    where?: ai_generation_sessionsWhereInput
  }

  /**
   * requirement_documents.project
   */
  export type requirement_documents$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    where?: systemsWhereInput
  }

  /**
   * requirement_documents.project_version
   */
  export type requirement_documents$project_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    where?: project_versionsWhereInput
  }

  /**
   * requirement_documents without action
   */
  export type requirement_documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
  }


  /**
   * Model systems
   */

  export type AggregateSystems = {
    _count: SystemsCountAggregateOutputType | null
    _avg: SystemsAvgAggregateOutputType | null
    _sum: SystemsSumAggregateOutputType | null
    _min: SystemsMinAggregateOutputType | null
    _max: SystemsMaxAggregateOutputType | null
  }

  export type SystemsAvgAggregateOutputType = {
    id: number | null
    sort_order: number | null
  }

  export type SystemsSumAggregateOutputType = {
    id: number | null
    sort_order: number | null
  }

  export type SystemsMinAggregateOutputType = {
    id: number | null
    name: string | null
    short_name: string | null
    description: string | null
    status: $Enums.system_status | null
    sort_order: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SystemsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    short_name: string | null
    description: string | null
    status: $Enums.system_status | null
    sort_order: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SystemsCountAggregateOutputType = {
    id: number
    name: number
    short_name: number
    description: number
    status: number
    sort_order: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SystemsAvgAggregateInputType = {
    id?: true
    sort_order?: true
  }

  export type SystemsSumAggregateInputType = {
    id?: true
    sort_order?: true
  }

  export type SystemsMinAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    description?: true
    status?: true
    sort_order?: true
    created_at?: true
    updated_at?: true
  }

  export type SystemsMaxAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    description?: true
    status?: true
    sort_order?: true
    created_at?: true
    updated_at?: true
  }

  export type SystemsCountAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    description?: true
    status?: true
    sort_order?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SystemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which systems to aggregate.
     */
    where?: systemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systems to fetch.
     */
    orderBy?: systemsOrderByWithRelationInput | systemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: systemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned systems
    **/
    _count?: true | SystemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemsMaxAggregateInputType
  }

  export type GetSystemsAggregateType<T extends SystemsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystems[P]>
      : GetScalarType<T[P], AggregateSystems[P]>
  }




  export type systemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: systemsWhereInput
    orderBy?: systemsOrderByWithAggregationInput | systemsOrderByWithAggregationInput[]
    by: SystemsScalarFieldEnum[] | SystemsScalarFieldEnum
    having?: systemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemsCountAggregateInputType | true
    _avg?: SystemsAvgAggregateInputType
    _sum?: SystemsSumAggregateInputType
    _min?: SystemsMinAggregateInputType
    _max?: SystemsMaxAggregateInputType
  }

  export type SystemsGroupByOutputType = {
    id: number
    name: string
    short_name: string | null
    description: string | null
    status: $Enums.system_status
    sort_order: number
    created_at: Date
    updated_at: Date
    _count: SystemsCountAggregateOutputType | null
    _avg: SystemsAvgAggregateOutputType | null
    _sum: SystemsSumAggregateOutputType | null
    _min: SystemsMinAggregateOutputType | null
    _max: SystemsMaxAggregateOutputType | null
  }

  type GetSystemsGroupByPayload<T extends systemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemsGroupByOutputType[P]>
        }
      >
    >


  export type systemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    short_name?: boolean
    description?: boolean
    status?: boolean
    sort_order?: boolean
    created_at?: boolean
    updated_at?: boolean
    versions?: boolean | systems$versionsArgs<ExtArgs>
    requirement_documents?: boolean | systems$requirement_documentsArgs<ExtArgs>
    _count?: boolean | SystemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systems"]>



  export type systemsSelectScalar = {
    id?: boolean
    name?: boolean
    short_name?: boolean
    description?: boolean
    status?: boolean
    sort_order?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type systemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "short_name" | "description" | "status" | "sort_order" | "created_at" | "updated_at", ExtArgs["result"]["systems"]>
  export type systemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | systems$versionsArgs<ExtArgs>
    requirement_documents?: boolean | systems$requirement_documentsArgs<ExtArgs>
    _count?: boolean | SystemsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $systemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "systems"
    objects: {
      versions: Prisma.$project_versionsPayload<ExtArgs>[]
      requirement_documents: Prisma.$requirement_documentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      short_name: string | null
      description: string | null
      status: $Enums.system_status
      sort_order: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["systems"]>
    composites: {}
  }

  type systemsGetPayload<S extends boolean | null | undefined | systemsDefaultArgs> = $Result.GetResult<Prisma.$systemsPayload, S>

  type systemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<systemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemsCountAggregateInputType | true
    }

  export interface systemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['systems'], meta: { name: 'systems' } }
    /**
     * Find zero or one Systems that matches the filter.
     * @param {systemsFindUniqueArgs} args - Arguments to find a Systems
     * @example
     * // Get one Systems
     * const systems = await prisma.systems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends systemsFindUniqueArgs>(args: SelectSubset<T, systemsFindUniqueArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Systems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {systemsFindUniqueOrThrowArgs} args - Arguments to find a Systems
     * @example
     * // Get one Systems
     * const systems = await prisma.systems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends systemsFindUniqueOrThrowArgs>(args: SelectSubset<T, systemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Systems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemsFindFirstArgs} args - Arguments to find a Systems
     * @example
     * // Get one Systems
     * const systems = await prisma.systems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends systemsFindFirstArgs>(args?: SelectSubset<T, systemsFindFirstArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Systems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemsFindFirstOrThrowArgs} args - Arguments to find a Systems
     * @example
     * // Get one Systems
     * const systems = await prisma.systems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends systemsFindFirstOrThrowArgs>(args?: SelectSubset<T, systemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Systems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Systems
     * const systems = await prisma.systems.findMany()
     * 
     * // Get first 10 Systems
     * const systems = await prisma.systems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemsWithIdOnly = await prisma.systems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends systemsFindManyArgs>(args?: SelectSubset<T, systemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Systems.
     * @param {systemsCreateArgs} args - Arguments to create a Systems.
     * @example
     * // Create one Systems
     * const Systems = await prisma.systems.create({
     *   data: {
     *     // ... data to create a Systems
     *   }
     * })
     * 
     */
    create<T extends systemsCreateArgs>(args: SelectSubset<T, systemsCreateArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Systems.
     * @param {systemsCreateManyArgs} args - Arguments to create many Systems.
     * @example
     * // Create many Systems
     * const systems = await prisma.systems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends systemsCreateManyArgs>(args?: SelectSubset<T, systemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Systems.
     * @param {systemsDeleteArgs} args - Arguments to delete one Systems.
     * @example
     * // Delete one Systems
     * const Systems = await prisma.systems.delete({
     *   where: {
     *     // ... filter to delete one Systems
     *   }
     * })
     * 
     */
    delete<T extends systemsDeleteArgs>(args: SelectSubset<T, systemsDeleteArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Systems.
     * @param {systemsUpdateArgs} args - Arguments to update one Systems.
     * @example
     * // Update one Systems
     * const systems = await prisma.systems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends systemsUpdateArgs>(args: SelectSubset<T, systemsUpdateArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Systems.
     * @param {systemsDeleteManyArgs} args - Arguments to filter Systems to delete.
     * @example
     * // Delete a few Systems
     * const { count } = await prisma.systems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends systemsDeleteManyArgs>(args?: SelectSubset<T, systemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Systems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Systems
     * const systems = await prisma.systems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends systemsUpdateManyArgs>(args: SelectSubset<T, systemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Systems.
     * @param {systemsUpsertArgs} args - Arguments to update or create a Systems.
     * @example
     * // Update or create a Systems
     * const systems = await prisma.systems.upsert({
     *   create: {
     *     // ... data to create a Systems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Systems we want to update
     *   }
     * })
     */
    upsert<T extends systemsUpsertArgs>(args: SelectSubset<T, systemsUpsertArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Systems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemsCountArgs} args - Arguments to filter Systems to count.
     * @example
     * // Count the number of Systems
     * const count = await prisma.systems.count({
     *   where: {
     *     // ... the filter for the Systems we want to count
     *   }
     * })
    **/
    count<T extends systemsCountArgs>(
      args?: Subset<T, systemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Systems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemsAggregateArgs>(args: Subset<T, SystemsAggregateArgs>): Prisma.PrismaPromise<GetSystemsAggregateType<T>>

    /**
     * Group by Systems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends systemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: systemsGroupByArgs['orderBy'] }
        : { orderBy?: systemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, systemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the systems model
   */
  readonly fields: systemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for systems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__systemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versions<T extends systems$versionsArgs<ExtArgs> = {}>(args?: Subset<T, systems$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requirement_documents<T extends systems$requirement_documentsArgs<ExtArgs> = {}>(args?: Subset<T, systems$requirement_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the systems model
   */
  interface systemsFieldRefs {
    readonly id: FieldRef<"systems", 'Int'>
    readonly name: FieldRef<"systems", 'String'>
    readonly short_name: FieldRef<"systems", 'String'>
    readonly description: FieldRef<"systems", 'String'>
    readonly status: FieldRef<"systems", 'system_status'>
    readonly sort_order: FieldRef<"systems", 'Int'>
    readonly created_at: FieldRef<"systems", 'DateTime'>
    readonly updated_at: FieldRef<"systems", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * systems findUnique
   */
  export type systemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * Filter, which systems to fetch.
     */
    where: systemsWhereUniqueInput
  }

  /**
   * systems findUniqueOrThrow
   */
  export type systemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * Filter, which systems to fetch.
     */
    where: systemsWhereUniqueInput
  }

  /**
   * systems findFirst
   */
  export type systemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * Filter, which systems to fetch.
     */
    where?: systemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systems to fetch.
     */
    orderBy?: systemsOrderByWithRelationInput | systemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for systems.
     */
    cursor?: systemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of systems.
     */
    distinct?: SystemsScalarFieldEnum | SystemsScalarFieldEnum[]
  }

  /**
   * systems findFirstOrThrow
   */
  export type systemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * Filter, which systems to fetch.
     */
    where?: systemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systems to fetch.
     */
    orderBy?: systemsOrderByWithRelationInput | systemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for systems.
     */
    cursor?: systemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of systems.
     */
    distinct?: SystemsScalarFieldEnum | SystemsScalarFieldEnum[]
  }

  /**
   * systems findMany
   */
  export type systemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * Filter, which systems to fetch.
     */
    where?: systemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systems to fetch.
     */
    orderBy?: systemsOrderByWithRelationInput | systemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing systems.
     */
    cursor?: systemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systems.
     */
    skip?: number
    distinct?: SystemsScalarFieldEnum | SystemsScalarFieldEnum[]
  }

  /**
   * systems create
   */
  export type systemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * The data needed to create a systems.
     */
    data: XOR<systemsCreateInput, systemsUncheckedCreateInput>
  }

  /**
   * systems createMany
   */
  export type systemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many systems.
     */
    data: systemsCreateManyInput | systemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * systems update
   */
  export type systemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * The data needed to update a systems.
     */
    data: XOR<systemsUpdateInput, systemsUncheckedUpdateInput>
    /**
     * Choose, which systems to update.
     */
    where: systemsWhereUniqueInput
  }

  /**
   * systems updateMany
   */
  export type systemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update systems.
     */
    data: XOR<systemsUpdateManyMutationInput, systemsUncheckedUpdateManyInput>
    /**
     * Filter which systems to update
     */
    where?: systemsWhereInput
    /**
     * Limit how many systems to update.
     */
    limit?: number
  }

  /**
   * systems upsert
   */
  export type systemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * The filter to search for the systems to update in case it exists.
     */
    where: systemsWhereUniqueInput
    /**
     * In case the systems found by the `where` argument doesn't exist, create a new systems with this data.
     */
    create: XOR<systemsCreateInput, systemsUncheckedCreateInput>
    /**
     * In case the systems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<systemsUpdateInput, systemsUncheckedUpdateInput>
  }

  /**
   * systems delete
   */
  export type systemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
    /**
     * Filter which systems to delete.
     */
    where: systemsWhereUniqueInput
  }

  /**
   * systems deleteMany
   */
  export type systemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which systems to delete
     */
    where?: systemsWhereInput
    /**
     * Limit how many systems to delete.
     */
    limit?: number
  }

  /**
   * systems.versions
   */
  export type systems$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    where?: project_versionsWhereInput
    orderBy?: project_versionsOrderByWithRelationInput | project_versionsOrderByWithRelationInput[]
    cursor?: project_versionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Project_versionsScalarFieldEnum | Project_versionsScalarFieldEnum[]
  }

  /**
   * systems.requirement_documents
   */
  export type systems$requirement_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    where?: requirement_documentsWhereInput
    orderBy?: requirement_documentsOrderByWithRelationInput | requirement_documentsOrderByWithRelationInput[]
    cursor?: requirement_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Requirement_documentsScalarFieldEnum | Requirement_documentsScalarFieldEnum[]
  }

  /**
   * systems without action
   */
  export type systemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systems
     */
    select?: systemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the systems
     */
    omit?: systemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: systemsInclude<ExtArgs> | null
  }


  /**
   * Model project_versions
   */

  export type AggregateProject_versions = {
    _count: Project_versionsCountAggregateOutputType | null
    _avg: Project_versionsAvgAggregateOutputType | null
    _sum: Project_versionsSumAggregateOutputType | null
    _min: Project_versionsMinAggregateOutputType | null
    _max: Project_versionsMaxAggregateOutputType | null
  }

  export type Project_versionsAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
  }

  export type Project_versionsSumAggregateOutputType = {
    id: number | null
    project_id: number | null
  }

  export type Project_versionsMinAggregateOutputType = {
    id: number | null
    project_id: number | null
    version_name: string | null
    version_code: string | null
    description: string | null
    is_main: boolean | null
    status: $Enums.system_status | null
    release_date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Project_versionsMaxAggregateOutputType = {
    id: number | null
    project_id: number | null
    version_name: string | null
    version_code: string | null
    description: string | null
    is_main: boolean | null
    status: $Enums.system_status | null
    release_date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Project_versionsCountAggregateOutputType = {
    id: number
    project_id: number
    version_name: number
    version_code: number
    description: number
    is_main: number
    status: number
    release_date: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Project_versionsAvgAggregateInputType = {
    id?: true
    project_id?: true
  }

  export type Project_versionsSumAggregateInputType = {
    id?: true
    project_id?: true
  }

  export type Project_versionsMinAggregateInputType = {
    id?: true
    project_id?: true
    version_name?: true
    version_code?: true
    description?: true
    is_main?: true
    status?: true
    release_date?: true
    created_at?: true
    updated_at?: true
  }

  export type Project_versionsMaxAggregateInputType = {
    id?: true
    project_id?: true
    version_name?: true
    version_code?: true
    description?: true
    is_main?: true
    status?: true
    release_date?: true
    created_at?: true
    updated_at?: true
  }

  export type Project_versionsCountAggregateInputType = {
    id?: true
    project_id?: true
    version_name?: true
    version_code?: true
    description?: true
    is_main?: true
    status?: true
    release_date?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Project_versionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_versions to aggregate.
     */
    where?: project_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_versions to fetch.
     */
    orderBy?: project_versionsOrderByWithRelationInput | project_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: project_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned project_versions
    **/
    _count?: true | Project_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Project_versionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Project_versionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Project_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Project_versionsMaxAggregateInputType
  }

  export type GetProject_versionsAggregateType<T extends Project_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateProject_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject_versions[P]>
      : GetScalarType<T[P], AggregateProject_versions[P]>
  }




  export type project_versionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_versionsWhereInput
    orderBy?: project_versionsOrderByWithAggregationInput | project_versionsOrderByWithAggregationInput[]
    by: Project_versionsScalarFieldEnum[] | Project_versionsScalarFieldEnum
    having?: project_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Project_versionsCountAggregateInputType | true
    _avg?: Project_versionsAvgAggregateInputType
    _sum?: Project_versionsSumAggregateInputType
    _min?: Project_versionsMinAggregateInputType
    _max?: Project_versionsMaxAggregateInputType
  }

  export type Project_versionsGroupByOutputType = {
    id: number
    project_id: number
    version_name: string
    version_code: string
    description: string | null
    is_main: boolean
    status: $Enums.system_status
    release_date: Date | null
    created_at: Date
    updated_at: Date
    _count: Project_versionsCountAggregateOutputType | null
    _avg: Project_versionsAvgAggregateOutputType | null
    _sum: Project_versionsSumAggregateOutputType | null
    _min: Project_versionsMinAggregateOutputType | null
    _max: Project_versionsMaxAggregateOutputType | null
  }

  type GetProject_versionsGroupByPayload<T extends project_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Project_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Project_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Project_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], Project_versionsGroupByOutputType[P]>
        }
      >
    >


  export type project_versionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    version_name?: boolean
    version_code?: boolean
    description?: boolean
    is_main?: boolean
    status?: boolean
    release_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    functional_test_cases?: boolean | project_versions$functional_test_casesArgs<ExtArgs>
    project?: boolean | systemsDefaultArgs<ExtArgs>
    requirement_documents?: boolean | project_versions$requirement_documentsArgs<ExtArgs>
    _count?: boolean | Project_versionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_versions"]>



  export type project_versionsSelectScalar = {
    id?: boolean
    project_id?: boolean
    version_name?: boolean
    version_code?: boolean
    description?: boolean
    is_main?: boolean
    status?: boolean
    release_date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type project_versionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "version_name" | "version_code" | "description" | "is_main" | "status" | "release_date" | "created_at" | "updated_at", ExtArgs["result"]["project_versions"]>
  export type project_versionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    functional_test_cases?: boolean | project_versions$functional_test_casesArgs<ExtArgs>
    project?: boolean | systemsDefaultArgs<ExtArgs>
    requirement_documents?: boolean | project_versions$requirement_documentsArgs<ExtArgs>
    _count?: boolean | Project_versionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $project_versionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "project_versions"
    objects: {
      functional_test_cases: Prisma.$functional_test_casesPayload<ExtArgs>[]
      project: Prisma.$systemsPayload<ExtArgs>
      requirement_documents: Prisma.$requirement_documentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      project_id: number
      version_name: string
      version_code: string
      description: string | null
      is_main: boolean
      status: $Enums.system_status
      release_date: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["project_versions"]>
    composites: {}
  }

  type project_versionsGetPayload<S extends boolean | null | undefined | project_versionsDefaultArgs> = $Result.GetResult<Prisma.$project_versionsPayload, S>

  type project_versionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<project_versionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Project_versionsCountAggregateInputType | true
    }

  export interface project_versionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['project_versions'], meta: { name: 'project_versions' } }
    /**
     * Find zero or one Project_versions that matches the filter.
     * @param {project_versionsFindUniqueArgs} args - Arguments to find a Project_versions
     * @example
     * // Get one Project_versions
     * const project_versions = await prisma.project_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends project_versionsFindUniqueArgs>(args: SelectSubset<T, project_versionsFindUniqueArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project_versions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {project_versionsFindUniqueOrThrowArgs} args - Arguments to find a Project_versions
     * @example
     * // Get one Project_versions
     * const project_versions = await prisma.project_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends project_versionsFindUniqueOrThrowArgs>(args: SelectSubset<T, project_versionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_versionsFindFirstArgs} args - Arguments to find a Project_versions
     * @example
     * // Get one Project_versions
     * const project_versions = await prisma.project_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends project_versionsFindFirstArgs>(args?: SelectSubset<T, project_versionsFindFirstArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project_versions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_versionsFindFirstOrThrowArgs} args - Arguments to find a Project_versions
     * @example
     * // Get one Project_versions
     * const project_versions = await prisma.project_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends project_versionsFindFirstOrThrowArgs>(args?: SelectSubset<T, project_versionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Project_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_versionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Project_versions
     * const project_versions = await prisma.project_versions.findMany()
     * 
     * // Get first 10 Project_versions
     * const project_versions = await prisma.project_versions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const project_versionsWithIdOnly = await prisma.project_versions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends project_versionsFindManyArgs>(args?: SelectSubset<T, project_versionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project_versions.
     * @param {project_versionsCreateArgs} args - Arguments to create a Project_versions.
     * @example
     * // Create one Project_versions
     * const Project_versions = await prisma.project_versions.create({
     *   data: {
     *     // ... data to create a Project_versions
     *   }
     * })
     * 
     */
    create<T extends project_versionsCreateArgs>(args: SelectSubset<T, project_versionsCreateArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Project_versions.
     * @param {project_versionsCreateManyArgs} args - Arguments to create many Project_versions.
     * @example
     * // Create many Project_versions
     * const project_versions = await prisma.project_versions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends project_versionsCreateManyArgs>(args?: SelectSubset<T, project_versionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project_versions.
     * @param {project_versionsDeleteArgs} args - Arguments to delete one Project_versions.
     * @example
     * // Delete one Project_versions
     * const Project_versions = await prisma.project_versions.delete({
     *   where: {
     *     // ... filter to delete one Project_versions
     *   }
     * })
     * 
     */
    delete<T extends project_versionsDeleteArgs>(args: SelectSubset<T, project_versionsDeleteArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project_versions.
     * @param {project_versionsUpdateArgs} args - Arguments to update one Project_versions.
     * @example
     * // Update one Project_versions
     * const project_versions = await prisma.project_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends project_versionsUpdateArgs>(args: SelectSubset<T, project_versionsUpdateArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Project_versions.
     * @param {project_versionsDeleteManyArgs} args - Arguments to filter Project_versions to delete.
     * @example
     * // Delete a few Project_versions
     * const { count } = await prisma.project_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends project_versionsDeleteManyArgs>(args?: SelectSubset<T, project_versionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Project_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Project_versions
     * const project_versions = await prisma.project_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends project_versionsUpdateManyArgs>(args: SelectSubset<T, project_versionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project_versions.
     * @param {project_versionsUpsertArgs} args - Arguments to update or create a Project_versions.
     * @example
     * // Update or create a Project_versions
     * const project_versions = await prisma.project_versions.upsert({
     *   create: {
     *     // ... data to create a Project_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project_versions we want to update
     *   }
     * })
     */
    upsert<T extends project_versionsUpsertArgs>(args: SelectSubset<T, project_versionsUpsertArgs<ExtArgs>>): Prisma__project_versionsClient<$Result.GetResult<Prisma.$project_versionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Project_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_versionsCountArgs} args - Arguments to filter Project_versions to count.
     * @example
     * // Count the number of Project_versions
     * const count = await prisma.project_versions.count({
     *   where: {
     *     // ... the filter for the Project_versions we want to count
     *   }
     * })
    **/
    count<T extends project_versionsCountArgs>(
      args?: Subset<T, project_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Project_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Project_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Project_versionsAggregateArgs>(args: Subset<T, Project_versionsAggregateArgs>): Prisma.PrismaPromise<GetProject_versionsAggregateType<T>>

    /**
     * Group by Project_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends project_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: project_versionsGroupByArgs['orderBy'] }
        : { orderBy?: project_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, project_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProject_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the project_versions model
   */
  readonly fields: project_versionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for project_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__project_versionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    functional_test_cases<T extends project_versions$functional_test_casesArgs<ExtArgs> = {}>(args?: Subset<T, project_versions$functional_test_casesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends systemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, systemsDefaultArgs<ExtArgs>>): Prisma__systemsClient<$Result.GetResult<Prisma.$systemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirement_documents<T extends project_versions$requirement_documentsArgs<ExtArgs> = {}>(args?: Subset<T, project_versions$requirement_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirement_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the project_versions model
   */
  interface project_versionsFieldRefs {
    readonly id: FieldRef<"project_versions", 'Int'>
    readonly project_id: FieldRef<"project_versions", 'Int'>
    readonly version_name: FieldRef<"project_versions", 'String'>
    readonly version_code: FieldRef<"project_versions", 'String'>
    readonly description: FieldRef<"project_versions", 'String'>
    readonly is_main: FieldRef<"project_versions", 'Boolean'>
    readonly status: FieldRef<"project_versions", 'system_status'>
    readonly release_date: FieldRef<"project_versions", 'DateTime'>
    readonly created_at: FieldRef<"project_versions", 'DateTime'>
    readonly updated_at: FieldRef<"project_versions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * project_versions findUnique
   */
  export type project_versionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * Filter, which project_versions to fetch.
     */
    where: project_versionsWhereUniqueInput
  }

  /**
   * project_versions findUniqueOrThrow
   */
  export type project_versionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * Filter, which project_versions to fetch.
     */
    where: project_versionsWhereUniqueInput
  }

  /**
   * project_versions findFirst
   */
  export type project_versionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * Filter, which project_versions to fetch.
     */
    where?: project_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_versions to fetch.
     */
    orderBy?: project_versionsOrderByWithRelationInput | project_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_versions.
     */
    cursor?: project_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_versions.
     */
    distinct?: Project_versionsScalarFieldEnum | Project_versionsScalarFieldEnum[]
  }

  /**
   * project_versions findFirstOrThrow
   */
  export type project_versionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * Filter, which project_versions to fetch.
     */
    where?: project_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_versions to fetch.
     */
    orderBy?: project_versionsOrderByWithRelationInput | project_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_versions.
     */
    cursor?: project_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_versions.
     */
    distinct?: Project_versionsScalarFieldEnum | Project_versionsScalarFieldEnum[]
  }

  /**
   * project_versions findMany
   */
  export type project_versionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * Filter, which project_versions to fetch.
     */
    where?: project_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_versions to fetch.
     */
    orderBy?: project_versionsOrderByWithRelationInput | project_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing project_versions.
     */
    cursor?: project_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_versions.
     */
    skip?: number
    distinct?: Project_versionsScalarFieldEnum | Project_versionsScalarFieldEnum[]
  }

  /**
   * project_versions create
   */
  export type project_versionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * The data needed to create a project_versions.
     */
    data: XOR<project_versionsCreateInput, project_versionsUncheckedCreateInput>
  }

  /**
   * project_versions createMany
   */
  export type project_versionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many project_versions.
     */
    data: project_versionsCreateManyInput | project_versionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project_versions update
   */
  export type project_versionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * The data needed to update a project_versions.
     */
    data: XOR<project_versionsUpdateInput, project_versionsUncheckedUpdateInput>
    /**
     * Choose, which project_versions to update.
     */
    where: project_versionsWhereUniqueInput
  }

  /**
   * project_versions updateMany
   */
  export type project_versionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update project_versions.
     */
    data: XOR<project_versionsUpdateManyMutationInput, project_versionsUncheckedUpdateManyInput>
    /**
     * Filter which project_versions to update
     */
    where?: project_versionsWhereInput
    /**
     * Limit how many project_versions to update.
     */
    limit?: number
  }

  /**
   * project_versions upsert
   */
  export type project_versionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * The filter to search for the project_versions to update in case it exists.
     */
    where: project_versionsWhereUniqueInput
    /**
     * In case the project_versions found by the `where` argument doesn't exist, create a new project_versions with this data.
     */
    create: XOR<project_versionsCreateInput, project_versionsUncheckedCreateInput>
    /**
     * In case the project_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<project_versionsUpdateInput, project_versionsUncheckedUpdateInput>
  }

  /**
   * project_versions delete
   */
  export type project_versionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
    /**
     * Filter which project_versions to delete.
     */
    where: project_versionsWhereUniqueInput
  }

  /**
   * project_versions deleteMany
   */
  export type project_versionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_versions to delete
     */
    where?: project_versionsWhereInput
    /**
     * Limit how many project_versions to delete.
     */
    limit?: number
  }

  /**
   * project_versions.functional_test_cases
   */
  export type project_versions$functional_test_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_cases
     */
    select?: functional_test_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_cases
     */
    omit?: functional_test_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_casesInclude<ExtArgs> | null
    where?: functional_test_casesWhereInput
    orderBy?: functional_test_casesOrderByWithRelationInput | functional_test_casesOrderByWithRelationInput[]
    cursor?: functional_test_casesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Functional_test_casesScalarFieldEnum | Functional_test_casesScalarFieldEnum[]
  }

  /**
   * project_versions.requirement_documents
   */
  export type project_versions$requirement_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirement_documents
     */
    select?: requirement_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirement_documents
     */
    omit?: requirement_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirement_documentsInclude<ExtArgs> | null
    where?: requirement_documentsWhereInput
    orderBy?: requirement_documentsOrderByWithRelationInput | requirement_documentsOrderByWithRelationInput[]
    cursor?: requirement_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Requirement_documentsScalarFieldEnum | Requirement_documentsScalarFieldEnum[]
  }

  /**
   * project_versions without action
   */
  export type project_versionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_versions
     */
    select?: project_versionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_versions
     */
    omit?: project_versionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_versionsInclude<ExtArgs> | null
  }


  /**
   * Model functional_test_executions
   */

  export type AggregateFunctional_test_executions = {
    _count: Functional_test_executionsCountAggregateOutputType | null
    _avg: Functional_test_executionsAvgAggregateOutputType | null
    _sum: Functional_test_executionsSumAggregateOutputType | null
    _min: Functional_test_executionsMinAggregateOutputType | null
    _max: Functional_test_executionsMaxAggregateOutputType | null
  }

  export type Functional_test_executionsAvgAggregateOutputType = {
    test_case_id: number | null
    duration_ms: number | null
    executor_id: number | null
    total_steps: number | null
    completed_steps: number | null
    passed_steps: number | null
    failed_steps: number | null
    blocked_steps: number | null
  }

  export type Functional_test_executionsSumAggregateOutputType = {
    test_case_id: number | null
    duration_ms: number | null
    executor_id: number | null
    total_steps: number | null
    completed_steps: number | null
    passed_steps: number | null
    failed_steps: number | null
    blocked_steps: number | null
  }

  export type Functional_test_executionsMinAggregateOutputType = {
    id: string | null
    test_case_id: number | null
    test_case_name: string | null
    final_result: $Enums.functional_execution_result | null
    actual_result: string | null
    comments: string | null
    duration_ms: number | null
    executed_at: Date | null
    executor_id: number | null
    executor_project: string | null
    total_steps: number | null
    completed_steps: number | null
    passed_steps: number | null
    failed_steps: number | null
    blocked_steps: number | null
  }

  export type Functional_test_executionsMaxAggregateOutputType = {
    id: string | null
    test_case_id: number | null
    test_case_name: string | null
    final_result: $Enums.functional_execution_result | null
    actual_result: string | null
    comments: string | null
    duration_ms: number | null
    executed_at: Date | null
    executor_id: number | null
    executor_project: string | null
    total_steps: number | null
    completed_steps: number | null
    passed_steps: number | null
    failed_steps: number | null
    blocked_steps: number | null
  }

  export type Functional_test_executionsCountAggregateOutputType = {
    id: number
    test_case_id: number
    test_case_name: number
    final_result: number
    actual_result: number
    comments: number
    duration_ms: number
    executed_at: number
    executor_id: number
    executor_project: number
    step_results: number
    total_steps: number
    completed_steps: number
    passed_steps: number
    failed_steps: number
    blocked_steps: number
    screenshots: number
    attachments: number
    metadata: number
    _all: number
  }


  export type Functional_test_executionsAvgAggregateInputType = {
    test_case_id?: true
    duration_ms?: true
    executor_id?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    blocked_steps?: true
  }

  export type Functional_test_executionsSumAggregateInputType = {
    test_case_id?: true
    duration_ms?: true
    executor_id?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    blocked_steps?: true
  }

  export type Functional_test_executionsMinAggregateInputType = {
    id?: true
    test_case_id?: true
    test_case_name?: true
    final_result?: true
    actual_result?: true
    comments?: true
    duration_ms?: true
    executed_at?: true
    executor_id?: true
    executor_project?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    blocked_steps?: true
  }

  export type Functional_test_executionsMaxAggregateInputType = {
    id?: true
    test_case_id?: true
    test_case_name?: true
    final_result?: true
    actual_result?: true
    comments?: true
    duration_ms?: true
    executed_at?: true
    executor_id?: true
    executor_project?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    blocked_steps?: true
  }

  export type Functional_test_executionsCountAggregateInputType = {
    id?: true
    test_case_id?: true
    test_case_name?: true
    final_result?: true
    actual_result?: true
    comments?: true
    duration_ms?: true
    executed_at?: true
    executor_id?: true
    executor_project?: true
    step_results?: true
    total_steps?: true
    completed_steps?: true
    passed_steps?: true
    failed_steps?: true
    blocked_steps?: true
    screenshots?: true
    attachments?: true
    metadata?: true
    _all?: true
  }

  export type Functional_test_executionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which functional_test_executions to aggregate.
     */
    where?: functional_test_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functional_test_executions to fetch.
     */
    orderBy?: functional_test_executionsOrderByWithRelationInput | functional_test_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: functional_test_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functional_test_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functional_test_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned functional_test_executions
    **/
    _count?: true | Functional_test_executionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Functional_test_executionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Functional_test_executionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Functional_test_executionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Functional_test_executionsMaxAggregateInputType
  }

  export type GetFunctional_test_executionsAggregateType<T extends Functional_test_executionsAggregateArgs> = {
        [P in keyof T & keyof AggregateFunctional_test_executions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunctional_test_executions[P]>
      : GetScalarType<T[P], AggregateFunctional_test_executions[P]>
  }




  export type functional_test_executionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: functional_test_executionsWhereInput
    orderBy?: functional_test_executionsOrderByWithAggregationInput | functional_test_executionsOrderByWithAggregationInput[]
    by: Functional_test_executionsScalarFieldEnum[] | Functional_test_executionsScalarFieldEnum
    having?: functional_test_executionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Functional_test_executionsCountAggregateInputType | true
    _avg?: Functional_test_executionsAvgAggregateInputType
    _sum?: Functional_test_executionsSumAggregateInputType
    _min?: Functional_test_executionsMinAggregateInputType
    _max?: Functional_test_executionsMaxAggregateInputType
  }

  export type Functional_test_executionsGroupByOutputType = {
    id: string
    test_case_id: number
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments: string | null
    duration_ms: number | null
    executed_at: Date
    executor_id: number
    executor_project: string | null
    step_results: JsonValue | null
    total_steps: number
    completed_steps: number
    passed_steps: number
    failed_steps: number
    blocked_steps: number
    screenshots: JsonValue | null
    attachments: JsonValue | null
    metadata: JsonValue | null
    _count: Functional_test_executionsCountAggregateOutputType | null
    _avg: Functional_test_executionsAvgAggregateOutputType | null
    _sum: Functional_test_executionsSumAggregateOutputType | null
    _min: Functional_test_executionsMinAggregateOutputType | null
    _max: Functional_test_executionsMaxAggregateOutputType | null
  }

  type GetFunctional_test_executionsGroupByPayload<T extends functional_test_executionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Functional_test_executionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Functional_test_executionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Functional_test_executionsGroupByOutputType[P]>
            : GetScalarType<T[P], Functional_test_executionsGroupByOutputType[P]>
        }
      >
    >


  export type functional_test_executionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    test_case_id?: boolean
    test_case_name?: boolean
    final_result?: boolean
    actual_result?: boolean
    comments?: boolean
    duration_ms?: boolean
    executed_at?: boolean
    executor_id?: boolean
    executor_project?: boolean
    step_results?: boolean
    total_steps?: boolean
    completed_steps?: boolean
    passed_steps?: boolean
    failed_steps?: boolean
    blocked_steps?: boolean
    screenshots?: boolean
    attachments?: boolean
    metadata?: boolean
    test_case?: boolean | functional_test_casesDefaultArgs<ExtArgs>
    executor?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["functional_test_executions"]>



  export type functional_test_executionsSelectScalar = {
    id?: boolean
    test_case_id?: boolean
    test_case_name?: boolean
    final_result?: boolean
    actual_result?: boolean
    comments?: boolean
    duration_ms?: boolean
    executed_at?: boolean
    executor_id?: boolean
    executor_project?: boolean
    step_results?: boolean
    total_steps?: boolean
    completed_steps?: boolean
    passed_steps?: boolean
    failed_steps?: boolean
    blocked_steps?: boolean
    screenshots?: boolean
    attachments?: boolean
    metadata?: boolean
  }

  export type functional_test_executionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "test_case_id" | "test_case_name" | "final_result" | "actual_result" | "comments" | "duration_ms" | "executed_at" | "executor_id" | "executor_project" | "step_results" | "total_steps" | "completed_steps" | "passed_steps" | "failed_steps" | "blocked_steps" | "screenshots" | "attachments" | "metadata", ExtArgs["result"]["functional_test_executions"]>
  export type functional_test_executionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_case?: boolean | functional_test_casesDefaultArgs<ExtArgs>
    executor?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $functional_test_executionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "functional_test_executions"
    objects: {
      test_case: Prisma.$functional_test_casesPayload<ExtArgs>
      executor: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      test_case_id: number
      test_case_name: string
      final_result: $Enums.functional_execution_result
      actual_result: string
      comments: string | null
      duration_ms: number | null
      executed_at: Date
      executor_id: number
      executor_project: string | null
      step_results: Prisma.JsonValue | null
      total_steps: number
      completed_steps: number
      passed_steps: number
      failed_steps: number
      blocked_steps: number
      screenshots: Prisma.JsonValue | null
      attachments: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["functional_test_executions"]>
    composites: {}
  }

  type functional_test_executionsGetPayload<S extends boolean | null | undefined | functional_test_executionsDefaultArgs> = $Result.GetResult<Prisma.$functional_test_executionsPayload, S>

  type functional_test_executionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<functional_test_executionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Functional_test_executionsCountAggregateInputType | true
    }

  export interface functional_test_executionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['functional_test_executions'], meta: { name: 'functional_test_executions' } }
    /**
     * Find zero or one Functional_test_executions that matches the filter.
     * @param {functional_test_executionsFindUniqueArgs} args - Arguments to find a Functional_test_executions
     * @example
     * // Get one Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends functional_test_executionsFindUniqueArgs>(args: SelectSubset<T, functional_test_executionsFindUniqueArgs<ExtArgs>>): Prisma__functional_test_executionsClient<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Functional_test_executions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {functional_test_executionsFindUniqueOrThrowArgs} args - Arguments to find a Functional_test_executions
     * @example
     * // Get one Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends functional_test_executionsFindUniqueOrThrowArgs>(args: SelectSubset<T, functional_test_executionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__functional_test_executionsClient<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Functional_test_executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_executionsFindFirstArgs} args - Arguments to find a Functional_test_executions
     * @example
     * // Get one Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends functional_test_executionsFindFirstArgs>(args?: SelectSubset<T, functional_test_executionsFindFirstArgs<ExtArgs>>): Prisma__functional_test_executionsClient<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Functional_test_executions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_executionsFindFirstOrThrowArgs} args - Arguments to find a Functional_test_executions
     * @example
     * // Get one Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends functional_test_executionsFindFirstOrThrowArgs>(args?: SelectSubset<T, functional_test_executionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__functional_test_executionsClient<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Functional_test_executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_executionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.findMany()
     * 
     * // Get first 10 Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const functional_test_executionsWithIdOnly = await prisma.functional_test_executions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends functional_test_executionsFindManyArgs>(args?: SelectSubset<T, functional_test_executionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Functional_test_executions.
     * @param {functional_test_executionsCreateArgs} args - Arguments to create a Functional_test_executions.
     * @example
     * // Create one Functional_test_executions
     * const Functional_test_executions = await prisma.functional_test_executions.create({
     *   data: {
     *     // ... data to create a Functional_test_executions
     *   }
     * })
     * 
     */
    create<T extends functional_test_executionsCreateArgs>(args: SelectSubset<T, functional_test_executionsCreateArgs<ExtArgs>>): Prisma__functional_test_executionsClient<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Functional_test_executions.
     * @param {functional_test_executionsCreateManyArgs} args - Arguments to create many Functional_test_executions.
     * @example
     * // Create many Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends functional_test_executionsCreateManyArgs>(args?: SelectSubset<T, functional_test_executionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Functional_test_executions.
     * @param {functional_test_executionsDeleteArgs} args - Arguments to delete one Functional_test_executions.
     * @example
     * // Delete one Functional_test_executions
     * const Functional_test_executions = await prisma.functional_test_executions.delete({
     *   where: {
     *     // ... filter to delete one Functional_test_executions
     *   }
     * })
     * 
     */
    delete<T extends functional_test_executionsDeleteArgs>(args: SelectSubset<T, functional_test_executionsDeleteArgs<ExtArgs>>): Prisma__functional_test_executionsClient<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Functional_test_executions.
     * @param {functional_test_executionsUpdateArgs} args - Arguments to update one Functional_test_executions.
     * @example
     * // Update one Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends functional_test_executionsUpdateArgs>(args: SelectSubset<T, functional_test_executionsUpdateArgs<ExtArgs>>): Prisma__functional_test_executionsClient<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Functional_test_executions.
     * @param {functional_test_executionsDeleteManyArgs} args - Arguments to filter Functional_test_executions to delete.
     * @example
     * // Delete a few Functional_test_executions
     * const { count } = await prisma.functional_test_executions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends functional_test_executionsDeleteManyArgs>(args?: SelectSubset<T, functional_test_executionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Functional_test_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_executionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends functional_test_executionsUpdateManyArgs>(args: SelectSubset<T, functional_test_executionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Functional_test_executions.
     * @param {functional_test_executionsUpsertArgs} args - Arguments to update or create a Functional_test_executions.
     * @example
     * // Update or create a Functional_test_executions
     * const functional_test_executions = await prisma.functional_test_executions.upsert({
     *   create: {
     *     // ... data to create a Functional_test_executions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Functional_test_executions we want to update
     *   }
     * })
     */
    upsert<T extends functional_test_executionsUpsertArgs>(args: SelectSubset<T, functional_test_executionsUpsertArgs<ExtArgs>>): Prisma__functional_test_executionsClient<$Result.GetResult<Prisma.$functional_test_executionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Functional_test_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_executionsCountArgs} args - Arguments to filter Functional_test_executions to count.
     * @example
     * // Count the number of Functional_test_executions
     * const count = await prisma.functional_test_executions.count({
     *   where: {
     *     // ... the filter for the Functional_test_executions we want to count
     *   }
     * })
    **/
    count<T extends functional_test_executionsCountArgs>(
      args?: Subset<T, functional_test_executionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Functional_test_executionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Functional_test_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Functional_test_executionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Functional_test_executionsAggregateArgs>(args: Subset<T, Functional_test_executionsAggregateArgs>): Prisma.PrismaPromise<GetFunctional_test_executionsAggregateType<T>>

    /**
     * Group by Functional_test_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functional_test_executionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends functional_test_executionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: functional_test_executionsGroupByArgs['orderBy'] }
        : { orderBy?: functional_test_executionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, functional_test_executionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunctional_test_executionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the functional_test_executions model
   */
  readonly fields: functional_test_executionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for functional_test_executions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__functional_test_executionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test_case<T extends functional_test_casesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, functional_test_casesDefaultArgs<ExtArgs>>): Prisma__functional_test_casesClient<$Result.GetResult<Prisma.$functional_test_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executor<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the functional_test_executions model
   */
  interface functional_test_executionsFieldRefs {
    readonly id: FieldRef<"functional_test_executions", 'String'>
    readonly test_case_id: FieldRef<"functional_test_executions", 'Int'>
    readonly test_case_name: FieldRef<"functional_test_executions", 'String'>
    readonly final_result: FieldRef<"functional_test_executions", 'functional_execution_result'>
    readonly actual_result: FieldRef<"functional_test_executions", 'String'>
    readonly comments: FieldRef<"functional_test_executions", 'String'>
    readonly duration_ms: FieldRef<"functional_test_executions", 'Int'>
    readonly executed_at: FieldRef<"functional_test_executions", 'DateTime'>
    readonly executor_id: FieldRef<"functional_test_executions", 'Int'>
    readonly executor_project: FieldRef<"functional_test_executions", 'String'>
    readonly step_results: FieldRef<"functional_test_executions", 'Json'>
    readonly total_steps: FieldRef<"functional_test_executions", 'Int'>
    readonly completed_steps: FieldRef<"functional_test_executions", 'Int'>
    readonly passed_steps: FieldRef<"functional_test_executions", 'Int'>
    readonly failed_steps: FieldRef<"functional_test_executions", 'Int'>
    readonly blocked_steps: FieldRef<"functional_test_executions", 'Int'>
    readonly screenshots: FieldRef<"functional_test_executions", 'Json'>
    readonly attachments: FieldRef<"functional_test_executions", 'Json'>
    readonly metadata: FieldRef<"functional_test_executions", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * functional_test_executions findUnique
   */
  export type functional_test_executionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_executions to fetch.
     */
    where: functional_test_executionsWhereUniqueInput
  }

  /**
   * functional_test_executions findUniqueOrThrow
   */
  export type functional_test_executionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_executions to fetch.
     */
    where: functional_test_executionsWhereUniqueInput
  }

  /**
   * functional_test_executions findFirst
   */
  export type functional_test_executionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_executions to fetch.
     */
    where?: functional_test_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functional_test_executions to fetch.
     */
    orderBy?: functional_test_executionsOrderByWithRelationInput | functional_test_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for functional_test_executions.
     */
    cursor?: functional_test_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functional_test_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functional_test_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of functional_test_executions.
     */
    distinct?: Functional_test_executionsScalarFieldEnum | Functional_test_executionsScalarFieldEnum[]
  }

  /**
   * functional_test_executions findFirstOrThrow
   */
  export type functional_test_executionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_executions to fetch.
     */
    where?: functional_test_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functional_test_executions to fetch.
     */
    orderBy?: functional_test_executionsOrderByWithRelationInput | functional_test_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for functional_test_executions.
     */
    cursor?: functional_test_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functional_test_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functional_test_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of functional_test_executions.
     */
    distinct?: Functional_test_executionsScalarFieldEnum | Functional_test_executionsScalarFieldEnum[]
  }

  /**
   * functional_test_executions findMany
   */
  export type functional_test_executionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * Filter, which functional_test_executions to fetch.
     */
    where?: functional_test_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functional_test_executions to fetch.
     */
    orderBy?: functional_test_executionsOrderByWithRelationInput | functional_test_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing functional_test_executions.
     */
    cursor?: functional_test_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functional_test_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functional_test_executions.
     */
    skip?: number
    distinct?: Functional_test_executionsScalarFieldEnum | Functional_test_executionsScalarFieldEnum[]
  }

  /**
   * functional_test_executions create
   */
  export type functional_test_executionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * The data needed to create a functional_test_executions.
     */
    data: XOR<functional_test_executionsCreateInput, functional_test_executionsUncheckedCreateInput>
  }

  /**
   * functional_test_executions createMany
   */
  export type functional_test_executionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many functional_test_executions.
     */
    data: functional_test_executionsCreateManyInput | functional_test_executionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * functional_test_executions update
   */
  export type functional_test_executionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * The data needed to update a functional_test_executions.
     */
    data: XOR<functional_test_executionsUpdateInput, functional_test_executionsUncheckedUpdateInput>
    /**
     * Choose, which functional_test_executions to update.
     */
    where: functional_test_executionsWhereUniqueInput
  }

  /**
   * functional_test_executions updateMany
   */
  export type functional_test_executionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update functional_test_executions.
     */
    data: XOR<functional_test_executionsUpdateManyMutationInput, functional_test_executionsUncheckedUpdateManyInput>
    /**
     * Filter which functional_test_executions to update
     */
    where?: functional_test_executionsWhereInput
    /**
     * Limit how many functional_test_executions to update.
     */
    limit?: number
  }

  /**
   * functional_test_executions upsert
   */
  export type functional_test_executionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * The filter to search for the functional_test_executions to update in case it exists.
     */
    where: functional_test_executionsWhereUniqueInput
    /**
     * In case the functional_test_executions found by the `where` argument doesn't exist, create a new functional_test_executions with this data.
     */
    create: XOR<functional_test_executionsCreateInput, functional_test_executionsUncheckedCreateInput>
    /**
     * In case the functional_test_executions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<functional_test_executionsUpdateInput, functional_test_executionsUncheckedUpdateInput>
  }

  /**
   * functional_test_executions delete
   */
  export type functional_test_executionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
    /**
     * Filter which functional_test_executions to delete.
     */
    where: functional_test_executionsWhereUniqueInput
  }

  /**
   * functional_test_executions deleteMany
   */
  export type functional_test_executionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which functional_test_executions to delete
     */
    where?: functional_test_executionsWhereInput
    /**
     * Limit how many functional_test_executions to delete.
     */
    limit?: number
  }

  /**
   * functional_test_executions without action
   */
  export type functional_test_executionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functional_test_executions
     */
    select?: functional_test_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the functional_test_executions
     */
    omit?: functional_test_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: functional_test_executionsInclude<ExtArgs> | null
  }


  /**
   * Model test_plans
   */

  export type AggregateTest_plans = {
    _count: Test_plansCountAggregateOutputType | null
    _avg: Test_plansAvgAggregateOutputType | null
    _sum: Test_plansSumAggregateOutputType | null
    _min: Test_plansMinAggregateOutputType | null
    _max: Test_plansMaxAggregateOutputType | null
  }

  export type Test_plansAvgAggregateOutputType = {
    id: number | null
    owner_id: number | null
  }

  export type Test_plansSumAggregateOutputType = {
    id: number | null
    owner_id: number | null
  }

  export type Test_plansMinAggregateOutputType = {
    id: number | null
    name: string | null
    short_name: string | null
    description: string | null
    project: string | null
    plan_type: $Enums.test_plan_type | null
    status: $Enums.test_plan_status | null
    owner_id: number | null
    start_date: Date | null
    end_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Test_plansMaxAggregateOutputType = {
    id: number | null
    name: string | null
    short_name: string | null
    description: string | null
    project: string | null
    plan_type: $Enums.test_plan_type | null
    status: $Enums.test_plan_status | null
    owner_id: number | null
    start_date: Date | null
    end_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Test_plansCountAggregateOutputType = {
    id: number
    name: number
    short_name: number
    description: number
    project: number
    plan_type: number
    status: number
    members: number
    owner_id: number
    start_date: number
    end_date: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Test_plansAvgAggregateInputType = {
    id?: true
    owner_id?: true
  }

  export type Test_plansSumAggregateInputType = {
    id?: true
    owner_id?: true
  }

  export type Test_plansMinAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    description?: true
    project?: true
    plan_type?: true
    status?: true
    owner_id?: true
    start_date?: true
    end_date?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Test_plansMaxAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    description?: true
    project?: true
    plan_type?: true
    status?: true
    owner_id?: true
    start_date?: true
    end_date?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Test_plansCountAggregateInputType = {
    id?: true
    name?: true
    short_name?: true
    description?: true
    project?: true
    plan_type?: true
    status?: true
    members?: true
    owner_id?: true
    start_date?: true
    end_date?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Test_plansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plans to aggregate.
     */
    where?: test_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plans to fetch.
     */
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_plans
    **/
    _count?: true | Test_plansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_plansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_plansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_plansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_plansMaxAggregateInputType
  }

  export type GetTest_plansAggregateType<T extends Test_plansAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_plans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_plans[P]>
      : GetScalarType<T[P], AggregateTest_plans[P]>
  }




  export type test_plansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plansWhereInput
    orderBy?: test_plansOrderByWithAggregationInput | test_plansOrderByWithAggregationInput[]
    by: Test_plansScalarFieldEnum[] | Test_plansScalarFieldEnum
    having?: test_plansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_plansCountAggregateInputType | true
    _avg?: Test_plansAvgAggregateInputType
    _sum?: Test_plansSumAggregateInputType
    _min?: Test_plansMinAggregateInputType
    _max?: Test_plansMaxAggregateInputType
  }

  export type Test_plansGroupByOutputType = {
    id: number
    name: string
    short_name: string | null
    description: string | null
    project: string | null
    plan_type: $Enums.test_plan_type
    status: $Enums.test_plan_status
    members: JsonValue | null
    owner_id: number
    start_date: Date | null
    end_date: Date | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Test_plansCountAggregateOutputType | null
    _avg: Test_plansAvgAggregateOutputType | null
    _sum: Test_plansSumAggregateOutputType | null
    _min: Test_plansMinAggregateOutputType | null
    _max: Test_plansMaxAggregateOutputType | null
  }

  type GetTest_plansGroupByPayload<T extends test_plansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_plansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_plansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_plansGroupByOutputType[P]>
            : GetScalarType<T[P], Test_plansGroupByOutputType[P]>
        }
      >
    >


  export type test_plansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    short_name?: boolean
    description?: boolean
    project?: boolean
    plan_type?: boolean
    status?: boolean
    members?: boolean
    owner_id?: boolean
    start_date?: boolean
    end_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    owner?: boolean | usersDefaultArgs<ExtArgs>
    plan_cases?: boolean | test_plans$plan_casesArgs<ExtArgs>
    plan_executions?: boolean | test_plans$plan_executionsArgs<ExtArgs>
    _count?: boolean | Test_plansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_plans"]>



  export type test_plansSelectScalar = {
    id?: boolean
    name?: boolean
    short_name?: boolean
    description?: boolean
    project?: boolean
    plan_type?: boolean
    status?: boolean
    members?: boolean
    owner_id?: boolean
    start_date?: boolean
    end_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type test_plansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "short_name" | "description" | "project" | "plan_type" | "status" | "members" | "owner_id" | "start_date" | "end_date" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["test_plans"]>
  export type test_plansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | usersDefaultArgs<ExtArgs>
    plan_cases?: boolean | test_plans$plan_casesArgs<ExtArgs>
    plan_executions?: boolean | test_plans$plan_executionsArgs<ExtArgs>
    _count?: boolean | Test_plansCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $test_plansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_plans"
    objects: {
      owner: Prisma.$usersPayload<ExtArgs>
      plan_cases: Prisma.$test_plan_casesPayload<ExtArgs>[]
      plan_executions: Prisma.$test_plan_executionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      short_name: string | null
      description: string | null
      project: string | null
      plan_type: $Enums.test_plan_type
      status: $Enums.test_plan_status
      members: Prisma.JsonValue | null
      owner_id: number
      start_date: Date | null
      end_date: Date | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["test_plans"]>
    composites: {}
  }

  type test_plansGetPayload<S extends boolean | null | undefined | test_plansDefaultArgs> = $Result.GetResult<Prisma.$test_plansPayload, S>

  type test_plansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_plansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_plansCountAggregateInputType | true
    }

  export interface test_plansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_plans'], meta: { name: 'test_plans' } }
    /**
     * Find zero or one Test_plans that matches the filter.
     * @param {test_plansFindUniqueArgs} args - Arguments to find a Test_plans
     * @example
     * // Get one Test_plans
     * const test_plans = await prisma.test_plans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_plansFindUniqueArgs>(args: SelectSubset<T, test_plansFindUniqueArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_plans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_plansFindUniqueOrThrowArgs} args - Arguments to find a Test_plans
     * @example
     * // Get one Test_plans
     * const test_plans = await prisma.test_plans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_plansFindUniqueOrThrowArgs>(args: SelectSubset<T, test_plansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansFindFirstArgs} args - Arguments to find a Test_plans
     * @example
     * // Get one Test_plans
     * const test_plans = await prisma.test_plans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_plansFindFirstArgs>(args?: SelectSubset<T, test_plansFindFirstArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_plans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansFindFirstOrThrowArgs} args - Arguments to find a Test_plans
     * @example
     * // Get one Test_plans
     * const test_plans = await prisma.test_plans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_plansFindFirstOrThrowArgs>(args?: SelectSubset<T, test_plansFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_plans
     * const test_plans = await prisma.test_plans.findMany()
     * 
     * // Get first 10 Test_plans
     * const test_plans = await prisma.test_plans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const test_plansWithIdOnly = await prisma.test_plans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends test_plansFindManyArgs>(args?: SelectSubset<T, test_plansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_plans.
     * @param {test_plansCreateArgs} args - Arguments to create a Test_plans.
     * @example
     * // Create one Test_plans
     * const Test_plans = await prisma.test_plans.create({
     *   data: {
     *     // ... data to create a Test_plans
     *   }
     * })
     * 
     */
    create<T extends test_plansCreateArgs>(args: SelectSubset<T, test_plansCreateArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_plans.
     * @param {test_plansCreateManyArgs} args - Arguments to create many Test_plans.
     * @example
     * // Create many Test_plans
     * const test_plans = await prisma.test_plans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_plansCreateManyArgs>(args?: SelectSubset<T, test_plansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_plans.
     * @param {test_plansDeleteArgs} args - Arguments to delete one Test_plans.
     * @example
     * // Delete one Test_plans
     * const Test_plans = await prisma.test_plans.delete({
     *   where: {
     *     // ... filter to delete one Test_plans
     *   }
     * })
     * 
     */
    delete<T extends test_plansDeleteArgs>(args: SelectSubset<T, test_plansDeleteArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_plans.
     * @param {test_plansUpdateArgs} args - Arguments to update one Test_plans.
     * @example
     * // Update one Test_plans
     * const test_plans = await prisma.test_plans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_plansUpdateArgs>(args: SelectSubset<T, test_plansUpdateArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_plans.
     * @param {test_plansDeleteManyArgs} args - Arguments to filter Test_plans to delete.
     * @example
     * // Delete a few Test_plans
     * const { count } = await prisma.test_plans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_plansDeleteManyArgs>(args?: SelectSubset<T, test_plansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_plans
     * const test_plans = await prisma.test_plans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_plansUpdateManyArgs>(args: SelectSubset<T, test_plansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_plans.
     * @param {test_plansUpsertArgs} args - Arguments to update or create a Test_plans.
     * @example
     * // Update or create a Test_plans
     * const test_plans = await prisma.test_plans.upsert({
     *   create: {
     *     // ... data to create a Test_plans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_plans we want to update
     *   }
     * })
     */
    upsert<T extends test_plansUpsertArgs>(args: SelectSubset<T, test_plansUpsertArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansCountArgs} args - Arguments to filter Test_plans to count.
     * @example
     * // Count the number of Test_plans
     * const count = await prisma.test_plans.count({
     *   where: {
     *     // ... the filter for the Test_plans we want to count
     *   }
     * })
    **/
    count<T extends test_plansCountArgs>(
      args?: Subset<T, test_plansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_plansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_plansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_plansAggregateArgs>(args: Subset<T, Test_plansAggregateArgs>): Prisma.PrismaPromise<GetTest_plansAggregateType<T>>

    /**
     * Group by Test_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_plansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_plansGroupByArgs['orderBy'] }
        : { orderBy?: test_plansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_plansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_plansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_plans model
   */
  readonly fields: test_plansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_plans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_plansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan_cases<T extends test_plans$plan_casesArgs<ExtArgs> = {}>(args?: Subset<T, test_plans$plan_casesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plan_executions<T extends test_plans$plan_executionsArgs<ExtArgs> = {}>(args?: Subset<T, test_plans$plan_executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_plans model
   */
  interface test_plansFieldRefs {
    readonly id: FieldRef<"test_plans", 'Int'>
    readonly name: FieldRef<"test_plans", 'String'>
    readonly short_name: FieldRef<"test_plans", 'String'>
    readonly description: FieldRef<"test_plans", 'String'>
    readonly project: FieldRef<"test_plans", 'String'>
    readonly plan_type: FieldRef<"test_plans", 'test_plan_type'>
    readonly status: FieldRef<"test_plans", 'test_plan_status'>
    readonly members: FieldRef<"test_plans", 'Json'>
    readonly owner_id: FieldRef<"test_plans", 'Int'>
    readonly start_date: FieldRef<"test_plans", 'DateTime'>
    readonly end_date: FieldRef<"test_plans", 'DateTime'>
    readonly created_at: FieldRef<"test_plans", 'DateTime'>
    readonly updated_at: FieldRef<"test_plans", 'DateTime'>
    readonly deleted_at: FieldRef<"test_plans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_plans findUnique
   */
  export type test_plansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where: test_plansWhereUniqueInput
  }

  /**
   * test_plans findUniqueOrThrow
   */
  export type test_plansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where: test_plansWhereUniqueInput
  }

  /**
   * test_plans findFirst
   */
  export type test_plansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where?: test_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plans to fetch.
     */
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plans.
     */
    cursor?: test_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plans.
     */
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * test_plans findFirstOrThrow
   */
  export type test_plansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where?: test_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plans to fetch.
     */
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plans.
     */
    cursor?: test_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plans.
     */
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * test_plans findMany
   */
  export type test_plansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter, which test_plans to fetch.
     */
    where?: test_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plans to fetch.
     */
    orderBy?: test_plansOrderByWithRelationInput | test_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_plans.
     */
    cursor?: test_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plans.
     */
    skip?: number
    distinct?: Test_plansScalarFieldEnum | Test_plansScalarFieldEnum[]
  }

  /**
   * test_plans create
   */
  export type test_plansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * The data needed to create a test_plans.
     */
    data: XOR<test_plansCreateInput, test_plansUncheckedCreateInput>
  }

  /**
   * test_plans createMany
   */
  export type test_plansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_plans.
     */
    data: test_plansCreateManyInput | test_plansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_plans update
   */
  export type test_plansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * The data needed to update a test_plans.
     */
    data: XOR<test_plansUpdateInput, test_plansUncheckedUpdateInput>
    /**
     * Choose, which test_plans to update.
     */
    where: test_plansWhereUniqueInput
  }

  /**
   * test_plans updateMany
   */
  export type test_plansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_plans.
     */
    data: XOR<test_plansUpdateManyMutationInput, test_plansUncheckedUpdateManyInput>
    /**
     * Filter which test_plans to update
     */
    where?: test_plansWhereInput
    /**
     * Limit how many test_plans to update.
     */
    limit?: number
  }

  /**
   * test_plans upsert
   */
  export type test_plansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * The filter to search for the test_plans to update in case it exists.
     */
    where: test_plansWhereUniqueInput
    /**
     * In case the test_plans found by the `where` argument doesn't exist, create a new test_plans with this data.
     */
    create: XOR<test_plansCreateInput, test_plansUncheckedCreateInput>
    /**
     * In case the test_plans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_plansUpdateInput, test_plansUncheckedUpdateInput>
  }

  /**
   * test_plans delete
   */
  export type test_plansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
    /**
     * Filter which test_plans to delete.
     */
    where: test_plansWhereUniqueInput
  }

  /**
   * test_plans deleteMany
   */
  export type test_plansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plans to delete
     */
    where?: test_plansWhereInput
    /**
     * Limit how many test_plans to delete.
     */
    limit?: number
  }

  /**
   * test_plans.plan_cases
   */
  export type test_plans$plan_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    where?: test_plan_casesWhereInput
    orderBy?: test_plan_casesOrderByWithRelationInput | test_plan_casesOrderByWithRelationInput[]
    cursor?: test_plan_casesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plan_casesScalarFieldEnum | Test_plan_casesScalarFieldEnum[]
  }

  /**
   * test_plans.plan_executions
   */
  export type test_plans$plan_executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    where?: test_plan_executionsWhereInput
    orderBy?: test_plan_executionsOrderByWithRelationInput | test_plan_executionsOrderByWithRelationInput[]
    cursor?: test_plan_executionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_plan_executionsScalarFieldEnum | Test_plan_executionsScalarFieldEnum[]
  }

  /**
   * test_plans without action
   */
  export type test_plansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plans
     */
    select?: test_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plans
     */
    omit?: test_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plansInclude<ExtArgs> | null
  }


  /**
   * Model test_plan_cases
   */

  export type AggregateTest_plan_cases = {
    _count: Test_plan_casesCountAggregateOutputType | null
    _avg: Test_plan_casesAvgAggregateOutputType | null
    _sum: Test_plan_casesSumAggregateOutputType | null
    _min: Test_plan_casesMinAggregateOutputType | null
    _max: Test_plan_casesMaxAggregateOutputType | null
  }

  export type Test_plan_casesAvgAggregateOutputType = {
    id: number | null
    plan_id: number | null
    case_id: number | null
    sort_order: number | null
  }

  export type Test_plan_casesSumAggregateOutputType = {
    id: number | null
    plan_id: number | null
    case_id: number | null
    sort_order: number | null
  }

  export type Test_plan_casesMinAggregateOutputType = {
    id: number | null
    plan_id: number | null
    case_id: number | null
    case_type: string | null
    case_name: string | null
    sort_order: number | null
    is_executed: boolean | null
    execution_result: string | null
    created_at: Date | null
  }

  export type Test_plan_casesMaxAggregateOutputType = {
    id: number | null
    plan_id: number | null
    case_id: number | null
    case_type: string | null
    case_name: string | null
    sort_order: number | null
    is_executed: boolean | null
    execution_result: string | null
    created_at: Date | null
  }

  export type Test_plan_casesCountAggregateOutputType = {
    id: number
    plan_id: number
    case_id: number
    case_type: number
    case_name: number
    sort_order: number
    is_executed: number
    execution_result: number
    created_at: number
    _all: number
  }


  export type Test_plan_casesAvgAggregateInputType = {
    id?: true
    plan_id?: true
    case_id?: true
    sort_order?: true
  }

  export type Test_plan_casesSumAggregateInputType = {
    id?: true
    plan_id?: true
    case_id?: true
    sort_order?: true
  }

  export type Test_plan_casesMinAggregateInputType = {
    id?: true
    plan_id?: true
    case_id?: true
    case_type?: true
    case_name?: true
    sort_order?: true
    is_executed?: true
    execution_result?: true
    created_at?: true
  }

  export type Test_plan_casesMaxAggregateInputType = {
    id?: true
    plan_id?: true
    case_id?: true
    case_type?: true
    case_name?: true
    sort_order?: true
    is_executed?: true
    execution_result?: true
    created_at?: true
  }

  export type Test_plan_casesCountAggregateInputType = {
    id?: true
    plan_id?: true
    case_id?: true
    case_type?: true
    case_name?: true
    sort_order?: true
    is_executed?: true
    execution_result?: true
    created_at?: true
    _all?: true
  }

  export type Test_plan_casesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plan_cases to aggregate.
     */
    where?: test_plan_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_cases to fetch.
     */
    orderBy?: test_plan_casesOrderByWithRelationInput | test_plan_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_plan_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_plan_cases
    **/
    _count?: true | Test_plan_casesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_plan_casesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_plan_casesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_plan_casesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_plan_casesMaxAggregateInputType
  }

  export type GetTest_plan_casesAggregateType<T extends Test_plan_casesAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_plan_cases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_plan_cases[P]>
      : GetScalarType<T[P], AggregateTest_plan_cases[P]>
  }




  export type test_plan_casesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plan_casesWhereInput
    orderBy?: test_plan_casesOrderByWithAggregationInput | test_plan_casesOrderByWithAggregationInput[]
    by: Test_plan_casesScalarFieldEnum[] | Test_plan_casesScalarFieldEnum
    having?: test_plan_casesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_plan_casesCountAggregateInputType | true
    _avg?: Test_plan_casesAvgAggregateInputType
    _sum?: Test_plan_casesSumAggregateInputType
    _min?: Test_plan_casesMinAggregateInputType
    _max?: Test_plan_casesMaxAggregateInputType
  }

  export type Test_plan_casesGroupByOutputType = {
    id: number
    plan_id: number
    case_id: number
    case_type: string
    case_name: string
    sort_order: number
    is_executed: boolean
    execution_result: string | null
    created_at: Date
    _count: Test_plan_casesCountAggregateOutputType | null
    _avg: Test_plan_casesAvgAggregateOutputType | null
    _sum: Test_plan_casesSumAggregateOutputType | null
    _min: Test_plan_casesMinAggregateOutputType | null
    _max: Test_plan_casesMaxAggregateOutputType | null
  }

  type GetTest_plan_casesGroupByPayload<T extends test_plan_casesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_plan_casesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_plan_casesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_plan_casesGroupByOutputType[P]>
            : GetScalarType<T[P], Test_plan_casesGroupByOutputType[P]>
        }
      >
    >


  export type test_plan_casesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plan_id?: boolean
    case_id?: boolean
    case_type?: boolean
    case_name?: boolean
    sort_order?: boolean
    is_executed?: boolean
    execution_result?: boolean
    created_at?: boolean
    plan?: boolean | test_plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_plan_cases"]>



  export type test_plan_casesSelectScalar = {
    id?: boolean
    plan_id?: boolean
    case_id?: boolean
    case_type?: boolean
    case_name?: boolean
    sort_order?: boolean
    is_executed?: boolean
    execution_result?: boolean
    created_at?: boolean
  }

  export type test_plan_casesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plan_id" | "case_id" | "case_type" | "case_name" | "sort_order" | "is_executed" | "execution_result" | "created_at", ExtArgs["result"]["test_plan_cases"]>
  export type test_plan_casesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | test_plansDefaultArgs<ExtArgs>
  }

  export type $test_plan_casesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_plan_cases"
    objects: {
      plan: Prisma.$test_plansPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plan_id: number
      case_id: number
      case_type: string
      case_name: string
      sort_order: number
      is_executed: boolean
      execution_result: string | null
      created_at: Date
    }, ExtArgs["result"]["test_plan_cases"]>
    composites: {}
  }

  type test_plan_casesGetPayload<S extends boolean | null | undefined | test_plan_casesDefaultArgs> = $Result.GetResult<Prisma.$test_plan_casesPayload, S>

  type test_plan_casesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_plan_casesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_plan_casesCountAggregateInputType | true
    }

  export interface test_plan_casesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_plan_cases'], meta: { name: 'test_plan_cases' } }
    /**
     * Find zero or one Test_plan_cases that matches the filter.
     * @param {test_plan_casesFindUniqueArgs} args - Arguments to find a Test_plan_cases
     * @example
     * // Get one Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_plan_casesFindUniqueArgs>(args: SelectSubset<T, test_plan_casesFindUniqueArgs<ExtArgs>>): Prisma__test_plan_casesClient<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_plan_cases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_plan_casesFindUniqueOrThrowArgs} args - Arguments to find a Test_plan_cases
     * @example
     * // Get one Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_plan_casesFindUniqueOrThrowArgs>(args: SelectSubset<T, test_plan_casesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_plan_casesClient<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_plan_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_casesFindFirstArgs} args - Arguments to find a Test_plan_cases
     * @example
     * // Get one Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_plan_casesFindFirstArgs>(args?: SelectSubset<T, test_plan_casesFindFirstArgs<ExtArgs>>): Prisma__test_plan_casesClient<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_plan_cases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_casesFindFirstOrThrowArgs} args - Arguments to find a Test_plan_cases
     * @example
     * // Get one Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_plan_casesFindFirstOrThrowArgs>(args?: SelectSubset<T, test_plan_casesFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_plan_casesClient<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_plan_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_casesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.findMany()
     * 
     * // Get first 10 Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const test_plan_casesWithIdOnly = await prisma.test_plan_cases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends test_plan_casesFindManyArgs>(args?: SelectSubset<T, test_plan_casesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_plan_cases.
     * @param {test_plan_casesCreateArgs} args - Arguments to create a Test_plan_cases.
     * @example
     * // Create one Test_plan_cases
     * const Test_plan_cases = await prisma.test_plan_cases.create({
     *   data: {
     *     // ... data to create a Test_plan_cases
     *   }
     * })
     * 
     */
    create<T extends test_plan_casesCreateArgs>(args: SelectSubset<T, test_plan_casesCreateArgs<ExtArgs>>): Prisma__test_plan_casesClient<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_plan_cases.
     * @param {test_plan_casesCreateManyArgs} args - Arguments to create many Test_plan_cases.
     * @example
     * // Create many Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_plan_casesCreateManyArgs>(args?: SelectSubset<T, test_plan_casesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_plan_cases.
     * @param {test_plan_casesDeleteArgs} args - Arguments to delete one Test_plan_cases.
     * @example
     * // Delete one Test_plan_cases
     * const Test_plan_cases = await prisma.test_plan_cases.delete({
     *   where: {
     *     // ... filter to delete one Test_plan_cases
     *   }
     * })
     * 
     */
    delete<T extends test_plan_casesDeleteArgs>(args: SelectSubset<T, test_plan_casesDeleteArgs<ExtArgs>>): Prisma__test_plan_casesClient<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_plan_cases.
     * @param {test_plan_casesUpdateArgs} args - Arguments to update one Test_plan_cases.
     * @example
     * // Update one Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_plan_casesUpdateArgs>(args: SelectSubset<T, test_plan_casesUpdateArgs<ExtArgs>>): Prisma__test_plan_casesClient<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_plan_cases.
     * @param {test_plan_casesDeleteManyArgs} args - Arguments to filter Test_plan_cases to delete.
     * @example
     * // Delete a few Test_plan_cases
     * const { count } = await prisma.test_plan_cases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_plan_casesDeleteManyArgs>(args?: SelectSubset<T, test_plan_casesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_plan_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_casesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_plan_casesUpdateManyArgs>(args: SelectSubset<T, test_plan_casesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_plan_cases.
     * @param {test_plan_casesUpsertArgs} args - Arguments to update or create a Test_plan_cases.
     * @example
     * // Update or create a Test_plan_cases
     * const test_plan_cases = await prisma.test_plan_cases.upsert({
     *   create: {
     *     // ... data to create a Test_plan_cases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_plan_cases we want to update
     *   }
     * })
     */
    upsert<T extends test_plan_casesUpsertArgs>(args: SelectSubset<T, test_plan_casesUpsertArgs<ExtArgs>>): Prisma__test_plan_casesClient<$Result.GetResult<Prisma.$test_plan_casesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_plan_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_casesCountArgs} args - Arguments to filter Test_plan_cases to count.
     * @example
     * // Count the number of Test_plan_cases
     * const count = await prisma.test_plan_cases.count({
     *   where: {
     *     // ... the filter for the Test_plan_cases we want to count
     *   }
     * })
    **/
    count<T extends test_plan_casesCountArgs>(
      args?: Subset<T, test_plan_casesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_plan_casesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_plan_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_plan_casesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_plan_casesAggregateArgs>(args: Subset<T, Test_plan_casesAggregateArgs>): Prisma.PrismaPromise<GetTest_plan_casesAggregateType<T>>

    /**
     * Group by Test_plan_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_casesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_plan_casesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_plan_casesGroupByArgs['orderBy'] }
        : { orderBy?: test_plan_casesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_plan_casesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_plan_casesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_plan_cases model
   */
  readonly fields: test_plan_casesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_plan_cases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_plan_casesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends test_plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_plansDefaultArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_plan_cases model
   */
  interface test_plan_casesFieldRefs {
    readonly id: FieldRef<"test_plan_cases", 'Int'>
    readonly plan_id: FieldRef<"test_plan_cases", 'Int'>
    readonly case_id: FieldRef<"test_plan_cases", 'Int'>
    readonly case_type: FieldRef<"test_plan_cases", 'String'>
    readonly case_name: FieldRef<"test_plan_cases", 'String'>
    readonly sort_order: FieldRef<"test_plan_cases", 'Int'>
    readonly is_executed: FieldRef<"test_plan_cases", 'Boolean'>
    readonly execution_result: FieldRef<"test_plan_cases", 'String'>
    readonly created_at: FieldRef<"test_plan_cases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * test_plan_cases findUnique
   */
  export type test_plan_casesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_cases to fetch.
     */
    where: test_plan_casesWhereUniqueInput
  }

  /**
   * test_plan_cases findUniqueOrThrow
   */
  export type test_plan_casesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_cases to fetch.
     */
    where: test_plan_casesWhereUniqueInput
  }

  /**
   * test_plan_cases findFirst
   */
  export type test_plan_casesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_cases to fetch.
     */
    where?: test_plan_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_cases to fetch.
     */
    orderBy?: test_plan_casesOrderByWithRelationInput | test_plan_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plan_cases.
     */
    cursor?: test_plan_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plan_cases.
     */
    distinct?: Test_plan_casesScalarFieldEnum | Test_plan_casesScalarFieldEnum[]
  }

  /**
   * test_plan_cases findFirstOrThrow
   */
  export type test_plan_casesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_cases to fetch.
     */
    where?: test_plan_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_cases to fetch.
     */
    orderBy?: test_plan_casesOrderByWithRelationInput | test_plan_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plan_cases.
     */
    cursor?: test_plan_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plan_cases.
     */
    distinct?: Test_plan_casesScalarFieldEnum | Test_plan_casesScalarFieldEnum[]
  }

  /**
   * test_plan_cases findMany
   */
  export type test_plan_casesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_cases to fetch.
     */
    where?: test_plan_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_cases to fetch.
     */
    orderBy?: test_plan_casesOrderByWithRelationInput | test_plan_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_plan_cases.
     */
    cursor?: test_plan_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_cases.
     */
    skip?: number
    distinct?: Test_plan_casesScalarFieldEnum | Test_plan_casesScalarFieldEnum[]
  }

  /**
   * test_plan_cases create
   */
  export type test_plan_casesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * The data needed to create a test_plan_cases.
     */
    data: XOR<test_plan_casesCreateInput, test_plan_casesUncheckedCreateInput>
  }

  /**
   * test_plan_cases createMany
   */
  export type test_plan_casesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_plan_cases.
     */
    data: test_plan_casesCreateManyInput | test_plan_casesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_plan_cases update
   */
  export type test_plan_casesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * The data needed to update a test_plan_cases.
     */
    data: XOR<test_plan_casesUpdateInput, test_plan_casesUncheckedUpdateInput>
    /**
     * Choose, which test_plan_cases to update.
     */
    where: test_plan_casesWhereUniqueInput
  }

  /**
   * test_plan_cases updateMany
   */
  export type test_plan_casesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_plan_cases.
     */
    data: XOR<test_plan_casesUpdateManyMutationInput, test_plan_casesUncheckedUpdateManyInput>
    /**
     * Filter which test_plan_cases to update
     */
    where?: test_plan_casesWhereInput
    /**
     * Limit how many test_plan_cases to update.
     */
    limit?: number
  }

  /**
   * test_plan_cases upsert
   */
  export type test_plan_casesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * The filter to search for the test_plan_cases to update in case it exists.
     */
    where: test_plan_casesWhereUniqueInput
    /**
     * In case the test_plan_cases found by the `where` argument doesn't exist, create a new test_plan_cases with this data.
     */
    create: XOR<test_plan_casesCreateInput, test_plan_casesUncheckedCreateInput>
    /**
     * In case the test_plan_cases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_plan_casesUpdateInput, test_plan_casesUncheckedUpdateInput>
  }

  /**
   * test_plan_cases delete
   */
  export type test_plan_casesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
    /**
     * Filter which test_plan_cases to delete.
     */
    where: test_plan_casesWhereUniqueInput
  }

  /**
   * test_plan_cases deleteMany
   */
  export type test_plan_casesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plan_cases to delete
     */
    where?: test_plan_casesWhereInput
    /**
     * Limit how many test_plan_cases to delete.
     */
    limit?: number
  }

  /**
   * test_plan_cases without action
   */
  export type test_plan_casesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_cases
     */
    select?: test_plan_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_cases
     */
    omit?: test_plan_casesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_casesInclude<ExtArgs> | null
  }


  /**
   * Model test_plan_executions
   */

  export type AggregateTest_plan_executions = {
    _count: Test_plan_executionsCountAggregateOutputType | null
    _avg: Test_plan_executionsAvgAggregateOutputType | null
    _sum: Test_plan_executionsSumAggregateOutputType | null
    _min: Test_plan_executionsMinAggregateOutputType | null
    _max: Test_plan_executionsMaxAggregateOutputType | null
  }

  export type Test_plan_executionsAvgAggregateOutputType = {
    plan_id: number | null
    executor_id: number | null
    progress: number | null
    total_cases: number | null
    completed_cases: number | null
    passed_cases: number | null
    failed_cases: number | null
    blocked_cases: number | null
    skipped_cases: number | null
    duration_ms: number | null
  }

  export type Test_plan_executionsSumAggregateOutputType = {
    plan_id: number | null
    executor_id: number | null
    progress: number | null
    total_cases: number | null
    completed_cases: number | null
    passed_cases: number | null
    failed_cases: number | null
    blocked_cases: number | null
    skipped_cases: number | null
    duration_ms: number | null
  }

  export type Test_plan_executionsMinAggregateOutputType = {
    id: string | null
    plan_id: number | null
    plan_name: string | null
    executor_id: number | null
    executor_name: string | null
    execution_type: string | null
    status: string | null
    progress: number | null
    total_cases: number | null
    completed_cases: number | null
    passed_cases: number | null
    failed_cases: number | null
    blocked_cases: number | null
    skipped_cases: number | null
    started_at: Date | null
    finished_at: Date | null
    duration_ms: number | null
    error_message: string | null
  }

  export type Test_plan_executionsMaxAggregateOutputType = {
    id: string | null
    plan_id: number | null
    plan_name: string | null
    executor_id: number | null
    executor_name: string | null
    execution_type: string | null
    status: string | null
    progress: number | null
    total_cases: number | null
    completed_cases: number | null
    passed_cases: number | null
    failed_cases: number | null
    blocked_cases: number | null
    skipped_cases: number | null
    started_at: Date | null
    finished_at: Date | null
    duration_ms: number | null
    error_message: string | null
  }

  export type Test_plan_executionsCountAggregateOutputType = {
    id: number
    plan_id: number
    plan_name: number
    executor_id: number
    executor_name: number
    execution_type: number
    status: number
    progress: number
    total_cases: number
    completed_cases: number
    passed_cases: number
    failed_cases: number
    blocked_cases: number
    skipped_cases: number
    started_at: number
    finished_at: number
    duration_ms: number
    execution_results: number
    error_message: number
    metadata: number
    _all: number
  }


  export type Test_plan_executionsAvgAggregateInputType = {
    plan_id?: true
    executor_id?: true
    progress?: true
    total_cases?: true
    completed_cases?: true
    passed_cases?: true
    failed_cases?: true
    blocked_cases?: true
    skipped_cases?: true
    duration_ms?: true
  }

  export type Test_plan_executionsSumAggregateInputType = {
    plan_id?: true
    executor_id?: true
    progress?: true
    total_cases?: true
    completed_cases?: true
    passed_cases?: true
    failed_cases?: true
    blocked_cases?: true
    skipped_cases?: true
    duration_ms?: true
  }

  export type Test_plan_executionsMinAggregateInputType = {
    id?: true
    plan_id?: true
    plan_name?: true
    executor_id?: true
    executor_name?: true
    execution_type?: true
    status?: true
    progress?: true
    total_cases?: true
    completed_cases?: true
    passed_cases?: true
    failed_cases?: true
    blocked_cases?: true
    skipped_cases?: true
    started_at?: true
    finished_at?: true
    duration_ms?: true
    error_message?: true
  }

  export type Test_plan_executionsMaxAggregateInputType = {
    id?: true
    plan_id?: true
    plan_name?: true
    executor_id?: true
    executor_name?: true
    execution_type?: true
    status?: true
    progress?: true
    total_cases?: true
    completed_cases?: true
    passed_cases?: true
    failed_cases?: true
    blocked_cases?: true
    skipped_cases?: true
    started_at?: true
    finished_at?: true
    duration_ms?: true
    error_message?: true
  }

  export type Test_plan_executionsCountAggregateInputType = {
    id?: true
    plan_id?: true
    plan_name?: true
    executor_id?: true
    executor_name?: true
    execution_type?: true
    status?: true
    progress?: true
    total_cases?: true
    completed_cases?: true
    passed_cases?: true
    failed_cases?: true
    blocked_cases?: true
    skipped_cases?: true
    started_at?: true
    finished_at?: true
    duration_ms?: true
    execution_results?: true
    error_message?: true
    metadata?: true
    _all?: true
  }

  export type Test_plan_executionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plan_executions to aggregate.
     */
    where?: test_plan_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_executions to fetch.
     */
    orderBy?: test_plan_executionsOrderByWithRelationInput | test_plan_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_plan_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_plan_executions
    **/
    _count?: true | Test_plan_executionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_plan_executionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_plan_executionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_plan_executionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_plan_executionsMaxAggregateInputType
  }

  export type GetTest_plan_executionsAggregateType<T extends Test_plan_executionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_plan_executions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_plan_executions[P]>
      : GetScalarType<T[P], AggregateTest_plan_executions[P]>
  }




  export type test_plan_executionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_plan_executionsWhereInput
    orderBy?: test_plan_executionsOrderByWithAggregationInput | test_plan_executionsOrderByWithAggregationInput[]
    by: Test_plan_executionsScalarFieldEnum[] | Test_plan_executionsScalarFieldEnum
    having?: test_plan_executionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_plan_executionsCountAggregateInputType | true
    _avg?: Test_plan_executionsAvgAggregateInputType
    _sum?: Test_plan_executionsSumAggregateInputType
    _min?: Test_plan_executionsMinAggregateInputType
    _max?: Test_plan_executionsMaxAggregateInputType
  }

  export type Test_plan_executionsGroupByOutputType = {
    id: string
    plan_id: number
    plan_name: string
    executor_id: number
    executor_name: string
    execution_type: string
    status: string
    progress: number
    total_cases: number
    completed_cases: number
    passed_cases: number
    failed_cases: number
    blocked_cases: number
    skipped_cases: number
    started_at: Date
    finished_at: Date | null
    duration_ms: number | null
    execution_results: JsonValue | null
    error_message: string | null
    metadata: JsonValue | null
    _count: Test_plan_executionsCountAggregateOutputType | null
    _avg: Test_plan_executionsAvgAggregateOutputType | null
    _sum: Test_plan_executionsSumAggregateOutputType | null
    _min: Test_plan_executionsMinAggregateOutputType | null
    _max: Test_plan_executionsMaxAggregateOutputType | null
  }

  type GetTest_plan_executionsGroupByPayload<T extends test_plan_executionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_plan_executionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_plan_executionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_plan_executionsGroupByOutputType[P]>
            : GetScalarType<T[P], Test_plan_executionsGroupByOutputType[P]>
        }
      >
    >


  export type test_plan_executionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plan_id?: boolean
    plan_name?: boolean
    executor_id?: boolean
    executor_name?: boolean
    execution_type?: boolean
    status?: boolean
    progress?: boolean
    total_cases?: boolean
    completed_cases?: boolean
    passed_cases?: boolean
    failed_cases?: boolean
    blocked_cases?: boolean
    skipped_cases?: boolean
    started_at?: boolean
    finished_at?: boolean
    duration_ms?: boolean
    execution_results?: boolean
    error_message?: boolean
    metadata?: boolean
    plan?: boolean | test_plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test_plan_executions"]>



  export type test_plan_executionsSelectScalar = {
    id?: boolean
    plan_id?: boolean
    plan_name?: boolean
    executor_id?: boolean
    executor_name?: boolean
    execution_type?: boolean
    status?: boolean
    progress?: boolean
    total_cases?: boolean
    completed_cases?: boolean
    passed_cases?: boolean
    failed_cases?: boolean
    blocked_cases?: boolean
    skipped_cases?: boolean
    started_at?: boolean
    finished_at?: boolean
    duration_ms?: boolean
    execution_results?: boolean
    error_message?: boolean
    metadata?: boolean
  }

  export type test_plan_executionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plan_id" | "plan_name" | "executor_id" | "executor_name" | "execution_type" | "status" | "progress" | "total_cases" | "completed_cases" | "passed_cases" | "failed_cases" | "blocked_cases" | "skipped_cases" | "started_at" | "finished_at" | "duration_ms" | "execution_results" | "error_message" | "metadata", ExtArgs["result"]["test_plan_executions"]>
  export type test_plan_executionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | test_plansDefaultArgs<ExtArgs>
  }

  export type $test_plan_executionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_plan_executions"
    objects: {
      plan: Prisma.$test_plansPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      plan_id: number
      plan_name: string
      executor_id: number
      executor_name: string
      execution_type: string
      status: string
      progress: number
      total_cases: number
      completed_cases: number
      passed_cases: number
      failed_cases: number
      blocked_cases: number
      skipped_cases: number
      started_at: Date
      finished_at: Date | null
      duration_ms: number | null
      execution_results: Prisma.JsonValue | null
      error_message: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["test_plan_executions"]>
    composites: {}
  }

  type test_plan_executionsGetPayload<S extends boolean | null | undefined | test_plan_executionsDefaultArgs> = $Result.GetResult<Prisma.$test_plan_executionsPayload, S>

  type test_plan_executionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_plan_executionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_plan_executionsCountAggregateInputType | true
    }

  export interface test_plan_executionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_plan_executions'], meta: { name: 'test_plan_executions' } }
    /**
     * Find zero or one Test_plan_executions that matches the filter.
     * @param {test_plan_executionsFindUniqueArgs} args - Arguments to find a Test_plan_executions
     * @example
     * // Get one Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_plan_executionsFindUniqueArgs>(args: SelectSubset<T, test_plan_executionsFindUniqueArgs<ExtArgs>>): Prisma__test_plan_executionsClient<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_plan_executions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_plan_executionsFindUniqueOrThrowArgs} args - Arguments to find a Test_plan_executions
     * @example
     * // Get one Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_plan_executionsFindUniqueOrThrowArgs>(args: SelectSubset<T, test_plan_executionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_plan_executionsClient<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_plan_executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_executionsFindFirstArgs} args - Arguments to find a Test_plan_executions
     * @example
     * // Get one Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_plan_executionsFindFirstArgs>(args?: SelectSubset<T, test_plan_executionsFindFirstArgs<ExtArgs>>): Prisma__test_plan_executionsClient<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_plan_executions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_executionsFindFirstOrThrowArgs} args - Arguments to find a Test_plan_executions
     * @example
     * // Get one Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_plan_executionsFindFirstOrThrowArgs>(args?: SelectSubset<T, test_plan_executionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_plan_executionsClient<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_plan_executions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_executionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.findMany()
     * 
     * // Get first 10 Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const test_plan_executionsWithIdOnly = await prisma.test_plan_executions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends test_plan_executionsFindManyArgs>(args?: SelectSubset<T, test_plan_executionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_plan_executions.
     * @param {test_plan_executionsCreateArgs} args - Arguments to create a Test_plan_executions.
     * @example
     * // Create one Test_plan_executions
     * const Test_plan_executions = await prisma.test_plan_executions.create({
     *   data: {
     *     // ... data to create a Test_plan_executions
     *   }
     * })
     * 
     */
    create<T extends test_plan_executionsCreateArgs>(args: SelectSubset<T, test_plan_executionsCreateArgs<ExtArgs>>): Prisma__test_plan_executionsClient<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_plan_executions.
     * @param {test_plan_executionsCreateManyArgs} args - Arguments to create many Test_plan_executions.
     * @example
     * // Create many Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_plan_executionsCreateManyArgs>(args?: SelectSubset<T, test_plan_executionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_plan_executions.
     * @param {test_plan_executionsDeleteArgs} args - Arguments to delete one Test_plan_executions.
     * @example
     * // Delete one Test_plan_executions
     * const Test_plan_executions = await prisma.test_plan_executions.delete({
     *   where: {
     *     // ... filter to delete one Test_plan_executions
     *   }
     * })
     * 
     */
    delete<T extends test_plan_executionsDeleteArgs>(args: SelectSubset<T, test_plan_executionsDeleteArgs<ExtArgs>>): Prisma__test_plan_executionsClient<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_plan_executions.
     * @param {test_plan_executionsUpdateArgs} args - Arguments to update one Test_plan_executions.
     * @example
     * // Update one Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_plan_executionsUpdateArgs>(args: SelectSubset<T, test_plan_executionsUpdateArgs<ExtArgs>>): Prisma__test_plan_executionsClient<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_plan_executions.
     * @param {test_plan_executionsDeleteManyArgs} args - Arguments to filter Test_plan_executions to delete.
     * @example
     * // Delete a few Test_plan_executions
     * const { count } = await prisma.test_plan_executions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_plan_executionsDeleteManyArgs>(args?: SelectSubset<T, test_plan_executionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_plan_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_executionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_plan_executionsUpdateManyArgs>(args: SelectSubset<T, test_plan_executionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_plan_executions.
     * @param {test_plan_executionsUpsertArgs} args - Arguments to update or create a Test_plan_executions.
     * @example
     * // Update or create a Test_plan_executions
     * const test_plan_executions = await prisma.test_plan_executions.upsert({
     *   create: {
     *     // ... data to create a Test_plan_executions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_plan_executions we want to update
     *   }
     * })
     */
    upsert<T extends test_plan_executionsUpsertArgs>(args: SelectSubset<T, test_plan_executionsUpsertArgs<ExtArgs>>): Prisma__test_plan_executionsClient<$Result.GetResult<Prisma.$test_plan_executionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_plan_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_executionsCountArgs} args - Arguments to filter Test_plan_executions to count.
     * @example
     * // Count the number of Test_plan_executions
     * const count = await prisma.test_plan_executions.count({
     *   where: {
     *     // ... the filter for the Test_plan_executions we want to count
     *   }
     * })
    **/
    count<T extends test_plan_executionsCountArgs>(
      args?: Subset<T, test_plan_executionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_plan_executionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_plan_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_plan_executionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_plan_executionsAggregateArgs>(args: Subset<T, Test_plan_executionsAggregateArgs>): Prisma.PrismaPromise<GetTest_plan_executionsAggregateType<T>>

    /**
     * Group by Test_plan_executions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_plan_executionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_plan_executionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_plan_executionsGroupByArgs['orderBy'] }
        : { orderBy?: test_plan_executionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_plan_executionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_plan_executionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_plan_executions model
   */
  readonly fields: test_plan_executionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_plan_executions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_plan_executionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends test_plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, test_plansDefaultArgs<ExtArgs>>): Prisma__test_plansClient<$Result.GetResult<Prisma.$test_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_plan_executions model
   */
  interface test_plan_executionsFieldRefs {
    readonly id: FieldRef<"test_plan_executions", 'String'>
    readonly plan_id: FieldRef<"test_plan_executions", 'Int'>
    readonly plan_name: FieldRef<"test_plan_executions", 'String'>
    readonly executor_id: FieldRef<"test_plan_executions", 'Int'>
    readonly executor_name: FieldRef<"test_plan_executions", 'String'>
    readonly execution_type: FieldRef<"test_plan_executions", 'String'>
    readonly status: FieldRef<"test_plan_executions", 'String'>
    readonly progress: FieldRef<"test_plan_executions", 'Int'>
    readonly total_cases: FieldRef<"test_plan_executions", 'Int'>
    readonly completed_cases: FieldRef<"test_plan_executions", 'Int'>
    readonly passed_cases: FieldRef<"test_plan_executions", 'Int'>
    readonly failed_cases: FieldRef<"test_plan_executions", 'Int'>
    readonly blocked_cases: FieldRef<"test_plan_executions", 'Int'>
    readonly skipped_cases: FieldRef<"test_plan_executions", 'Int'>
    readonly started_at: FieldRef<"test_plan_executions", 'DateTime'>
    readonly finished_at: FieldRef<"test_plan_executions", 'DateTime'>
    readonly duration_ms: FieldRef<"test_plan_executions", 'Int'>
    readonly execution_results: FieldRef<"test_plan_executions", 'Json'>
    readonly error_message: FieldRef<"test_plan_executions", 'String'>
    readonly metadata: FieldRef<"test_plan_executions", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * test_plan_executions findUnique
   */
  export type test_plan_executionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_executions to fetch.
     */
    where: test_plan_executionsWhereUniqueInput
  }

  /**
   * test_plan_executions findUniqueOrThrow
   */
  export type test_plan_executionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_executions to fetch.
     */
    where: test_plan_executionsWhereUniqueInput
  }

  /**
   * test_plan_executions findFirst
   */
  export type test_plan_executionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_executions to fetch.
     */
    where?: test_plan_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_executions to fetch.
     */
    orderBy?: test_plan_executionsOrderByWithRelationInput | test_plan_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plan_executions.
     */
    cursor?: test_plan_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plan_executions.
     */
    distinct?: Test_plan_executionsScalarFieldEnum | Test_plan_executionsScalarFieldEnum[]
  }

  /**
   * test_plan_executions findFirstOrThrow
   */
  export type test_plan_executionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_executions to fetch.
     */
    where?: test_plan_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_executions to fetch.
     */
    orderBy?: test_plan_executionsOrderByWithRelationInput | test_plan_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_plan_executions.
     */
    cursor?: test_plan_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_executions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_plan_executions.
     */
    distinct?: Test_plan_executionsScalarFieldEnum | Test_plan_executionsScalarFieldEnum[]
  }

  /**
   * test_plan_executions findMany
   */
  export type test_plan_executionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * Filter, which test_plan_executions to fetch.
     */
    where?: test_plan_executionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_plan_executions to fetch.
     */
    orderBy?: test_plan_executionsOrderByWithRelationInput | test_plan_executionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_plan_executions.
     */
    cursor?: test_plan_executionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_plan_executions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_plan_executions.
     */
    skip?: number
    distinct?: Test_plan_executionsScalarFieldEnum | Test_plan_executionsScalarFieldEnum[]
  }

  /**
   * test_plan_executions create
   */
  export type test_plan_executionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * The data needed to create a test_plan_executions.
     */
    data: XOR<test_plan_executionsCreateInput, test_plan_executionsUncheckedCreateInput>
  }

  /**
   * test_plan_executions createMany
   */
  export type test_plan_executionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_plan_executions.
     */
    data: test_plan_executionsCreateManyInput | test_plan_executionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_plan_executions update
   */
  export type test_plan_executionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * The data needed to update a test_plan_executions.
     */
    data: XOR<test_plan_executionsUpdateInput, test_plan_executionsUncheckedUpdateInput>
    /**
     * Choose, which test_plan_executions to update.
     */
    where: test_plan_executionsWhereUniqueInput
  }

  /**
   * test_plan_executions updateMany
   */
  export type test_plan_executionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_plan_executions.
     */
    data: XOR<test_plan_executionsUpdateManyMutationInput, test_plan_executionsUncheckedUpdateManyInput>
    /**
     * Filter which test_plan_executions to update
     */
    where?: test_plan_executionsWhereInput
    /**
     * Limit how many test_plan_executions to update.
     */
    limit?: number
  }

  /**
   * test_plan_executions upsert
   */
  export type test_plan_executionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * The filter to search for the test_plan_executions to update in case it exists.
     */
    where: test_plan_executionsWhereUniqueInput
    /**
     * In case the test_plan_executions found by the `where` argument doesn't exist, create a new test_plan_executions with this data.
     */
    create: XOR<test_plan_executionsCreateInput, test_plan_executionsUncheckedCreateInput>
    /**
     * In case the test_plan_executions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_plan_executionsUpdateInput, test_plan_executionsUncheckedUpdateInput>
  }

  /**
   * test_plan_executions delete
   */
  export type test_plan_executionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
    /**
     * Filter which test_plan_executions to delete.
     */
    where: test_plan_executionsWhereUniqueInput
  }

  /**
   * test_plan_executions deleteMany
   */
  export type test_plan_executionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_plan_executions to delete
     */
    where?: test_plan_executionsWhereInput
    /**
     * Limit how many test_plan_executions to delete.
     */
    limit?: number
  }

  /**
   * test_plan_executions without action
   */
  export type test_plan_executionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_plan_executions
     */
    select?: test_plan_executionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_plan_executions
     */
    omit?: test_plan_executionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_plan_executionsInclude<ExtArgs> | null
  }


  /**
   * Model ai_element_cache
   */

  export type AggregateAi_element_cache = {
    _count: Ai_element_cacheCountAggregateOutputType | null
    _avg: Ai_element_cacheAvgAggregateOutputType | null
    _sum: Ai_element_cacheSumAggregateOutputType | null
    _min: Ai_element_cacheMinAggregateOutputType | null
    _max: Ai_element_cacheMaxAggregateOutputType | null
  }

  export type Ai_element_cacheAvgAggregateOutputType = {
    id: number | null
    confidence: number | null
    hit_count: number | null
  }

  export type Ai_element_cacheSumAggregateOutputType = {
    id: number | null
    confidence: number | null
    hit_count: number | null
  }

  export type Ai_element_cacheMinAggregateOutputType = {
    id: number | null
    cache_key: string | null
    url: string | null
    selector: string | null
    snapshot_fp: string | null
    element_ref: string | null
    element_text: string | null
    confidence: number | null
    hit_count: number | null
    last_hit_at: Date | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Ai_element_cacheMaxAggregateOutputType = {
    id: number | null
    cache_key: string | null
    url: string | null
    selector: string | null
    snapshot_fp: string | null
    element_ref: string | null
    element_text: string | null
    confidence: number | null
    hit_count: number | null
    last_hit_at: Date | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Ai_element_cacheCountAggregateOutputType = {
    id: number
    cache_key: number
    url: number
    selector: number
    snapshot_fp: number
    element_ref: number
    element_text: number
    confidence: number
    hit_count: number
    last_hit_at: number
    created_at: number
    expires_at: number
    _all: number
  }


  export type Ai_element_cacheAvgAggregateInputType = {
    id?: true
    confidence?: true
    hit_count?: true
  }

  export type Ai_element_cacheSumAggregateInputType = {
    id?: true
    confidence?: true
    hit_count?: true
  }

  export type Ai_element_cacheMinAggregateInputType = {
    id?: true
    cache_key?: true
    url?: true
    selector?: true
    snapshot_fp?: true
    element_ref?: true
    element_text?: true
    confidence?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
  }

  export type Ai_element_cacheMaxAggregateInputType = {
    id?: true
    cache_key?: true
    url?: true
    selector?: true
    snapshot_fp?: true
    element_ref?: true
    element_text?: true
    confidence?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
  }

  export type Ai_element_cacheCountAggregateInputType = {
    id?: true
    cache_key?: true
    url?: true
    selector?: true
    snapshot_fp?: true
    element_ref?: true
    element_text?: true
    confidence?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
    _all?: true
  }

  export type Ai_element_cacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_element_cache to aggregate.
     */
    where?: ai_element_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_element_caches to fetch.
     */
    orderBy?: ai_element_cacheOrderByWithRelationInput | ai_element_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_element_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_element_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_element_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_element_caches
    **/
    _count?: true | Ai_element_cacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_element_cacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_element_cacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_element_cacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_element_cacheMaxAggregateInputType
  }

  export type GetAi_element_cacheAggregateType<T extends Ai_element_cacheAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_element_cache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_element_cache[P]>
      : GetScalarType<T[P], AggregateAi_element_cache[P]>
  }




  export type ai_element_cacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_element_cacheWhereInput
    orderBy?: ai_element_cacheOrderByWithAggregationInput | ai_element_cacheOrderByWithAggregationInput[]
    by: Ai_element_cacheScalarFieldEnum[] | Ai_element_cacheScalarFieldEnum
    having?: ai_element_cacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_element_cacheCountAggregateInputType | true
    _avg?: Ai_element_cacheAvgAggregateInputType
    _sum?: Ai_element_cacheSumAggregateInputType
    _min?: Ai_element_cacheMinAggregateInputType
    _max?: Ai_element_cacheMaxAggregateInputType
  }

  export type Ai_element_cacheGroupByOutputType = {
    id: number
    cache_key: string
    url: string
    selector: string
    snapshot_fp: string
    element_ref: string
    element_text: string
    confidence: number
    hit_count: number
    last_hit_at: Date | null
    created_at: Date
    expires_at: Date
    _count: Ai_element_cacheCountAggregateOutputType | null
    _avg: Ai_element_cacheAvgAggregateOutputType | null
    _sum: Ai_element_cacheSumAggregateOutputType | null
    _min: Ai_element_cacheMinAggregateOutputType | null
    _max: Ai_element_cacheMaxAggregateOutputType | null
  }

  type GetAi_element_cacheGroupByPayload<T extends ai_element_cacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_element_cacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_element_cacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_element_cacheGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_element_cacheGroupByOutputType[P]>
        }
      >
    >


  export type ai_element_cacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cache_key?: boolean
    url?: boolean
    selector?: boolean
    snapshot_fp?: boolean
    element_ref?: boolean
    element_text?: boolean
    confidence?: boolean
    hit_count?: boolean
    last_hit_at?: boolean
    created_at?: boolean
    expires_at?: boolean
  }, ExtArgs["result"]["ai_element_cache"]>



  export type ai_element_cacheSelectScalar = {
    id?: boolean
    cache_key?: boolean
    url?: boolean
    selector?: boolean
    snapshot_fp?: boolean
    element_ref?: boolean
    element_text?: boolean
    confidence?: boolean
    hit_count?: boolean
    last_hit_at?: boolean
    created_at?: boolean
    expires_at?: boolean
  }

  export type ai_element_cacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cache_key" | "url" | "selector" | "snapshot_fp" | "element_ref" | "element_text" | "confidence" | "hit_count" | "last_hit_at" | "created_at" | "expires_at", ExtArgs["result"]["ai_element_cache"]>

  export type $ai_element_cachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_element_cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cache_key: string
      url: string
      selector: string
      snapshot_fp: string
      element_ref: string
      element_text: string
      confidence: number
      hit_count: number
      last_hit_at: Date | null
      created_at: Date
      expires_at: Date
    }, ExtArgs["result"]["ai_element_cache"]>
    composites: {}
  }

  type ai_element_cacheGetPayload<S extends boolean | null | undefined | ai_element_cacheDefaultArgs> = $Result.GetResult<Prisma.$ai_element_cachePayload, S>

  type ai_element_cacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_element_cacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_element_cacheCountAggregateInputType | true
    }

  export interface ai_element_cacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_element_cache'], meta: { name: 'ai_element_cache' } }
    /**
     * Find zero or one Ai_element_cache that matches the filter.
     * @param {ai_element_cacheFindUniqueArgs} args - Arguments to find a Ai_element_cache
     * @example
     * // Get one Ai_element_cache
     * const ai_element_cache = await prisma.ai_element_cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_element_cacheFindUniqueArgs>(args: SelectSubset<T, ai_element_cacheFindUniqueArgs<ExtArgs>>): Prisma__ai_element_cacheClient<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_element_cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_element_cacheFindUniqueOrThrowArgs} args - Arguments to find a Ai_element_cache
     * @example
     * // Get one Ai_element_cache
     * const ai_element_cache = await prisma.ai_element_cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_element_cacheFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_element_cacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_element_cacheClient<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_element_cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_element_cacheFindFirstArgs} args - Arguments to find a Ai_element_cache
     * @example
     * // Get one Ai_element_cache
     * const ai_element_cache = await prisma.ai_element_cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_element_cacheFindFirstArgs>(args?: SelectSubset<T, ai_element_cacheFindFirstArgs<ExtArgs>>): Prisma__ai_element_cacheClient<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_element_cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_element_cacheFindFirstOrThrowArgs} args - Arguments to find a Ai_element_cache
     * @example
     * // Get one Ai_element_cache
     * const ai_element_cache = await prisma.ai_element_cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_element_cacheFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_element_cacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_element_cacheClient<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_element_caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_element_cacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_element_caches
     * const ai_element_caches = await prisma.ai_element_cache.findMany()
     * 
     * // Get first 10 Ai_element_caches
     * const ai_element_caches = await prisma.ai_element_cache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_element_cacheWithIdOnly = await prisma.ai_element_cache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_element_cacheFindManyArgs>(args?: SelectSubset<T, ai_element_cacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_element_cache.
     * @param {ai_element_cacheCreateArgs} args - Arguments to create a Ai_element_cache.
     * @example
     * // Create one Ai_element_cache
     * const Ai_element_cache = await prisma.ai_element_cache.create({
     *   data: {
     *     // ... data to create a Ai_element_cache
     *   }
     * })
     * 
     */
    create<T extends ai_element_cacheCreateArgs>(args: SelectSubset<T, ai_element_cacheCreateArgs<ExtArgs>>): Prisma__ai_element_cacheClient<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_element_caches.
     * @param {ai_element_cacheCreateManyArgs} args - Arguments to create many Ai_element_caches.
     * @example
     * // Create many Ai_element_caches
     * const ai_element_cache = await prisma.ai_element_cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_element_cacheCreateManyArgs>(args?: SelectSubset<T, ai_element_cacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ai_element_cache.
     * @param {ai_element_cacheDeleteArgs} args - Arguments to delete one Ai_element_cache.
     * @example
     * // Delete one Ai_element_cache
     * const Ai_element_cache = await prisma.ai_element_cache.delete({
     *   where: {
     *     // ... filter to delete one Ai_element_cache
     *   }
     * })
     * 
     */
    delete<T extends ai_element_cacheDeleteArgs>(args: SelectSubset<T, ai_element_cacheDeleteArgs<ExtArgs>>): Prisma__ai_element_cacheClient<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_element_cache.
     * @param {ai_element_cacheUpdateArgs} args - Arguments to update one Ai_element_cache.
     * @example
     * // Update one Ai_element_cache
     * const ai_element_cache = await prisma.ai_element_cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_element_cacheUpdateArgs>(args: SelectSubset<T, ai_element_cacheUpdateArgs<ExtArgs>>): Prisma__ai_element_cacheClient<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_element_caches.
     * @param {ai_element_cacheDeleteManyArgs} args - Arguments to filter Ai_element_caches to delete.
     * @example
     * // Delete a few Ai_element_caches
     * const { count } = await prisma.ai_element_cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_element_cacheDeleteManyArgs>(args?: SelectSubset<T, ai_element_cacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_element_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_element_cacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_element_caches
     * const ai_element_cache = await prisma.ai_element_cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_element_cacheUpdateManyArgs>(args: SelectSubset<T, ai_element_cacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_element_cache.
     * @param {ai_element_cacheUpsertArgs} args - Arguments to update or create a Ai_element_cache.
     * @example
     * // Update or create a Ai_element_cache
     * const ai_element_cache = await prisma.ai_element_cache.upsert({
     *   create: {
     *     // ... data to create a Ai_element_cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_element_cache we want to update
     *   }
     * })
     */
    upsert<T extends ai_element_cacheUpsertArgs>(args: SelectSubset<T, ai_element_cacheUpsertArgs<ExtArgs>>): Prisma__ai_element_cacheClient<$Result.GetResult<Prisma.$ai_element_cachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_element_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_element_cacheCountArgs} args - Arguments to filter Ai_element_caches to count.
     * @example
     * // Count the number of Ai_element_caches
     * const count = await prisma.ai_element_cache.count({
     *   where: {
     *     // ... the filter for the Ai_element_caches we want to count
     *   }
     * })
    **/
    count<T extends ai_element_cacheCountArgs>(
      args?: Subset<T, ai_element_cacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_element_cacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_element_cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_element_cacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_element_cacheAggregateArgs>(args: Subset<T, Ai_element_cacheAggregateArgs>): Prisma.PrismaPromise<GetAi_element_cacheAggregateType<T>>

    /**
     * Group by Ai_element_cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_element_cacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_element_cacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_element_cacheGroupByArgs['orderBy'] }
        : { orderBy?: ai_element_cacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_element_cacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_element_cacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_element_cache model
   */
  readonly fields: ai_element_cacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_element_cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_element_cacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_element_cache model
   */
  interface ai_element_cacheFieldRefs {
    readonly id: FieldRef<"ai_element_cache", 'Int'>
    readonly cache_key: FieldRef<"ai_element_cache", 'String'>
    readonly url: FieldRef<"ai_element_cache", 'String'>
    readonly selector: FieldRef<"ai_element_cache", 'String'>
    readonly snapshot_fp: FieldRef<"ai_element_cache", 'String'>
    readonly element_ref: FieldRef<"ai_element_cache", 'String'>
    readonly element_text: FieldRef<"ai_element_cache", 'String'>
    readonly confidence: FieldRef<"ai_element_cache", 'Int'>
    readonly hit_count: FieldRef<"ai_element_cache", 'Int'>
    readonly last_hit_at: FieldRef<"ai_element_cache", 'DateTime'>
    readonly created_at: FieldRef<"ai_element_cache", 'DateTime'>
    readonly expires_at: FieldRef<"ai_element_cache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_element_cache findUnique
   */
  export type ai_element_cacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_element_cache to fetch.
     */
    where: ai_element_cacheWhereUniqueInput
  }

  /**
   * ai_element_cache findUniqueOrThrow
   */
  export type ai_element_cacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_element_cache to fetch.
     */
    where: ai_element_cacheWhereUniqueInput
  }

  /**
   * ai_element_cache findFirst
   */
  export type ai_element_cacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_element_cache to fetch.
     */
    where?: ai_element_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_element_caches to fetch.
     */
    orderBy?: ai_element_cacheOrderByWithRelationInput | ai_element_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_element_caches.
     */
    cursor?: ai_element_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_element_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_element_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_element_caches.
     */
    distinct?: Ai_element_cacheScalarFieldEnum | Ai_element_cacheScalarFieldEnum[]
  }

  /**
   * ai_element_cache findFirstOrThrow
   */
  export type ai_element_cacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_element_cache to fetch.
     */
    where?: ai_element_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_element_caches to fetch.
     */
    orderBy?: ai_element_cacheOrderByWithRelationInput | ai_element_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_element_caches.
     */
    cursor?: ai_element_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_element_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_element_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_element_caches.
     */
    distinct?: Ai_element_cacheScalarFieldEnum | Ai_element_cacheScalarFieldEnum[]
  }

  /**
   * ai_element_cache findMany
   */
  export type ai_element_cacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_element_caches to fetch.
     */
    where?: ai_element_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_element_caches to fetch.
     */
    orderBy?: ai_element_cacheOrderByWithRelationInput | ai_element_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_element_caches.
     */
    cursor?: ai_element_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_element_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_element_caches.
     */
    skip?: number
    distinct?: Ai_element_cacheScalarFieldEnum | Ai_element_cacheScalarFieldEnum[]
  }

  /**
   * ai_element_cache create
   */
  export type ai_element_cacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * The data needed to create a ai_element_cache.
     */
    data: XOR<ai_element_cacheCreateInput, ai_element_cacheUncheckedCreateInput>
  }

  /**
   * ai_element_cache createMany
   */
  export type ai_element_cacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_element_caches.
     */
    data: ai_element_cacheCreateManyInput | ai_element_cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_element_cache update
   */
  export type ai_element_cacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * The data needed to update a ai_element_cache.
     */
    data: XOR<ai_element_cacheUpdateInput, ai_element_cacheUncheckedUpdateInput>
    /**
     * Choose, which ai_element_cache to update.
     */
    where: ai_element_cacheWhereUniqueInput
  }

  /**
   * ai_element_cache updateMany
   */
  export type ai_element_cacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_element_caches.
     */
    data: XOR<ai_element_cacheUpdateManyMutationInput, ai_element_cacheUncheckedUpdateManyInput>
    /**
     * Filter which ai_element_caches to update
     */
    where?: ai_element_cacheWhereInput
    /**
     * Limit how many ai_element_caches to update.
     */
    limit?: number
  }

  /**
   * ai_element_cache upsert
   */
  export type ai_element_cacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * The filter to search for the ai_element_cache to update in case it exists.
     */
    where: ai_element_cacheWhereUniqueInput
    /**
     * In case the ai_element_cache found by the `where` argument doesn't exist, create a new ai_element_cache with this data.
     */
    create: XOR<ai_element_cacheCreateInput, ai_element_cacheUncheckedCreateInput>
    /**
     * In case the ai_element_cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_element_cacheUpdateInput, ai_element_cacheUncheckedUpdateInput>
  }

  /**
   * ai_element_cache delete
   */
  export type ai_element_cacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
    /**
     * Filter which ai_element_cache to delete.
     */
    where: ai_element_cacheWhereUniqueInput
  }

  /**
   * ai_element_cache deleteMany
   */
  export type ai_element_cacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_element_caches to delete
     */
    where?: ai_element_cacheWhereInput
    /**
     * Limit how many ai_element_caches to delete.
     */
    limit?: number
  }

  /**
   * ai_element_cache without action
   */
  export type ai_element_cacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_element_cache
     */
    select?: ai_element_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_element_cache
     */
    omit?: ai_element_cacheOmit<ExtArgs> | null
  }


  /**
   * Model ai_assertion_cache
   */

  export type AggregateAi_assertion_cache = {
    _count: Ai_assertion_cacheCountAggregateOutputType | null
    _avg: Ai_assertion_cacheAvgAggregateOutputType | null
    _sum: Ai_assertion_cacheSumAggregateOutputType | null
    _min: Ai_assertion_cacheMinAggregateOutputType | null
    _max: Ai_assertion_cacheMaxAggregateOutputType | null
  }

  export type Ai_assertion_cacheAvgAggregateOutputType = {
    id: number | null
    hit_count: number | null
  }

  export type Ai_assertion_cacheSumAggregateOutputType = {
    id: number | null
    hit_count: number | null
  }

  export type Ai_assertion_cacheMinAggregateOutputType = {
    id: number | null
    cache_key: string | null
    assertion_desc: string | null
    page_elements_fp: string | null
    command_name: string | null
    hit_count: number | null
    last_hit_at: Date | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Ai_assertion_cacheMaxAggregateOutputType = {
    id: number | null
    cache_key: string | null
    assertion_desc: string | null
    page_elements_fp: string | null
    command_name: string | null
    hit_count: number | null
    last_hit_at: Date | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Ai_assertion_cacheCountAggregateOutputType = {
    id: number
    cache_key: number
    assertion_desc: number
    page_elements_fp: number
    command_name: number
    command_args: number
    assertion_info: number
    hit_count: number
    last_hit_at: number
    created_at: number
    expires_at: number
    _all: number
  }


  export type Ai_assertion_cacheAvgAggregateInputType = {
    id?: true
    hit_count?: true
  }

  export type Ai_assertion_cacheSumAggregateInputType = {
    id?: true
    hit_count?: true
  }

  export type Ai_assertion_cacheMinAggregateInputType = {
    id?: true
    cache_key?: true
    assertion_desc?: true
    page_elements_fp?: true
    command_name?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
  }

  export type Ai_assertion_cacheMaxAggregateInputType = {
    id?: true
    cache_key?: true
    assertion_desc?: true
    page_elements_fp?: true
    command_name?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
  }

  export type Ai_assertion_cacheCountAggregateInputType = {
    id?: true
    cache_key?: true
    assertion_desc?: true
    page_elements_fp?: true
    command_name?: true
    command_args?: true
    assertion_info?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
    _all?: true
  }

  export type Ai_assertion_cacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_assertion_cache to aggregate.
     */
    where?: ai_assertion_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_assertion_caches to fetch.
     */
    orderBy?: ai_assertion_cacheOrderByWithRelationInput | ai_assertion_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_assertion_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_assertion_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_assertion_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_assertion_caches
    **/
    _count?: true | Ai_assertion_cacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_assertion_cacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_assertion_cacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_assertion_cacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_assertion_cacheMaxAggregateInputType
  }

  export type GetAi_assertion_cacheAggregateType<T extends Ai_assertion_cacheAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_assertion_cache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_assertion_cache[P]>
      : GetScalarType<T[P], AggregateAi_assertion_cache[P]>
  }




  export type ai_assertion_cacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_assertion_cacheWhereInput
    orderBy?: ai_assertion_cacheOrderByWithAggregationInput | ai_assertion_cacheOrderByWithAggregationInput[]
    by: Ai_assertion_cacheScalarFieldEnum[] | Ai_assertion_cacheScalarFieldEnum
    having?: ai_assertion_cacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_assertion_cacheCountAggregateInputType | true
    _avg?: Ai_assertion_cacheAvgAggregateInputType
    _sum?: Ai_assertion_cacheSumAggregateInputType
    _min?: Ai_assertion_cacheMinAggregateInputType
    _max?: Ai_assertion_cacheMaxAggregateInputType
  }

  export type Ai_assertion_cacheGroupByOutputType = {
    id: number
    cache_key: string
    assertion_desc: string
    page_elements_fp: string
    command_name: string
    command_args: JsonValue | null
    assertion_info: JsonValue | null
    hit_count: number
    last_hit_at: Date | null
    created_at: Date
    expires_at: Date
    _count: Ai_assertion_cacheCountAggregateOutputType | null
    _avg: Ai_assertion_cacheAvgAggregateOutputType | null
    _sum: Ai_assertion_cacheSumAggregateOutputType | null
    _min: Ai_assertion_cacheMinAggregateOutputType | null
    _max: Ai_assertion_cacheMaxAggregateOutputType | null
  }

  type GetAi_assertion_cacheGroupByPayload<T extends ai_assertion_cacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_assertion_cacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_assertion_cacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_assertion_cacheGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_assertion_cacheGroupByOutputType[P]>
        }
      >
    >


  export type ai_assertion_cacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cache_key?: boolean
    assertion_desc?: boolean
    page_elements_fp?: boolean
    command_name?: boolean
    command_args?: boolean
    assertion_info?: boolean
    hit_count?: boolean
    last_hit_at?: boolean
    created_at?: boolean
    expires_at?: boolean
  }, ExtArgs["result"]["ai_assertion_cache"]>



  export type ai_assertion_cacheSelectScalar = {
    id?: boolean
    cache_key?: boolean
    assertion_desc?: boolean
    page_elements_fp?: boolean
    command_name?: boolean
    command_args?: boolean
    assertion_info?: boolean
    hit_count?: boolean
    last_hit_at?: boolean
    created_at?: boolean
    expires_at?: boolean
  }

  export type ai_assertion_cacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cache_key" | "assertion_desc" | "page_elements_fp" | "command_name" | "command_args" | "assertion_info" | "hit_count" | "last_hit_at" | "created_at" | "expires_at", ExtArgs["result"]["ai_assertion_cache"]>

  export type $ai_assertion_cachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_assertion_cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cache_key: string
      assertion_desc: string
      page_elements_fp: string
      command_name: string
      command_args: Prisma.JsonValue | null
      assertion_info: Prisma.JsonValue | null
      hit_count: number
      last_hit_at: Date | null
      created_at: Date
      expires_at: Date
    }, ExtArgs["result"]["ai_assertion_cache"]>
    composites: {}
  }

  type ai_assertion_cacheGetPayload<S extends boolean | null | undefined | ai_assertion_cacheDefaultArgs> = $Result.GetResult<Prisma.$ai_assertion_cachePayload, S>

  type ai_assertion_cacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_assertion_cacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_assertion_cacheCountAggregateInputType | true
    }

  export interface ai_assertion_cacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_assertion_cache'], meta: { name: 'ai_assertion_cache' } }
    /**
     * Find zero or one Ai_assertion_cache that matches the filter.
     * @param {ai_assertion_cacheFindUniqueArgs} args - Arguments to find a Ai_assertion_cache
     * @example
     * // Get one Ai_assertion_cache
     * const ai_assertion_cache = await prisma.ai_assertion_cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_assertion_cacheFindUniqueArgs>(args: SelectSubset<T, ai_assertion_cacheFindUniqueArgs<ExtArgs>>): Prisma__ai_assertion_cacheClient<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_assertion_cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_assertion_cacheFindUniqueOrThrowArgs} args - Arguments to find a Ai_assertion_cache
     * @example
     * // Get one Ai_assertion_cache
     * const ai_assertion_cache = await prisma.ai_assertion_cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_assertion_cacheFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_assertion_cacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_assertion_cacheClient<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_assertion_cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assertion_cacheFindFirstArgs} args - Arguments to find a Ai_assertion_cache
     * @example
     * // Get one Ai_assertion_cache
     * const ai_assertion_cache = await prisma.ai_assertion_cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_assertion_cacheFindFirstArgs>(args?: SelectSubset<T, ai_assertion_cacheFindFirstArgs<ExtArgs>>): Prisma__ai_assertion_cacheClient<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_assertion_cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assertion_cacheFindFirstOrThrowArgs} args - Arguments to find a Ai_assertion_cache
     * @example
     * // Get one Ai_assertion_cache
     * const ai_assertion_cache = await prisma.ai_assertion_cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_assertion_cacheFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_assertion_cacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_assertion_cacheClient<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_assertion_caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assertion_cacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_assertion_caches
     * const ai_assertion_caches = await prisma.ai_assertion_cache.findMany()
     * 
     * // Get first 10 Ai_assertion_caches
     * const ai_assertion_caches = await prisma.ai_assertion_cache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_assertion_cacheWithIdOnly = await prisma.ai_assertion_cache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_assertion_cacheFindManyArgs>(args?: SelectSubset<T, ai_assertion_cacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_assertion_cache.
     * @param {ai_assertion_cacheCreateArgs} args - Arguments to create a Ai_assertion_cache.
     * @example
     * // Create one Ai_assertion_cache
     * const Ai_assertion_cache = await prisma.ai_assertion_cache.create({
     *   data: {
     *     // ... data to create a Ai_assertion_cache
     *   }
     * })
     * 
     */
    create<T extends ai_assertion_cacheCreateArgs>(args: SelectSubset<T, ai_assertion_cacheCreateArgs<ExtArgs>>): Prisma__ai_assertion_cacheClient<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_assertion_caches.
     * @param {ai_assertion_cacheCreateManyArgs} args - Arguments to create many Ai_assertion_caches.
     * @example
     * // Create many Ai_assertion_caches
     * const ai_assertion_cache = await prisma.ai_assertion_cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_assertion_cacheCreateManyArgs>(args?: SelectSubset<T, ai_assertion_cacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ai_assertion_cache.
     * @param {ai_assertion_cacheDeleteArgs} args - Arguments to delete one Ai_assertion_cache.
     * @example
     * // Delete one Ai_assertion_cache
     * const Ai_assertion_cache = await prisma.ai_assertion_cache.delete({
     *   where: {
     *     // ... filter to delete one Ai_assertion_cache
     *   }
     * })
     * 
     */
    delete<T extends ai_assertion_cacheDeleteArgs>(args: SelectSubset<T, ai_assertion_cacheDeleteArgs<ExtArgs>>): Prisma__ai_assertion_cacheClient<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_assertion_cache.
     * @param {ai_assertion_cacheUpdateArgs} args - Arguments to update one Ai_assertion_cache.
     * @example
     * // Update one Ai_assertion_cache
     * const ai_assertion_cache = await prisma.ai_assertion_cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_assertion_cacheUpdateArgs>(args: SelectSubset<T, ai_assertion_cacheUpdateArgs<ExtArgs>>): Prisma__ai_assertion_cacheClient<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_assertion_caches.
     * @param {ai_assertion_cacheDeleteManyArgs} args - Arguments to filter Ai_assertion_caches to delete.
     * @example
     * // Delete a few Ai_assertion_caches
     * const { count } = await prisma.ai_assertion_cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_assertion_cacheDeleteManyArgs>(args?: SelectSubset<T, ai_assertion_cacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_assertion_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assertion_cacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_assertion_caches
     * const ai_assertion_cache = await prisma.ai_assertion_cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_assertion_cacheUpdateManyArgs>(args: SelectSubset<T, ai_assertion_cacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_assertion_cache.
     * @param {ai_assertion_cacheUpsertArgs} args - Arguments to update or create a Ai_assertion_cache.
     * @example
     * // Update or create a Ai_assertion_cache
     * const ai_assertion_cache = await prisma.ai_assertion_cache.upsert({
     *   create: {
     *     // ... data to create a Ai_assertion_cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_assertion_cache we want to update
     *   }
     * })
     */
    upsert<T extends ai_assertion_cacheUpsertArgs>(args: SelectSubset<T, ai_assertion_cacheUpsertArgs<ExtArgs>>): Prisma__ai_assertion_cacheClient<$Result.GetResult<Prisma.$ai_assertion_cachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_assertion_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assertion_cacheCountArgs} args - Arguments to filter Ai_assertion_caches to count.
     * @example
     * // Count the number of Ai_assertion_caches
     * const count = await prisma.ai_assertion_cache.count({
     *   where: {
     *     // ... the filter for the Ai_assertion_caches we want to count
     *   }
     * })
    **/
    count<T extends ai_assertion_cacheCountArgs>(
      args?: Subset<T, ai_assertion_cacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_assertion_cacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_assertion_cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_assertion_cacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_assertion_cacheAggregateArgs>(args: Subset<T, Ai_assertion_cacheAggregateArgs>): Prisma.PrismaPromise<GetAi_assertion_cacheAggregateType<T>>

    /**
     * Group by Ai_assertion_cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assertion_cacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_assertion_cacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_assertion_cacheGroupByArgs['orderBy'] }
        : { orderBy?: ai_assertion_cacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_assertion_cacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_assertion_cacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_assertion_cache model
   */
  readonly fields: ai_assertion_cacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_assertion_cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_assertion_cacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_assertion_cache model
   */
  interface ai_assertion_cacheFieldRefs {
    readonly id: FieldRef<"ai_assertion_cache", 'Int'>
    readonly cache_key: FieldRef<"ai_assertion_cache", 'String'>
    readonly assertion_desc: FieldRef<"ai_assertion_cache", 'String'>
    readonly page_elements_fp: FieldRef<"ai_assertion_cache", 'String'>
    readonly command_name: FieldRef<"ai_assertion_cache", 'String'>
    readonly command_args: FieldRef<"ai_assertion_cache", 'Json'>
    readonly assertion_info: FieldRef<"ai_assertion_cache", 'Json'>
    readonly hit_count: FieldRef<"ai_assertion_cache", 'Int'>
    readonly last_hit_at: FieldRef<"ai_assertion_cache", 'DateTime'>
    readonly created_at: FieldRef<"ai_assertion_cache", 'DateTime'>
    readonly expires_at: FieldRef<"ai_assertion_cache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_assertion_cache findUnique
   */
  export type ai_assertion_cacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_assertion_cache to fetch.
     */
    where: ai_assertion_cacheWhereUniqueInput
  }

  /**
   * ai_assertion_cache findUniqueOrThrow
   */
  export type ai_assertion_cacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_assertion_cache to fetch.
     */
    where: ai_assertion_cacheWhereUniqueInput
  }

  /**
   * ai_assertion_cache findFirst
   */
  export type ai_assertion_cacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_assertion_cache to fetch.
     */
    where?: ai_assertion_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_assertion_caches to fetch.
     */
    orderBy?: ai_assertion_cacheOrderByWithRelationInput | ai_assertion_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_assertion_caches.
     */
    cursor?: ai_assertion_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_assertion_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_assertion_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_assertion_caches.
     */
    distinct?: Ai_assertion_cacheScalarFieldEnum | Ai_assertion_cacheScalarFieldEnum[]
  }

  /**
   * ai_assertion_cache findFirstOrThrow
   */
  export type ai_assertion_cacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_assertion_cache to fetch.
     */
    where?: ai_assertion_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_assertion_caches to fetch.
     */
    orderBy?: ai_assertion_cacheOrderByWithRelationInput | ai_assertion_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_assertion_caches.
     */
    cursor?: ai_assertion_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_assertion_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_assertion_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_assertion_caches.
     */
    distinct?: Ai_assertion_cacheScalarFieldEnum | Ai_assertion_cacheScalarFieldEnum[]
  }

  /**
   * ai_assertion_cache findMany
   */
  export type ai_assertion_cacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_assertion_caches to fetch.
     */
    where?: ai_assertion_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_assertion_caches to fetch.
     */
    orderBy?: ai_assertion_cacheOrderByWithRelationInput | ai_assertion_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_assertion_caches.
     */
    cursor?: ai_assertion_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_assertion_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_assertion_caches.
     */
    skip?: number
    distinct?: Ai_assertion_cacheScalarFieldEnum | Ai_assertion_cacheScalarFieldEnum[]
  }

  /**
   * ai_assertion_cache create
   */
  export type ai_assertion_cacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * The data needed to create a ai_assertion_cache.
     */
    data: XOR<ai_assertion_cacheCreateInput, ai_assertion_cacheUncheckedCreateInput>
  }

  /**
   * ai_assertion_cache createMany
   */
  export type ai_assertion_cacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_assertion_caches.
     */
    data: ai_assertion_cacheCreateManyInput | ai_assertion_cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_assertion_cache update
   */
  export type ai_assertion_cacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * The data needed to update a ai_assertion_cache.
     */
    data: XOR<ai_assertion_cacheUpdateInput, ai_assertion_cacheUncheckedUpdateInput>
    /**
     * Choose, which ai_assertion_cache to update.
     */
    where: ai_assertion_cacheWhereUniqueInput
  }

  /**
   * ai_assertion_cache updateMany
   */
  export type ai_assertion_cacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_assertion_caches.
     */
    data: XOR<ai_assertion_cacheUpdateManyMutationInput, ai_assertion_cacheUncheckedUpdateManyInput>
    /**
     * Filter which ai_assertion_caches to update
     */
    where?: ai_assertion_cacheWhereInput
    /**
     * Limit how many ai_assertion_caches to update.
     */
    limit?: number
  }

  /**
   * ai_assertion_cache upsert
   */
  export type ai_assertion_cacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * The filter to search for the ai_assertion_cache to update in case it exists.
     */
    where: ai_assertion_cacheWhereUniqueInput
    /**
     * In case the ai_assertion_cache found by the `where` argument doesn't exist, create a new ai_assertion_cache with this data.
     */
    create: XOR<ai_assertion_cacheCreateInput, ai_assertion_cacheUncheckedCreateInput>
    /**
     * In case the ai_assertion_cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_assertion_cacheUpdateInput, ai_assertion_cacheUncheckedUpdateInput>
  }

  /**
   * ai_assertion_cache delete
   */
  export type ai_assertion_cacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
    /**
     * Filter which ai_assertion_cache to delete.
     */
    where: ai_assertion_cacheWhereUniqueInput
  }

  /**
   * ai_assertion_cache deleteMany
   */
  export type ai_assertion_cacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_assertion_caches to delete
     */
    where?: ai_assertion_cacheWhereInput
    /**
     * Limit how many ai_assertion_caches to delete.
     */
    limit?: number
  }

  /**
   * ai_assertion_cache without action
   */
  export type ai_assertion_cacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assertion_cache
     */
    select?: ai_assertion_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_assertion_cache
     */
    omit?: ai_assertion_cacheOmit<ExtArgs> | null
  }


  /**
   * Model ai_operation_cache
   */

  export type AggregateAi_operation_cache = {
    _count: Ai_operation_cacheCountAggregateOutputType | null
    _avg: Ai_operation_cacheAvgAggregateOutputType | null
    _sum: Ai_operation_cacheSumAggregateOutputType | null
    _min: Ai_operation_cacheMinAggregateOutputType | null
    _max: Ai_operation_cacheMaxAggregateOutputType | null
  }

  export type Ai_operation_cacheAvgAggregateOutputType = {
    id: number | null
    hit_count: number | null
  }

  export type Ai_operation_cacheSumAggregateOutputType = {
    id: number | null
    hit_count: number | null
  }

  export type Ai_operation_cacheMinAggregateOutputType = {
    id: number | null
    cache_key: string | null
    operation_desc: string | null
    page_elements_fp: string | null
    command_name: string | null
    hit_count: number | null
    last_hit_at: Date | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Ai_operation_cacheMaxAggregateOutputType = {
    id: number | null
    cache_key: string | null
    operation_desc: string | null
    page_elements_fp: string | null
    command_name: string | null
    hit_count: number | null
    last_hit_at: Date | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Ai_operation_cacheCountAggregateOutputType = {
    id: number
    cache_key: number
    operation_desc: number
    page_elements_fp: number
    command_name: number
    command_args: number
    hit_count: number
    last_hit_at: number
    created_at: number
    expires_at: number
    _all: number
  }


  export type Ai_operation_cacheAvgAggregateInputType = {
    id?: true
    hit_count?: true
  }

  export type Ai_operation_cacheSumAggregateInputType = {
    id?: true
    hit_count?: true
  }

  export type Ai_operation_cacheMinAggregateInputType = {
    id?: true
    cache_key?: true
    operation_desc?: true
    page_elements_fp?: true
    command_name?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
  }

  export type Ai_operation_cacheMaxAggregateInputType = {
    id?: true
    cache_key?: true
    operation_desc?: true
    page_elements_fp?: true
    command_name?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
  }

  export type Ai_operation_cacheCountAggregateInputType = {
    id?: true
    cache_key?: true
    operation_desc?: true
    page_elements_fp?: true
    command_name?: true
    command_args?: true
    hit_count?: true
    last_hit_at?: true
    created_at?: true
    expires_at?: true
    _all?: true
  }

  export type Ai_operation_cacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_operation_cache to aggregate.
     */
    where?: ai_operation_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_operation_caches to fetch.
     */
    orderBy?: ai_operation_cacheOrderByWithRelationInput | ai_operation_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_operation_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_operation_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_operation_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_operation_caches
    **/
    _count?: true | Ai_operation_cacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_operation_cacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_operation_cacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_operation_cacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_operation_cacheMaxAggregateInputType
  }

  export type GetAi_operation_cacheAggregateType<T extends Ai_operation_cacheAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_operation_cache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_operation_cache[P]>
      : GetScalarType<T[P], AggregateAi_operation_cache[P]>
  }




  export type ai_operation_cacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_operation_cacheWhereInput
    orderBy?: ai_operation_cacheOrderByWithAggregationInput | ai_operation_cacheOrderByWithAggregationInput[]
    by: Ai_operation_cacheScalarFieldEnum[] | Ai_operation_cacheScalarFieldEnum
    having?: ai_operation_cacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_operation_cacheCountAggregateInputType | true
    _avg?: Ai_operation_cacheAvgAggregateInputType
    _sum?: Ai_operation_cacheSumAggregateInputType
    _min?: Ai_operation_cacheMinAggregateInputType
    _max?: Ai_operation_cacheMaxAggregateInputType
  }

  export type Ai_operation_cacheGroupByOutputType = {
    id: number
    cache_key: string
    operation_desc: string
    page_elements_fp: string
    command_name: string
    command_args: JsonValue | null
    hit_count: number
    last_hit_at: Date | null
    created_at: Date
    expires_at: Date
    _count: Ai_operation_cacheCountAggregateOutputType | null
    _avg: Ai_operation_cacheAvgAggregateOutputType | null
    _sum: Ai_operation_cacheSumAggregateOutputType | null
    _min: Ai_operation_cacheMinAggregateOutputType | null
    _max: Ai_operation_cacheMaxAggregateOutputType | null
  }

  type GetAi_operation_cacheGroupByPayload<T extends ai_operation_cacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_operation_cacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_operation_cacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_operation_cacheGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_operation_cacheGroupByOutputType[P]>
        }
      >
    >


  export type ai_operation_cacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cache_key?: boolean
    operation_desc?: boolean
    page_elements_fp?: boolean
    command_name?: boolean
    command_args?: boolean
    hit_count?: boolean
    last_hit_at?: boolean
    created_at?: boolean
    expires_at?: boolean
  }, ExtArgs["result"]["ai_operation_cache"]>



  export type ai_operation_cacheSelectScalar = {
    id?: boolean
    cache_key?: boolean
    operation_desc?: boolean
    page_elements_fp?: boolean
    command_name?: boolean
    command_args?: boolean
    hit_count?: boolean
    last_hit_at?: boolean
    created_at?: boolean
    expires_at?: boolean
  }

  export type ai_operation_cacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cache_key" | "operation_desc" | "page_elements_fp" | "command_name" | "command_args" | "hit_count" | "last_hit_at" | "created_at" | "expires_at", ExtArgs["result"]["ai_operation_cache"]>

  export type $ai_operation_cachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_operation_cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cache_key: string
      operation_desc: string
      page_elements_fp: string
      command_name: string
      command_args: Prisma.JsonValue | null
      hit_count: number
      last_hit_at: Date | null
      created_at: Date
      expires_at: Date
    }, ExtArgs["result"]["ai_operation_cache"]>
    composites: {}
  }

  type ai_operation_cacheGetPayload<S extends boolean | null | undefined | ai_operation_cacheDefaultArgs> = $Result.GetResult<Prisma.$ai_operation_cachePayload, S>

  type ai_operation_cacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_operation_cacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_operation_cacheCountAggregateInputType | true
    }

  export interface ai_operation_cacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_operation_cache'], meta: { name: 'ai_operation_cache' } }
    /**
     * Find zero or one Ai_operation_cache that matches the filter.
     * @param {ai_operation_cacheFindUniqueArgs} args - Arguments to find a Ai_operation_cache
     * @example
     * // Get one Ai_operation_cache
     * const ai_operation_cache = await prisma.ai_operation_cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_operation_cacheFindUniqueArgs>(args: SelectSubset<T, ai_operation_cacheFindUniqueArgs<ExtArgs>>): Prisma__ai_operation_cacheClient<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_operation_cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_operation_cacheFindUniqueOrThrowArgs} args - Arguments to find a Ai_operation_cache
     * @example
     * // Get one Ai_operation_cache
     * const ai_operation_cache = await prisma.ai_operation_cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_operation_cacheFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_operation_cacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_operation_cacheClient<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_operation_cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_operation_cacheFindFirstArgs} args - Arguments to find a Ai_operation_cache
     * @example
     * // Get one Ai_operation_cache
     * const ai_operation_cache = await prisma.ai_operation_cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_operation_cacheFindFirstArgs>(args?: SelectSubset<T, ai_operation_cacheFindFirstArgs<ExtArgs>>): Prisma__ai_operation_cacheClient<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_operation_cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_operation_cacheFindFirstOrThrowArgs} args - Arguments to find a Ai_operation_cache
     * @example
     * // Get one Ai_operation_cache
     * const ai_operation_cache = await prisma.ai_operation_cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_operation_cacheFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_operation_cacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_operation_cacheClient<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_operation_caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_operation_cacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_operation_caches
     * const ai_operation_caches = await prisma.ai_operation_cache.findMany()
     * 
     * // Get first 10 Ai_operation_caches
     * const ai_operation_caches = await prisma.ai_operation_cache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_operation_cacheWithIdOnly = await prisma.ai_operation_cache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_operation_cacheFindManyArgs>(args?: SelectSubset<T, ai_operation_cacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_operation_cache.
     * @param {ai_operation_cacheCreateArgs} args - Arguments to create a Ai_operation_cache.
     * @example
     * // Create one Ai_operation_cache
     * const Ai_operation_cache = await prisma.ai_operation_cache.create({
     *   data: {
     *     // ... data to create a Ai_operation_cache
     *   }
     * })
     * 
     */
    create<T extends ai_operation_cacheCreateArgs>(args: SelectSubset<T, ai_operation_cacheCreateArgs<ExtArgs>>): Prisma__ai_operation_cacheClient<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_operation_caches.
     * @param {ai_operation_cacheCreateManyArgs} args - Arguments to create many Ai_operation_caches.
     * @example
     * // Create many Ai_operation_caches
     * const ai_operation_cache = await prisma.ai_operation_cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_operation_cacheCreateManyArgs>(args?: SelectSubset<T, ai_operation_cacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ai_operation_cache.
     * @param {ai_operation_cacheDeleteArgs} args - Arguments to delete one Ai_operation_cache.
     * @example
     * // Delete one Ai_operation_cache
     * const Ai_operation_cache = await prisma.ai_operation_cache.delete({
     *   where: {
     *     // ... filter to delete one Ai_operation_cache
     *   }
     * })
     * 
     */
    delete<T extends ai_operation_cacheDeleteArgs>(args: SelectSubset<T, ai_operation_cacheDeleteArgs<ExtArgs>>): Prisma__ai_operation_cacheClient<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_operation_cache.
     * @param {ai_operation_cacheUpdateArgs} args - Arguments to update one Ai_operation_cache.
     * @example
     * // Update one Ai_operation_cache
     * const ai_operation_cache = await prisma.ai_operation_cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_operation_cacheUpdateArgs>(args: SelectSubset<T, ai_operation_cacheUpdateArgs<ExtArgs>>): Prisma__ai_operation_cacheClient<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_operation_caches.
     * @param {ai_operation_cacheDeleteManyArgs} args - Arguments to filter Ai_operation_caches to delete.
     * @example
     * // Delete a few Ai_operation_caches
     * const { count } = await prisma.ai_operation_cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_operation_cacheDeleteManyArgs>(args?: SelectSubset<T, ai_operation_cacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_operation_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_operation_cacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_operation_caches
     * const ai_operation_cache = await prisma.ai_operation_cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_operation_cacheUpdateManyArgs>(args: SelectSubset<T, ai_operation_cacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_operation_cache.
     * @param {ai_operation_cacheUpsertArgs} args - Arguments to update or create a Ai_operation_cache.
     * @example
     * // Update or create a Ai_operation_cache
     * const ai_operation_cache = await prisma.ai_operation_cache.upsert({
     *   create: {
     *     // ... data to create a Ai_operation_cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_operation_cache we want to update
     *   }
     * })
     */
    upsert<T extends ai_operation_cacheUpsertArgs>(args: SelectSubset<T, ai_operation_cacheUpsertArgs<ExtArgs>>): Prisma__ai_operation_cacheClient<$Result.GetResult<Prisma.$ai_operation_cachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_operation_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_operation_cacheCountArgs} args - Arguments to filter Ai_operation_caches to count.
     * @example
     * // Count the number of Ai_operation_caches
     * const count = await prisma.ai_operation_cache.count({
     *   where: {
     *     // ... the filter for the Ai_operation_caches we want to count
     *   }
     * })
    **/
    count<T extends ai_operation_cacheCountArgs>(
      args?: Subset<T, ai_operation_cacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_operation_cacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_operation_cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_operation_cacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_operation_cacheAggregateArgs>(args: Subset<T, Ai_operation_cacheAggregateArgs>): Prisma.PrismaPromise<GetAi_operation_cacheAggregateType<T>>

    /**
     * Group by Ai_operation_cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_operation_cacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_operation_cacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_operation_cacheGroupByArgs['orderBy'] }
        : { orderBy?: ai_operation_cacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_operation_cacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_operation_cacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_operation_cache model
   */
  readonly fields: ai_operation_cacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_operation_cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_operation_cacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_operation_cache model
   */
  interface ai_operation_cacheFieldRefs {
    readonly id: FieldRef<"ai_operation_cache", 'Int'>
    readonly cache_key: FieldRef<"ai_operation_cache", 'String'>
    readonly operation_desc: FieldRef<"ai_operation_cache", 'String'>
    readonly page_elements_fp: FieldRef<"ai_operation_cache", 'String'>
    readonly command_name: FieldRef<"ai_operation_cache", 'String'>
    readonly command_args: FieldRef<"ai_operation_cache", 'Json'>
    readonly hit_count: FieldRef<"ai_operation_cache", 'Int'>
    readonly last_hit_at: FieldRef<"ai_operation_cache", 'DateTime'>
    readonly created_at: FieldRef<"ai_operation_cache", 'DateTime'>
    readonly expires_at: FieldRef<"ai_operation_cache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_operation_cache findUnique
   */
  export type ai_operation_cacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_operation_cache to fetch.
     */
    where: ai_operation_cacheWhereUniqueInput
  }

  /**
   * ai_operation_cache findUniqueOrThrow
   */
  export type ai_operation_cacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_operation_cache to fetch.
     */
    where: ai_operation_cacheWhereUniqueInput
  }

  /**
   * ai_operation_cache findFirst
   */
  export type ai_operation_cacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_operation_cache to fetch.
     */
    where?: ai_operation_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_operation_caches to fetch.
     */
    orderBy?: ai_operation_cacheOrderByWithRelationInput | ai_operation_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_operation_caches.
     */
    cursor?: ai_operation_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_operation_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_operation_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_operation_caches.
     */
    distinct?: Ai_operation_cacheScalarFieldEnum | Ai_operation_cacheScalarFieldEnum[]
  }

  /**
   * ai_operation_cache findFirstOrThrow
   */
  export type ai_operation_cacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_operation_cache to fetch.
     */
    where?: ai_operation_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_operation_caches to fetch.
     */
    orderBy?: ai_operation_cacheOrderByWithRelationInput | ai_operation_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_operation_caches.
     */
    cursor?: ai_operation_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_operation_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_operation_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_operation_caches.
     */
    distinct?: Ai_operation_cacheScalarFieldEnum | Ai_operation_cacheScalarFieldEnum[]
  }

  /**
   * ai_operation_cache findMany
   */
  export type ai_operation_cacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * Filter, which ai_operation_caches to fetch.
     */
    where?: ai_operation_cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_operation_caches to fetch.
     */
    orderBy?: ai_operation_cacheOrderByWithRelationInput | ai_operation_cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_operation_caches.
     */
    cursor?: ai_operation_cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_operation_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_operation_caches.
     */
    skip?: number
    distinct?: Ai_operation_cacheScalarFieldEnum | Ai_operation_cacheScalarFieldEnum[]
  }

  /**
   * ai_operation_cache create
   */
  export type ai_operation_cacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * The data needed to create a ai_operation_cache.
     */
    data: XOR<ai_operation_cacheCreateInput, ai_operation_cacheUncheckedCreateInput>
  }

  /**
   * ai_operation_cache createMany
   */
  export type ai_operation_cacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_operation_caches.
     */
    data: ai_operation_cacheCreateManyInput | ai_operation_cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_operation_cache update
   */
  export type ai_operation_cacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * The data needed to update a ai_operation_cache.
     */
    data: XOR<ai_operation_cacheUpdateInput, ai_operation_cacheUncheckedUpdateInput>
    /**
     * Choose, which ai_operation_cache to update.
     */
    where: ai_operation_cacheWhereUniqueInput
  }

  /**
   * ai_operation_cache updateMany
   */
  export type ai_operation_cacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_operation_caches.
     */
    data: XOR<ai_operation_cacheUpdateManyMutationInput, ai_operation_cacheUncheckedUpdateManyInput>
    /**
     * Filter which ai_operation_caches to update
     */
    where?: ai_operation_cacheWhereInput
    /**
     * Limit how many ai_operation_caches to update.
     */
    limit?: number
  }

  /**
   * ai_operation_cache upsert
   */
  export type ai_operation_cacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * The filter to search for the ai_operation_cache to update in case it exists.
     */
    where: ai_operation_cacheWhereUniqueInput
    /**
     * In case the ai_operation_cache found by the `where` argument doesn't exist, create a new ai_operation_cache with this data.
     */
    create: XOR<ai_operation_cacheCreateInput, ai_operation_cacheUncheckedCreateInput>
    /**
     * In case the ai_operation_cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_operation_cacheUpdateInput, ai_operation_cacheUncheckedUpdateInput>
  }

  /**
   * ai_operation_cache delete
   */
  export type ai_operation_cacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
    /**
     * Filter which ai_operation_cache to delete.
     */
    where: ai_operation_cacheWhereUniqueInput
  }

  /**
   * ai_operation_cache deleteMany
   */
  export type ai_operation_cacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_operation_caches to delete
     */
    where?: ai_operation_cacheWhereInput
    /**
     * Limit how many ai_operation_caches to delete.
     */
    limit?: number
  }

  /**
   * ai_operation_cache without action
   */
  export type ai_operation_cacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_operation_cache
     */
    select?: ai_operation_cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_operation_cache
     */
    omit?: ai_operation_cacheOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Ai_promptsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version: 'version',
    template: 'template',
    created_at: 'created_at'
  };

  export type Ai_promptsScalarFieldEnum = (typeof Ai_promptsScalarFieldEnum)[keyof typeof Ai_promptsScalarFieldEnum]


  export const Ai_runsScalarFieldEnum: {
    id: 'id',
    prompt_id: 'prompt_id',
    run_id: 'run_id',
    token_used: 'token_used',
    cost_usd: 'cost_usd',
    executed_at: 'executed_at'
  };

  export type Ai_runsScalarFieldEnum = (typeof Ai_runsScalarFieldEnum)[keyof typeof Ai_runsScalarFieldEnum]


  export const Api_tokensScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token_hash: 'token_hash',
    scopes: 'scopes',
    expires_at: 'expires_at',
    created_at: 'created_at'
  };

  export type Api_tokensScalarFieldEnum = (typeof Api_tokensScalarFieldEnum)[keyof typeof Api_tokensScalarFieldEnum]


  export const AttachmentsScalarFieldEnum: {
    id: 'id',
    run_result_id: 'run_result_id',
    file_key: 'file_key',
    mime_type: 'mime_type',
    size_bytes: 'size_bytes',
    created_at: 'created_at'
  };

  export type AttachmentsScalarFieldEnum = (typeof AttachmentsScalarFieldEnum)[keyof typeof AttachmentsScalarFieldEnum]


  export const Audit_logsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    action: 'action',
    target_type: 'target_type',
    target_id: 'target_id',
    meta: 'meta',
    created_at: 'created_at'
  };

  export type Audit_logsScalarFieldEnum = (typeof Audit_logsScalarFieldEnum)[keyof typeof Audit_logsScalarFieldEnum]


  export const Feature_flagsScalarFieldEnum: {
    flag_name: 'flag_name',
    is_enabled: 'is_enabled',
    rollout_percentage: 'rollout_percentage',
    updated_at: 'updated_at'
  };

  export type Feature_flagsScalarFieldEnum = (typeof Feature_flagsScalarFieldEnum)[keyof typeof Feature_flagsScalarFieldEnum]


  export const Job_logsScalarFieldEnum: {
    id: 'id',
    job_name: 'job_name',
    status: 'status',
    message: 'message',
    started_at: 'started_at',
    ended_at: 'ended_at'
  };

  export type Job_logsScalarFieldEnum = (typeof Job_logsScalarFieldEnum)[keyof typeof Job_logsScalarFieldEnum]


  export const Metrics_dailyScalarFieldEnum: {
    metric_date: 'metric_date',
    suite_id: 'suite_id',
    pass_rate: 'pass_rate',
    avg_duration_ms: 'avg_duration_ms'
  };

  export type Metrics_dailyScalarFieldEnum = (typeof Metrics_dailyScalarFieldEnum)[keyof typeof Metrics_dailyScalarFieldEnum]


  export const ReportsScalarFieldEnum: {
    id: 'id',
    run_id: 'run_id',
    summary: 'summary',
    generated_at: 'generated_at'
  };

  export type ReportsScalarFieldEnum = (typeof ReportsScalarFieldEnum)[keyof typeof ReportsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    key: 'key',
    value: 'value',
    updated_at: 'updated_at'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const Step_screenshotsScalarFieldEnum: {
    id: 'id',
    run_id: 'run_id',
    test_case_id: 'test_case_id',
    step_index: 'step_index',
    step_description: 'step_description',
    status: 'status',
    file_path: 'file_path',
    file_name: 'file_name',
    file_size: 'file_size',
    mime_type: 'mime_type',
    created_at: 'created_at',
    file_exists: 'file_exists'
  };

  export type Step_screenshotsScalarFieldEnum = (typeof Step_screenshotsScalarFieldEnum)[keyof typeof Step_screenshotsScalarFieldEnum]


  export const Suite_case_mapScalarFieldEnum: {
    suite_id: 'suite_id',
    case_id: 'case_id'
  };

  export type Suite_case_mapScalarFieldEnum = (typeof Suite_case_mapScalarFieldEnum)[keyof typeof Suite_case_mapScalarFieldEnum]


  export const Test_casesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    steps: 'steps',
    tags: 'tags',
    system: 'system',
    module: 'module',
    project: 'project',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Test_casesScalarFieldEnum = (typeof Test_casesScalarFieldEnum)[keyof typeof Test_casesScalarFieldEnum]


  export const Test_run_resultsScalarFieldEnum: {
    id: 'id',
    run_id: 'run_id',
    case_id: 'case_id',
    status: 'status',
    duration_ms: 'duration_ms',
    screenshot_url: 'screenshot_url',
    executed_at: 'executed_at'
  };

  export type Test_run_resultsScalarFieldEnum = (typeof Test_run_resultsScalarFieldEnum)[keyof typeof Test_run_resultsScalarFieldEnum]


  export const Test_runsScalarFieldEnum: {
    id: 'id',
    suite_id: 'suite_id',
    trigger_user_id: 'trigger_user_id',
    status: 'status',
    started_at: 'started_at',
    finished_at: 'finished_at'
  };

  export type Test_runsScalarFieldEnum = (typeof Test_runsScalarFieldEnum)[keyof typeof Test_runsScalarFieldEnum]


  export const Test_suitesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    owner_id: 'owner_id',
    project: 'project',
    metadata: 'metadata',
    created_at: 'created_at'
  };

  export type Test_suitesScalarFieldEnum = (typeof Test_suitesScalarFieldEnum)[keyof typeof Test_suitesScalarFieldEnum]


  export const User_rolesScalarFieldEnum: {
    user_id: 'user_id',
    role_id: 'role_id'
  };

  export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    account_name: 'account_name',
    password_hash: 'password_hash',
    project: 'project',
    is_super_admin: 'is_super_admin',
    created_at: 'created_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Run_artifactsScalarFieldEnum: {
    id: 'id',
    runId: 'runId',
    type: 'type',
    filename: 'filename',
    size: 'size',
    createdAt: 'createdAt'
  };

  export type Run_artifactsScalarFieldEnum = (typeof Run_artifactsScalarFieldEnum)[keyof typeof Run_artifactsScalarFieldEnum]


  export const Case_versionsScalarFieldEnum: {
    id: 'id',
    case_id: 'case_id',
    version: 'version',
    steps: 'steps',
    tags: 'tags',
    system: 'system',
    module: 'module',
    meta: 'meta',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type Case_versionsScalarFieldEnum = (typeof Case_versionsScalarFieldEnum)[keyof typeof Case_versionsScalarFieldEnum]


  export const Bulk_edit_sessionsScalarFieldEnum: {
    id: 'id',
    system: 'system',
    module: 'module',
    tag_filter: 'tag_filter',
    priority_filter: 'priority_filter',
    change_brief: 'change_brief',
    status: 'status',
    created_by: 'created_by',
    created_at: 'created_at',
    applied_at: 'applied_at'
  };

  export type Bulk_edit_sessionsScalarFieldEnum = (typeof Bulk_edit_sessionsScalarFieldEnum)[keyof typeof Bulk_edit_sessionsScalarFieldEnum]


  export const Case_patch_proposalsScalarFieldEnum: {
    id: 'id',
    session_id: 'session_id',
    case_id: 'case_id',
    diff_json: 'diff_json',
    ai_rationale: 'ai_rationale',
    side_effects: 'side_effects',
    risk_level: 'risk_level',
    recall_reason: 'recall_reason',
    old_hash: 'old_hash',
    new_hash: 'new_hash',
    apply_status: 'apply_status',
    created_at: 'created_at',
    applied_at: 'applied_at'
  };

  export type Case_patch_proposalsScalarFieldEnum = (typeof Case_patch_proposalsScalarFieldEnum)[keyof typeof Case_patch_proposalsScalarFieldEnum]


  export const Test_case_executionsScalarFieldEnum: {
    id: 'id',
    test_case_id: 'test_case_id',
    test_case_title: 'test_case_title',
    environment: 'environment',
    execution_mode: 'execution_mode',
    status: 'status',
    executor_user_id: 'executor_user_id',
    executor_project: 'executor_project',
    queued_at: 'queued_at',
    started_at: 'started_at',
    finished_at: 'finished_at',
    duration_ms: 'duration_ms',
    total_steps: 'total_steps',
    completed_steps: 'completed_steps',
    passed_steps: 'passed_steps',
    failed_steps: 'failed_steps',
    progress: 'progress',
    error_message: 'error_message',
    execution_logs: 'execution_logs',
    screenshots: 'screenshots',
    artifacts: 'artifacts',
    metadata: 'metadata'
  };

  export type Test_case_executionsScalarFieldEnum = (typeof Test_case_executionsScalarFieldEnum)[keyof typeof Test_case_executionsScalarFieldEnum]


  export const Functional_test_casesScalarFieldEnum: {
    id: 'id',
    case_id: 'case_id',
    name: 'name',
    description: 'description',
    system: 'system',
    module: 'module',
    priority: 'priority',
    tags: 'tags',
    status: 'status',
    source: 'source',
    ai_session_id: 'ai_session_id',
    creator_id: 'creator_id',
    test_type: 'test_type',
    preconditions: 'preconditions',
    test_data: 'test_data',
    section_id: 'section_id',
    section_name: 'section_name',
    scenario_name: 'scenario_name',
    scenario_description: 'scenario_description',
    batch_number: 'batch_number',
    coverage_areas: 'coverage_areas',
    created_at: 'created_at',
    updated_at: 'updated_at',
    case_type: 'case_type',
    project_version_id: 'project_version_id',
    requirement_source: 'requirement_source',
    section_description: 'section_description',
    expected_result: 'expected_result',
    risk_level: 'risk_level',
    steps: 'steps',
    test_point_name: 'test_point_name',
    test_purpose: 'test_purpose',
    requirement_doc_id: 'requirement_doc_id',
    deleted_at: 'deleted_at'
  };

  export type Functional_test_casesScalarFieldEnum = (typeof Functional_test_casesScalarFieldEnum)[keyof typeof Functional_test_casesScalarFieldEnum]


  export const Ai_generation_sessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    axure_filename: 'axure_filename',
    axure_file_size: 'axure_file_size',
    project_name: 'project_name',
    system_type: 'system_type',
    business_domain: 'business_domain',
    requirement_doc: 'requirement_doc',
    page_count: 'page_count',
    element_count: 'element_count',
    interaction_count: 'interaction_count',
    total_generated: 'total_generated',
    total_saved: 'total_saved',
    batches: 'batches',
    pre_analysis_result: 'pre_analysis_result',
    enhanced_data: 'enhanced_data',
    created_at: 'created_at'
  };

  export type Ai_generation_sessionsScalarFieldEnum = (typeof Ai_generation_sessionsScalarFieldEnum)[keyof typeof Ai_generation_sessionsScalarFieldEnum]


  export const Requirement_documentsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    summary: 'summary',
    source_filename: 'source_filename',
    ai_session_id: 'ai_session_id',
    project_id: 'project_id',
    project_version_id: 'project_version_id',
    creator_id: 'creator_id',
    scenario_count: 'scenario_count',
    test_case_count: 'test_case_count',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    module: 'module',
    system: 'system'
  };

  export type Requirement_documentsScalarFieldEnum = (typeof Requirement_documentsScalarFieldEnum)[keyof typeof Requirement_documentsScalarFieldEnum]


  export const SystemsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    short_name: 'short_name',
    description: 'description',
    status: 'status',
    sort_order: 'sort_order',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SystemsScalarFieldEnum = (typeof SystemsScalarFieldEnum)[keyof typeof SystemsScalarFieldEnum]


  export const Project_versionsScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    version_name: 'version_name',
    version_code: 'version_code',
    description: 'description',
    is_main: 'is_main',
    status: 'status',
    release_date: 'release_date',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Project_versionsScalarFieldEnum = (typeof Project_versionsScalarFieldEnum)[keyof typeof Project_versionsScalarFieldEnum]


  export const Functional_test_executionsScalarFieldEnum: {
    id: 'id',
    test_case_id: 'test_case_id',
    test_case_name: 'test_case_name',
    final_result: 'final_result',
    actual_result: 'actual_result',
    comments: 'comments',
    duration_ms: 'duration_ms',
    executed_at: 'executed_at',
    executor_id: 'executor_id',
    executor_project: 'executor_project',
    step_results: 'step_results',
    total_steps: 'total_steps',
    completed_steps: 'completed_steps',
    passed_steps: 'passed_steps',
    failed_steps: 'failed_steps',
    blocked_steps: 'blocked_steps',
    screenshots: 'screenshots',
    attachments: 'attachments',
    metadata: 'metadata'
  };

  export type Functional_test_executionsScalarFieldEnum = (typeof Functional_test_executionsScalarFieldEnum)[keyof typeof Functional_test_executionsScalarFieldEnum]


  export const Test_plansScalarFieldEnum: {
    id: 'id',
    name: 'name',
    short_name: 'short_name',
    description: 'description',
    project: 'project',
    plan_type: 'plan_type',
    status: 'status',
    members: 'members',
    owner_id: 'owner_id',
    start_date: 'start_date',
    end_date: 'end_date',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Test_plansScalarFieldEnum = (typeof Test_plansScalarFieldEnum)[keyof typeof Test_plansScalarFieldEnum]


  export const Test_plan_casesScalarFieldEnum: {
    id: 'id',
    plan_id: 'plan_id',
    case_id: 'case_id',
    case_type: 'case_type',
    case_name: 'case_name',
    sort_order: 'sort_order',
    is_executed: 'is_executed',
    execution_result: 'execution_result',
    created_at: 'created_at'
  };

  export type Test_plan_casesScalarFieldEnum = (typeof Test_plan_casesScalarFieldEnum)[keyof typeof Test_plan_casesScalarFieldEnum]


  export const Test_plan_executionsScalarFieldEnum: {
    id: 'id',
    plan_id: 'plan_id',
    plan_name: 'plan_name',
    executor_id: 'executor_id',
    executor_name: 'executor_name',
    execution_type: 'execution_type',
    status: 'status',
    progress: 'progress',
    total_cases: 'total_cases',
    completed_cases: 'completed_cases',
    passed_cases: 'passed_cases',
    failed_cases: 'failed_cases',
    blocked_cases: 'blocked_cases',
    skipped_cases: 'skipped_cases',
    started_at: 'started_at',
    finished_at: 'finished_at',
    duration_ms: 'duration_ms',
    execution_results: 'execution_results',
    error_message: 'error_message',
    metadata: 'metadata'
  };

  export type Test_plan_executionsScalarFieldEnum = (typeof Test_plan_executionsScalarFieldEnum)[keyof typeof Test_plan_executionsScalarFieldEnum]


  export const Ai_element_cacheScalarFieldEnum: {
    id: 'id',
    cache_key: 'cache_key',
    url: 'url',
    selector: 'selector',
    snapshot_fp: 'snapshot_fp',
    element_ref: 'element_ref',
    element_text: 'element_text',
    confidence: 'confidence',
    hit_count: 'hit_count',
    last_hit_at: 'last_hit_at',
    created_at: 'created_at',
    expires_at: 'expires_at'
  };

  export type Ai_element_cacheScalarFieldEnum = (typeof Ai_element_cacheScalarFieldEnum)[keyof typeof Ai_element_cacheScalarFieldEnum]


  export const Ai_assertion_cacheScalarFieldEnum: {
    id: 'id',
    cache_key: 'cache_key',
    assertion_desc: 'assertion_desc',
    page_elements_fp: 'page_elements_fp',
    command_name: 'command_name',
    command_args: 'command_args',
    assertion_info: 'assertion_info',
    hit_count: 'hit_count',
    last_hit_at: 'last_hit_at',
    created_at: 'created_at',
    expires_at: 'expires_at'
  };

  export type Ai_assertion_cacheScalarFieldEnum = (typeof Ai_assertion_cacheScalarFieldEnum)[keyof typeof Ai_assertion_cacheScalarFieldEnum]


  export const Ai_operation_cacheScalarFieldEnum: {
    id: 'id',
    cache_key: 'cache_key',
    operation_desc: 'operation_desc',
    page_elements_fp: 'page_elements_fp',
    command_name: 'command_name',
    command_args: 'command_args',
    hit_count: 'hit_count',
    last_hit_at: 'last_hit_at',
    created_at: 'created_at',
    expires_at: 'expires_at'
  };

  export type Ai_operation_cacheScalarFieldEnum = (typeof Ai_operation_cacheScalarFieldEnum)[keyof typeof Ai_operation_cacheScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const ai_promptsOrderByRelevanceFieldEnum: {
    name: 'name',
    template: 'template'
  };

  export type ai_promptsOrderByRelevanceFieldEnum = (typeof ai_promptsOrderByRelevanceFieldEnum)[keyof typeof ai_promptsOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const api_tokensOrderByRelevanceFieldEnum: {
    token_hash: 'token_hash'
  };

  export type api_tokensOrderByRelevanceFieldEnum = (typeof api_tokensOrderByRelevanceFieldEnum)[keyof typeof api_tokensOrderByRelevanceFieldEnum]


  export const attachmentsOrderByRelevanceFieldEnum: {
    file_key: 'file_key',
    mime_type: 'mime_type'
  };

  export type attachmentsOrderByRelevanceFieldEnum = (typeof attachmentsOrderByRelevanceFieldEnum)[keyof typeof attachmentsOrderByRelevanceFieldEnum]


  export const audit_logsOrderByRelevanceFieldEnum: {
    action: 'action',
    target_type: 'target_type'
  };

  export type audit_logsOrderByRelevanceFieldEnum = (typeof audit_logsOrderByRelevanceFieldEnum)[keyof typeof audit_logsOrderByRelevanceFieldEnum]


  export const feature_flagsOrderByRelevanceFieldEnum: {
    flag_name: 'flag_name'
  };

  export type feature_flagsOrderByRelevanceFieldEnum = (typeof feature_flagsOrderByRelevanceFieldEnum)[keyof typeof feature_flagsOrderByRelevanceFieldEnum]


  export const job_logsOrderByRelevanceFieldEnum: {
    job_name: 'job_name',
    message: 'message'
  };

  export type job_logsOrderByRelevanceFieldEnum = (typeof job_logsOrderByRelevanceFieldEnum)[keyof typeof job_logsOrderByRelevanceFieldEnum]


  export const rolesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type rolesOrderByRelevanceFieldEnum = (typeof rolesOrderByRelevanceFieldEnum)[keyof typeof rolesOrderByRelevanceFieldEnum]


  export const settingsOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type settingsOrderByRelevanceFieldEnum = (typeof settingsOrderByRelevanceFieldEnum)[keyof typeof settingsOrderByRelevanceFieldEnum]


  export const step_screenshotsOrderByRelevanceFieldEnum: {
    run_id: 'run_id',
    step_index: 'step_index',
    step_description: 'step_description',
    file_path: 'file_path',
    file_name: 'file_name',
    mime_type: 'mime_type'
  };

  export type step_screenshotsOrderByRelevanceFieldEnum = (typeof step_screenshotsOrderByRelevanceFieldEnum)[keyof typeof step_screenshotsOrderByRelevanceFieldEnum]


  export const test_casesOrderByRelevanceFieldEnum: {
    title: 'title',
    system: 'system',
    module: 'module',
    project: 'project'
  };

  export type test_casesOrderByRelevanceFieldEnum = (typeof test_casesOrderByRelevanceFieldEnum)[keyof typeof test_casesOrderByRelevanceFieldEnum]


  export const test_run_resultsOrderByRelevanceFieldEnum: {
    screenshot_url: 'screenshot_url'
  };

  export type test_run_resultsOrderByRelevanceFieldEnum = (typeof test_run_resultsOrderByRelevanceFieldEnum)[keyof typeof test_run_resultsOrderByRelevanceFieldEnum]


  export const test_suitesOrderByRelevanceFieldEnum: {
    name: 'name',
    project: 'project'
  };

  export type test_suitesOrderByRelevanceFieldEnum = (typeof test_suitesOrderByRelevanceFieldEnum)[keyof typeof test_suitesOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    email: 'email',
    username: 'username',
    account_name: 'account_name',
    password_hash: 'password_hash',
    project: 'project'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  export const run_artifactsOrderByRelevanceFieldEnum: {
    runId: 'runId',
    type: 'type',
    filename: 'filename'
  };

  export type run_artifactsOrderByRelevanceFieldEnum = (typeof run_artifactsOrderByRelevanceFieldEnum)[keyof typeof run_artifactsOrderByRelevanceFieldEnum]


  export const case_versionsOrderByRelevanceFieldEnum: {
    system: 'system',
    module: 'module'
  };

  export type case_versionsOrderByRelevanceFieldEnum = (typeof case_versionsOrderByRelevanceFieldEnum)[keyof typeof case_versionsOrderByRelevanceFieldEnum]


  export const bulk_edit_sessionsOrderByRelevanceFieldEnum: {
    system: 'system',
    module: 'module',
    priority_filter: 'priority_filter',
    change_brief: 'change_brief'
  };

  export type bulk_edit_sessionsOrderByRelevanceFieldEnum = (typeof bulk_edit_sessionsOrderByRelevanceFieldEnum)[keyof typeof bulk_edit_sessionsOrderByRelevanceFieldEnum]


  export const case_patch_proposalsOrderByRelevanceFieldEnum: {
    ai_rationale: 'ai_rationale',
    recall_reason: 'recall_reason',
    old_hash: 'old_hash',
    new_hash: 'new_hash'
  };

  export type case_patch_proposalsOrderByRelevanceFieldEnum = (typeof case_patch_proposalsOrderByRelevanceFieldEnum)[keyof typeof case_patch_proposalsOrderByRelevanceFieldEnum]


  export const test_case_executionsOrderByRelevanceFieldEnum: {
    id: 'id',
    test_case_title: 'test_case_title',
    environment: 'environment',
    execution_mode: 'execution_mode',
    executor_project: 'executor_project',
    error_message: 'error_message'
  };

  export type test_case_executionsOrderByRelevanceFieldEnum = (typeof test_case_executionsOrderByRelevanceFieldEnum)[keyof typeof test_case_executionsOrderByRelevanceFieldEnum]


  export const functional_test_casesOrderByRelevanceFieldEnum: {
    case_id: 'case_id',
    name: 'name',
    description: 'description',
    system: 'system',
    module: 'module',
    tags: 'tags',
    ai_session_id: 'ai_session_id',
    test_type: 'test_type',
    preconditions: 'preconditions',
    test_data: 'test_data',
    section_id: 'section_id',
    section_name: 'section_name',
    scenario_name: 'scenario_name',
    scenario_description: 'scenario_description',
    coverage_areas: 'coverage_areas',
    requirement_source: 'requirement_source',
    section_description: 'section_description',
    expected_result: 'expected_result',
    steps: 'steps',
    test_point_name: 'test_point_name',
    test_purpose: 'test_purpose'
  };

  export type functional_test_casesOrderByRelevanceFieldEnum = (typeof functional_test_casesOrderByRelevanceFieldEnum)[keyof typeof functional_test_casesOrderByRelevanceFieldEnum]


  export const ai_generation_sessionsOrderByRelevanceFieldEnum: {
    id: 'id',
    axure_filename: 'axure_filename',
    project_name: 'project_name',
    system_type: 'system_type',
    business_domain: 'business_domain',
    requirement_doc: 'requirement_doc'
  };

  export type ai_generation_sessionsOrderByRelevanceFieldEnum = (typeof ai_generation_sessionsOrderByRelevanceFieldEnum)[keyof typeof ai_generation_sessionsOrderByRelevanceFieldEnum]


  export const requirement_documentsOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content',
    summary: 'summary',
    source_filename: 'source_filename',
    ai_session_id: 'ai_session_id',
    module: 'module',
    system: 'system'
  };

  export type requirement_documentsOrderByRelevanceFieldEnum = (typeof requirement_documentsOrderByRelevanceFieldEnum)[keyof typeof requirement_documentsOrderByRelevanceFieldEnum]


  export const systemsOrderByRelevanceFieldEnum: {
    name: 'name',
    short_name: 'short_name',
    description: 'description'
  };

  export type systemsOrderByRelevanceFieldEnum = (typeof systemsOrderByRelevanceFieldEnum)[keyof typeof systemsOrderByRelevanceFieldEnum]


  export const project_versionsOrderByRelevanceFieldEnum: {
    version_name: 'version_name',
    version_code: 'version_code',
    description: 'description'
  };

  export type project_versionsOrderByRelevanceFieldEnum = (typeof project_versionsOrderByRelevanceFieldEnum)[keyof typeof project_versionsOrderByRelevanceFieldEnum]


  export const functional_test_executionsOrderByRelevanceFieldEnum: {
    id: 'id',
    test_case_name: 'test_case_name',
    actual_result: 'actual_result',
    comments: 'comments',
    executor_project: 'executor_project'
  };

  export type functional_test_executionsOrderByRelevanceFieldEnum = (typeof functional_test_executionsOrderByRelevanceFieldEnum)[keyof typeof functional_test_executionsOrderByRelevanceFieldEnum]


  export const test_plansOrderByRelevanceFieldEnum: {
    name: 'name',
    short_name: 'short_name',
    description: 'description',
    project: 'project'
  };

  export type test_plansOrderByRelevanceFieldEnum = (typeof test_plansOrderByRelevanceFieldEnum)[keyof typeof test_plansOrderByRelevanceFieldEnum]


  export const test_plan_casesOrderByRelevanceFieldEnum: {
    case_type: 'case_type',
    case_name: 'case_name',
    execution_result: 'execution_result'
  };

  export type test_plan_casesOrderByRelevanceFieldEnum = (typeof test_plan_casesOrderByRelevanceFieldEnum)[keyof typeof test_plan_casesOrderByRelevanceFieldEnum]


  export const test_plan_executionsOrderByRelevanceFieldEnum: {
    id: 'id',
    plan_name: 'plan_name',
    executor_name: 'executor_name',
    execution_type: 'execution_type',
    status: 'status',
    error_message: 'error_message'
  };

  export type test_plan_executionsOrderByRelevanceFieldEnum = (typeof test_plan_executionsOrderByRelevanceFieldEnum)[keyof typeof test_plan_executionsOrderByRelevanceFieldEnum]


  export const ai_element_cacheOrderByRelevanceFieldEnum: {
    cache_key: 'cache_key',
    url: 'url',
    selector: 'selector',
    snapshot_fp: 'snapshot_fp',
    element_ref: 'element_ref',
    element_text: 'element_text'
  };

  export type ai_element_cacheOrderByRelevanceFieldEnum = (typeof ai_element_cacheOrderByRelevanceFieldEnum)[keyof typeof ai_element_cacheOrderByRelevanceFieldEnum]


  export const ai_assertion_cacheOrderByRelevanceFieldEnum: {
    cache_key: 'cache_key',
    assertion_desc: 'assertion_desc',
    page_elements_fp: 'page_elements_fp',
    command_name: 'command_name'
  };

  export type ai_assertion_cacheOrderByRelevanceFieldEnum = (typeof ai_assertion_cacheOrderByRelevanceFieldEnum)[keyof typeof ai_assertion_cacheOrderByRelevanceFieldEnum]


  export const ai_operation_cacheOrderByRelevanceFieldEnum: {
    cache_key: 'cache_key',
    operation_desc: 'operation_desc',
    page_elements_fp: 'page_elements_fp',
    command_name: 'command_name'
  };

  export type ai_operation_cacheOrderByRelevanceFieldEnum = (typeof ai_operation_cacheOrderByRelevanceFieldEnum)[keyof typeof ai_operation_cacheOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'job_logs_status'
   */
  export type Enumjob_logs_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'job_logs_status'>
    


  /**
   * Reference to a field of type 'step_screenshots_status'
   */
  export type Enumstep_screenshots_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'step_screenshots_status'>
    


  /**
   * Reference to a field of type 'test_run_results_status'
   */
  export type Enumtest_run_results_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_run_results_status'>
    


  /**
   * Reference to a field of type 'test_runs_status'
   */
  export type Enumtest_runs_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_runs_status'>
    


  /**
   * Reference to a field of type 'bulk_edit_sessions_status'
   */
  export type Enumbulk_edit_sessions_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'bulk_edit_sessions_status'>
    


  /**
   * Reference to a field of type 'proposal_risk_level'
   */
  export type Enumproposal_risk_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'proposal_risk_level'>
    


  /**
   * Reference to a field of type 'proposal_apply_status'
   */
  export type Enumproposal_apply_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'proposal_apply_status'>
    


  /**
   * Reference to a field of type 'test_case_execution_status'
   */
  export type Enumtest_case_execution_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_case_execution_status'>
    


  /**
   * Reference to a field of type 'functional_test_priority'
   */
  export type Enumfunctional_test_priorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'functional_test_priority'>
    


  /**
   * Reference to a field of type 'functional_test_status'
   */
  export type Enumfunctional_test_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'functional_test_status'>
    


  /**
   * Reference to a field of type 'functional_test_source'
   */
  export type Enumfunctional_test_sourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'functional_test_source'>
    


  /**
   * Reference to a field of type 'functional_case_type'
   */
  export type Enumfunctional_case_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'functional_case_type'>
    


  /**
   * Reference to a field of type 'functional_risk_level'
   */
  export type Enumfunctional_risk_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'functional_risk_level'>
    


  /**
   * Reference to a field of type 'requirement_doc_status'
   */
  export type Enumrequirement_doc_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'requirement_doc_status'>
    


  /**
   * Reference to a field of type 'system_status'
   */
  export type Enumsystem_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'system_status'>
    


  /**
   * Reference to a field of type 'functional_execution_result'
   */
  export type Enumfunctional_execution_resultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'functional_execution_result'>
    


  /**
   * Reference to a field of type 'test_plan_type'
   */
  export type Enumtest_plan_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_plan_type'>
    


  /**
   * Reference to a field of type 'test_plan_status'
   */
  export type Enumtest_plan_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_plan_status'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ai_promptsWhereInput = {
    AND?: ai_promptsWhereInput | ai_promptsWhereInput[]
    OR?: ai_promptsWhereInput[]
    NOT?: ai_promptsWhereInput | ai_promptsWhereInput[]
    id?: IntFilter<"ai_prompts"> | number
    name?: StringFilter<"ai_prompts"> | string
    version?: IntFilter<"ai_prompts"> | number
    template?: StringFilter<"ai_prompts"> | string
    created_at?: DateTimeNullableFilter<"ai_prompts"> | Date | string | null
    ai_runs?: Ai_runsListRelationFilter
  }

  export type ai_promptsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    template?: SortOrder
    created_at?: SortOrderInput | SortOrder
    ai_runs?: ai_runsOrderByRelationAggregateInput
    _relevance?: ai_promptsOrderByRelevanceInput
  }

  export type ai_promptsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_version?: ai_promptsNameVersionCompoundUniqueInput
    AND?: ai_promptsWhereInput | ai_promptsWhereInput[]
    OR?: ai_promptsWhereInput[]
    NOT?: ai_promptsWhereInput | ai_promptsWhereInput[]
    name?: StringFilter<"ai_prompts"> | string
    version?: IntFilter<"ai_prompts"> | number
    template?: StringFilter<"ai_prompts"> | string
    created_at?: DateTimeNullableFilter<"ai_prompts"> | Date | string | null
    ai_runs?: Ai_runsListRelationFilter
  }, "id" | "name_version">

  export type ai_promptsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    template?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ai_promptsCountOrderByAggregateInput
    _avg?: ai_promptsAvgOrderByAggregateInput
    _max?: ai_promptsMaxOrderByAggregateInput
    _min?: ai_promptsMinOrderByAggregateInput
    _sum?: ai_promptsSumOrderByAggregateInput
  }

  export type ai_promptsScalarWhereWithAggregatesInput = {
    AND?: ai_promptsScalarWhereWithAggregatesInput | ai_promptsScalarWhereWithAggregatesInput[]
    OR?: ai_promptsScalarWhereWithAggregatesInput[]
    NOT?: ai_promptsScalarWhereWithAggregatesInput | ai_promptsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_prompts"> | number
    name?: StringWithAggregatesFilter<"ai_prompts"> | string
    version?: IntWithAggregatesFilter<"ai_prompts"> | number
    template?: StringWithAggregatesFilter<"ai_prompts"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"ai_prompts"> | Date | string | null
  }

  export type ai_runsWhereInput = {
    AND?: ai_runsWhereInput | ai_runsWhereInput[]
    OR?: ai_runsWhereInput[]
    NOT?: ai_runsWhereInput | ai_runsWhereInput[]
    id?: IntFilter<"ai_runs"> | number
    prompt_id?: IntFilter<"ai_runs"> | number
    run_id?: IntNullableFilter<"ai_runs"> | number | null
    token_used?: IntNullableFilter<"ai_runs"> | number | null
    cost_usd?: DecimalNullableFilter<"ai_runs"> | Decimal | DecimalJsLike | number | string | null
    executed_at?: DateTimeNullableFilter<"ai_runs"> | Date | string | null
    ai_prompts?: XOR<Ai_promptsScalarRelationFilter, ai_promptsWhereInput>
    test_runs?: XOR<Test_runsNullableScalarRelationFilter, test_runsWhereInput> | null
  }

  export type ai_runsOrderByWithRelationInput = {
    id?: SortOrder
    prompt_id?: SortOrder
    run_id?: SortOrderInput | SortOrder
    token_used?: SortOrderInput | SortOrder
    cost_usd?: SortOrderInput | SortOrder
    executed_at?: SortOrderInput | SortOrder
    ai_prompts?: ai_promptsOrderByWithRelationInput
    test_runs?: test_runsOrderByWithRelationInput
  }

  export type ai_runsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ai_runsWhereInput | ai_runsWhereInput[]
    OR?: ai_runsWhereInput[]
    NOT?: ai_runsWhereInput | ai_runsWhereInput[]
    prompt_id?: IntFilter<"ai_runs"> | number
    run_id?: IntNullableFilter<"ai_runs"> | number | null
    token_used?: IntNullableFilter<"ai_runs"> | number | null
    cost_usd?: DecimalNullableFilter<"ai_runs"> | Decimal | DecimalJsLike | number | string | null
    executed_at?: DateTimeNullableFilter<"ai_runs"> | Date | string | null
    ai_prompts?: XOR<Ai_promptsScalarRelationFilter, ai_promptsWhereInput>
    test_runs?: XOR<Test_runsNullableScalarRelationFilter, test_runsWhereInput> | null
  }, "id">

  export type ai_runsOrderByWithAggregationInput = {
    id?: SortOrder
    prompt_id?: SortOrder
    run_id?: SortOrderInput | SortOrder
    token_used?: SortOrderInput | SortOrder
    cost_usd?: SortOrderInput | SortOrder
    executed_at?: SortOrderInput | SortOrder
    _count?: ai_runsCountOrderByAggregateInput
    _avg?: ai_runsAvgOrderByAggregateInput
    _max?: ai_runsMaxOrderByAggregateInput
    _min?: ai_runsMinOrderByAggregateInput
    _sum?: ai_runsSumOrderByAggregateInput
  }

  export type ai_runsScalarWhereWithAggregatesInput = {
    AND?: ai_runsScalarWhereWithAggregatesInput | ai_runsScalarWhereWithAggregatesInput[]
    OR?: ai_runsScalarWhereWithAggregatesInput[]
    NOT?: ai_runsScalarWhereWithAggregatesInput | ai_runsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_runs"> | number
    prompt_id?: IntWithAggregatesFilter<"ai_runs"> | number
    run_id?: IntNullableWithAggregatesFilter<"ai_runs"> | number | null
    token_used?: IntNullableWithAggregatesFilter<"ai_runs"> | number | null
    cost_usd?: DecimalNullableWithAggregatesFilter<"ai_runs"> | Decimal | DecimalJsLike | number | string | null
    executed_at?: DateTimeNullableWithAggregatesFilter<"ai_runs"> | Date | string | null
  }

  export type api_tokensWhereInput = {
    AND?: api_tokensWhereInput | api_tokensWhereInput[]
    OR?: api_tokensWhereInput[]
    NOT?: api_tokensWhereInput | api_tokensWhereInput[]
    id?: IntFilter<"api_tokens"> | number
    user_id?: IntFilter<"api_tokens"> | number
    token_hash?: StringFilter<"api_tokens"> | string
    scopes?: JsonNullableFilter<"api_tokens">
    expires_at?: DateTimeNullableFilter<"api_tokens"> | Date | string | null
    created_at?: DateTimeNullableFilter<"api_tokens"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type api_tokensOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    scopes?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    _relevance?: api_tokensOrderByRelevanceInput
  }

  export type api_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: api_tokensWhereInput | api_tokensWhereInput[]
    OR?: api_tokensWhereInput[]
    NOT?: api_tokensWhereInput | api_tokensWhereInput[]
    user_id?: IntFilter<"api_tokens"> | number
    token_hash?: StringFilter<"api_tokens"> | string
    scopes?: JsonNullableFilter<"api_tokens">
    expires_at?: DateTimeNullableFilter<"api_tokens"> | Date | string | null
    created_at?: DateTimeNullableFilter<"api_tokens"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type api_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    scopes?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: api_tokensCountOrderByAggregateInput
    _avg?: api_tokensAvgOrderByAggregateInput
    _max?: api_tokensMaxOrderByAggregateInput
    _min?: api_tokensMinOrderByAggregateInput
    _sum?: api_tokensSumOrderByAggregateInput
  }

  export type api_tokensScalarWhereWithAggregatesInput = {
    AND?: api_tokensScalarWhereWithAggregatesInput | api_tokensScalarWhereWithAggregatesInput[]
    OR?: api_tokensScalarWhereWithAggregatesInput[]
    NOT?: api_tokensScalarWhereWithAggregatesInput | api_tokensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"api_tokens"> | number
    user_id?: IntWithAggregatesFilter<"api_tokens"> | number
    token_hash?: StringWithAggregatesFilter<"api_tokens"> | string
    scopes?: JsonNullableWithAggregatesFilter<"api_tokens">
    expires_at?: DateTimeNullableWithAggregatesFilter<"api_tokens"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"api_tokens"> | Date | string | null
  }

  export type attachmentsWhereInput = {
    AND?: attachmentsWhereInput | attachmentsWhereInput[]
    OR?: attachmentsWhereInput[]
    NOT?: attachmentsWhereInput | attachmentsWhereInput[]
    id?: IntFilter<"attachments"> | number
    run_result_id?: IntFilter<"attachments"> | number
    file_key?: StringFilter<"attachments"> | string
    mime_type?: StringNullableFilter<"attachments"> | string | null
    size_bytes?: BigIntNullableFilter<"attachments"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"attachments"> | Date | string | null
    test_run_results?: XOR<Test_run_resultsScalarRelationFilter, test_run_resultsWhereInput>
  }

  export type attachmentsOrderByWithRelationInput = {
    id?: SortOrder
    run_result_id?: SortOrder
    file_key?: SortOrder
    mime_type?: SortOrderInput | SortOrder
    size_bytes?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    test_run_results?: test_run_resultsOrderByWithRelationInput
    _relevance?: attachmentsOrderByRelevanceInput
  }

  export type attachmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: attachmentsWhereInput | attachmentsWhereInput[]
    OR?: attachmentsWhereInput[]
    NOT?: attachmentsWhereInput | attachmentsWhereInput[]
    run_result_id?: IntFilter<"attachments"> | number
    file_key?: StringFilter<"attachments"> | string
    mime_type?: StringNullableFilter<"attachments"> | string | null
    size_bytes?: BigIntNullableFilter<"attachments"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"attachments"> | Date | string | null
    test_run_results?: XOR<Test_run_resultsScalarRelationFilter, test_run_resultsWhereInput>
  }, "id">

  export type attachmentsOrderByWithAggregationInput = {
    id?: SortOrder
    run_result_id?: SortOrder
    file_key?: SortOrder
    mime_type?: SortOrderInput | SortOrder
    size_bytes?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: attachmentsCountOrderByAggregateInput
    _avg?: attachmentsAvgOrderByAggregateInput
    _max?: attachmentsMaxOrderByAggregateInput
    _min?: attachmentsMinOrderByAggregateInput
    _sum?: attachmentsSumOrderByAggregateInput
  }

  export type attachmentsScalarWhereWithAggregatesInput = {
    AND?: attachmentsScalarWhereWithAggregatesInput | attachmentsScalarWhereWithAggregatesInput[]
    OR?: attachmentsScalarWhereWithAggregatesInput[]
    NOT?: attachmentsScalarWhereWithAggregatesInput | attachmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attachments"> | number
    run_result_id?: IntWithAggregatesFilter<"attachments"> | number
    file_key?: StringWithAggregatesFilter<"attachments"> | string
    mime_type?: StringNullableWithAggregatesFilter<"attachments"> | string | null
    size_bytes?: BigIntNullableWithAggregatesFilter<"attachments"> | bigint | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"attachments"> | Date | string | null
  }

  export type audit_logsWhereInput = {
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    id?: BigIntFilter<"audit_logs"> | bigint | number
    user_id?: IntNullableFilter<"audit_logs"> | number | null
    action?: StringFilter<"audit_logs"> | string
    target_type?: StringNullableFilter<"audit_logs"> | string | null
    target_id?: BigIntNullableFilter<"audit_logs"> | bigint | number | null
    meta?: JsonNullableFilter<"audit_logs">
    created_at?: DateTimeNullableFilter<"audit_logs"> | Date | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type audit_logsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    action?: SortOrder
    target_type?: SortOrderInput | SortOrder
    target_id?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    _relevance?: audit_logsOrderByRelevanceInput
  }

  export type audit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    user_id?: IntNullableFilter<"audit_logs"> | number | null
    action?: StringFilter<"audit_logs"> | string
    target_type?: StringNullableFilter<"audit_logs"> | string | null
    target_id?: BigIntNullableFilter<"audit_logs"> | bigint | number | null
    meta?: JsonNullableFilter<"audit_logs">
    created_at?: DateTimeNullableFilter<"audit_logs"> | Date | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type audit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    action?: SortOrder
    target_type?: SortOrderInput | SortOrder
    target_id?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: audit_logsCountOrderByAggregateInput
    _avg?: audit_logsAvgOrderByAggregateInput
    _max?: audit_logsMaxOrderByAggregateInput
    _min?: audit_logsMinOrderByAggregateInput
    _sum?: audit_logsSumOrderByAggregateInput
  }

  export type audit_logsScalarWhereWithAggregatesInput = {
    AND?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    OR?: audit_logsScalarWhereWithAggregatesInput[]
    NOT?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"audit_logs"> | bigint | number
    user_id?: IntNullableWithAggregatesFilter<"audit_logs"> | number | null
    action?: StringWithAggregatesFilter<"audit_logs"> | string
    target_type?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    target_id?: BigIntNullableWithAggregatesFilter<"audit_logs"> | bigint | number | null
    meta?: JsonNullableWithAggregatesFilter<"audit_logs">
    created_at?: DateTimeNullableWithAggregatesFilter<"audit_logs"> | Date | string | null
  }

  export type feature_flagsWhereInput = {
    AND?: feature_flagsWhereInput | feature_flagsWhereInput[]
    OR?: feature_flagsWhereInput[]
    NOT?: feature_flagsWhereInput | feature_flagsWhereInput[]
    flag_name?: StringFilter<"feature_flags"> | string
    is_enabled?: BoolNullableFilter<"feature_flags"> | boolean | null
    rollout_percentage?: IntNullableFilter<"feature_flags"> | number | null
    updated_at?: DateTimeNullableFilter<"feature_flags"> | Date | string | null
  }

  export type feature_flagsOrderByWithRelationInput = {
    flag_name?: SortOrder
    is_enabled?: SortOrderInput | SortOrder
    rollout_percentage?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: feature_flagsOrderByRelevanceInput
  }

  export type feature_flagsWhereUniqueInput = Prisma.AtLeast<{
    flag_name?: string
    AND?: feature_flagsWhereInput | feature_flagsWhereInput[]
    OR?: feature_flagsWhereInput[]
    NOT?: feature_flagsWhereInput | feature_flagsWhereInput[]
    is_enabled?: BoolNullableFilter<"feature_flags"> | boolean | null
    rollout_percentage?: IntNullableFilter<"feature_flags"> | number | null
    updated_at?: DateTimeNullableFilter<"feature_flags"> | Date | string | null
  }, "flag_name">

  export type feature_flagsOrderByWithAggregationInput = {
    flag_name?: SortOrder
    is_enabled?: SortOrderInput | SortOrder
    rollout_percentage?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: feature_flagsCountOrderByAggregateInput
    _avg?: feature_flagsAvgOrderByAggregateInput
    _max?: feature_flagsMaxOrderByAggregateInput
    _min?: feature_flagsMinOrderByAggregateInput
    _sum?: feature_flagsSumOrderByAggregateInput
  }

  export type feature_flagsScalarWhereWithAggregatesInput = {
    AND?: feature_flagsScalarWhereWithAggregatesInput | feature_flagsScalarWhereWithAggregatesInput[]
    OR?: feature_flagsScalarWhereWithAggregatesInput[]
    NOT?: feature_flagsScalarWhereWithAggregatesInput | feature_flagsScalarWhereWithAggregatesInput[]
    flag_name?: StringWithAggregatesFilter<"feature_flags"> | string
    is_enabled?: BoolNullableWithAggregatesFilter<"feature_flags"> | boolean | null
    rollout_percentage?: IntNullableWithAggregatesFilter<"feature_flags"> | number | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"feature_flags"> | Date | string | null
  }

  export type job_logsWhereInput = {
    AND?: job_logsWhereInput | job_logsWhereInput[]
    OR?: job_logsWhereInput[]
    NOT?: job_logsWhereInput | job_logsWhereInput[]
    id?: BigIntFilter<"job_logs"> | bigint | number
    job_name?: StringFilter<"job_logs"> | string
    status?: Enumjob_logs_statusFilter<"job_logs"> | $Enums.job_logs_status
    message?: StringNullableFilter<"job_logs"> | string | null
    started_at?: DateTimeNullableFilter<"job_logs"> | Date | string | null
    ended_at?: DateTimeNullableFilter<"job_logs"> | Date | string | null
  }

  export type job_logsOrderByWithRelationInput = {
    id?: SortOrder
    job_name?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    ended_at?: SortOrderInput | SortOrder
    _relevance?: job_logsOrderByRelevanceInput
  }

  export type job_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: job_logsWhereInput | job_logsWhereInput[]
    OR?: job_logsWhereInput[]
    NOT?: job_logsWhereInput | job_logsWhereInput[]
    job_name?: StringFilter<"job_logs"> | string
    status?: Enumjob_logs_statusFilter<"job_logs"> | $Enums.job_logs_status
    message?: StringNullableFilter<"job_logs"> | string | null
    started_at?: DateTimeNullableFilter<"job_logs"> | Date | string | null
    ended_at?: DateTimeNullableFilter<"job_logs"> | Date | string | null
  }, "id">

  export type job_logsOrderByWithAggregationInput = {
    id?: SortOrder
    job_name?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    ended_at?: SortOrderInput | SortOrder
    _count?: job_logsCountOrderByAggregateInput
    _avg?: job_logsAvgOrderByAggregateInput
    _max?: job_logsMaxOrderByAggregateInput
    _min?: job_logsMinOrderByAggregateInput
    _sum?: job_logsSumOrderByAggregateInput
  }

  export type job_logsScalarWhereWithAggregatesInput = {
    AND?: job_logsScalarWhereWithAggregatesInput | job_logsScalarWhereWithAggregatesInput[]
    OR?: job_logsScalarWhereWithAggregatesInput[]
    NOT?: job_logsScalarWhereWithAggregatesInput | job_logsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"job_logs"> | bigint | number
    job_name?: StringWithAggregatesFilter<"job_logs"> | string
    status?: Enumjob_logs_statusWithAggregatesFilter<"job_logs"> | $Enums.job_logs_status
    message?: StringNullableWithAggregatesFilter<"job_logs"> | string | null
    started_at?: DateTimeNullableWithAggregatesFilter<"job_logs"> | Date | string | null
    ended_at?: DateTimeNullableWithAggregatesFilter<"job_logs"> | Date | string | null
  }

  export type metrics_dailyWhereInput = {
    AND?: metrics_dailyWhereInput | metrics_dailyWhereInput[]
    OR?: metrics_dailyWhereInput[]
    NOT?: metrics_dailyWhereInput | metrics_dailyWhereInput[]
    metric_date?: DateTimeFilter<"metrics_daily"> | Date | string
    suite_id?: IntFilter<"metrics_daily"> | number
    pass_rate?: DecimalNullableFilter<"metrics_daily"> | Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: IntNullableFilter<"metrics_daily"> | number | null
  }

  export type metrics_dailyOrderByWithRelationInput = {
    metric_date?: SortOrder
    suite_id?: SortOrder
    pass_rate?: SortOrderInput | SortOrder
    avg_duration_ms?: SortOrderInput | SortOrder
  }

  export type metrics_dailyWhereUniqueInput = Prisma.AtLeast<{
    metric_date_suite_id?: metrics_dailyMetric_dateSuite_idCompoundUniqueInput
    AND?: metrics_dailyWhereInput | metrics_dailyWhereInput[]
    OR?: metrics_dailyWhereInput[]
    NOT?: metrics_dailyWhereInput | metrics_dailyWhereInput[]
    metric_date?: DateTimeFilter<"metrics_daily"> | Date | string
    suite_id?: IntFilter<"metrics_daily"> | number
    pass_rate?: DecimalNullableFilter<"metrics_daily"> | Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: IntNullableFilter<"metrics_daily"> | number | null
  }, "metric_date_suite_id">

  export type metrics_dailyOrderByWithAggregationInput = {
    metric_date?: SortOrder
    suite_id?: SortOrder
    pass_rate?: SortOrderInput | SortOrder
    avg_duration_ms?: SortOrderInput | SortOrder
    _count?: metrics_dailyCountOrderByAggregateInput
    _avg?: metrics_dailyAvgOrderByAggregateInput
    _max?: metrics_dailyMaxOrderByAggregateInput
    _min?: metrics_dailyMinOrderByAggregateInput
    _sum?: metrics_dailySumOrderByAggregateInput
  }

  export type metrics_dailyScalarWhereWithAggregatesInput = {
    AND?: metrics_dailyScalarWhereWithAggregatesInput | metrics_dailyScalarWhereWithAggregatesInput[]
    OR?: metrics_dailyScalarWhereWithAggregatesInput[]
    NOT?: metrics_dailyScalarWhereWithAggregatesInput | metrics_dailyScalarWhereWithAggregatesInput[]
    metric_date?: DateTimeWithAggregatesFilter<"metrics_daily"> | Date | string
    suite_id?: IntWithAggregatesFilter<"metrics_daily"> | number
    pass_rate?: DecimalNullableWithAggregatesFilter<"metrics_daily"> | Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: IntNullableWithAggregatesFilter<"metrics_daily"> | number | null
  }

  export type reportsWhereInput = {
    AND?: reportsWhereInput | reportsWhereInput[]
    OR?: reportsWhereInput[]
    NOT?: reportsWhereInput | reportsWhereInput[]
    id?: IntFilter<"reports"> | number
    run_id?: IntFilter<"reports"> | number
    summary?: JsonNullableFilter<"reports">
    generated_at?: DateTimeNullableFilter<"reports"> | Date | string | null
    test_runs?: XOR<Test_runsScalarRelationFilter, test_runsWhereInput>
  }

  export type reportsOrderByWithRelationInput = {
    id?: SortOrder
    run_id?: SortOrder
    summary?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    test_runs?: test_runsOrderByWithRelationInput
  }

  export type reportsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: reportsWhereInput | reportsWhereInput[]
    OR?: reportsWhereInput[]
    NOT?: reportsWhereInput | reportsWhereInput[]
    run_id?: IntFilter<"reports"> | number
    summary?: JsonNullableFilter<"reports">
    generated_at?: DateTimeNullableFilter<"reports"> | Date | string | null
    test_runs?: XOR<Test_runsScalarRelationFilter, test_runsWhereInput>
  }, "id">

  export type reportsOrderByWithAggregationInput = {
    id?: SortOrder
    run_id?: SortOrder
    summary?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    _count?: reportsCountOrderByAggregateInput
    _avg?: reportsAvgOrderByAggregateInput
    _max?: reportsMaxOrderByAggregateInput
    _min?: reportsMinOrderByAggregateInput
    _sum?: reportsSumOrderByAggregateInput
  }

  export type reportsScalarWhereWithAggregatesInput = {
    AND?: reportsScalarWhereWithAggregatesInput | reportsScalarWhereWithAggregatesInput[]
    OR?: reportsScalarWhereWithAggregatesInput[]
    NOT?: reportsScalarWhereWithAggregatesInput | reportsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"reports"> | number
    run_id?: IntWithAggregatesFilter<"reports"> | number
    summary?: JsonNullableWithAggregatesFilter<"reports">
    generated_at?: DateTimeNullableWithAggregatesFilter<"reports"> | Date | string | null
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    name?: StringFilter<"roles"> | string
    user_roles?: User_rolesListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    user_roles?: user_rolesOrderByRelationAggregateInput
    _relevance?: rolesOrderByRelevanceInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    user_roles?: User_rolesListRelationFilter
  }, "id" | "name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    name?: StringWithAggregatesFilter<"roles"> | string
  }

  export type settingsWhereInput = {
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    key?: StringFilter<"settings"> | string
    value?: StringNullableFilter<"settings"> | string | null
    updated_at?: DateTimeNullableFilter<"settings"> | Date | string | null
  }

  export type settingsOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: settingsOrderByRelevanceInput
  }

  export type settingsWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    value?: StringNullableFilter<"settings"> | string | null
    updated_at?: DateTimeNullableFilter<"settings"> | Date | string | null
  }, "key">

  export type settingsOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: settingsCountOrderByAggregateInput
    _max?: settingsMaxOrderByAggregateInput
    _min?: settingsMinOrderByAggregateInput
  }

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    OR?: settingsScalarWhereWithAggregatesInput[]
    NOT?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"settings"> | string
    value?: StringNullableWithAggregatesFilter<"settings"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"settings"> | Date | string | null
  }

  export type step_screenshotsWhereInput = {
    AND?: step_screenshotsWhereInput | step_screenshotsWhereInput[]
    OR?: step_screenshotsWhereInput[]
    NOT?: step_screenshotsWhereInput | step_screenshotsWhereInput[]
    id?: IntFilter<"step_screenshots"> | number
    run_id?: StringFilter<"step_screenshots"> | string
    test_case_id?: IntNullableFilter<"step_screenshots"> | number | null
    step_index?: StringFilter<"step_screenshots"> | string
    step_description?: StringNullableFilter<"step_screenshots"> | string | null
    status?: Enumstep_screenshots_statusFilter<"step_screenshots"> | $Enums.step_screenshots_status
    file_path?: StringFilter<"step_screenshots"> | string
    file_name?: StringFilter<"step_screenshots"> | string
    file_size?: BigIntNullableFilter<"step_screenshots"> | bigint | number | null
    mime_type?: StringNullableFilter<"step_screenshots"> | string | null
    created_at?: DateTimeNullableFilter<"step_screenshots"> | Date | string | null
    file_exists?: BoolFilter<"step_screenshots"> | boolean
    test_cases?: XOR<Test_casesNullableScalarRelationFilter, test_casesWhereInput> | null
  }

  export type step_screenshotsOrderByWithRelationInput = {
    id?: SortOrder
    run_id?: SortOrder
    test_case_id?: SortOrderInput | SortOrder
    step_index?: SortOrder
    step_description?: SortOrderInput | SortOrder
    status?: SortOrder
    file_path?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrderInput | SortOrder
    mime_type?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    file_exists?: SortOrder
    test_cases?: test_casesOrderByWithRelationInput
    _relevance?: step_screenshotsOrderByRelevanceInput
  }

  export type step_screenshotsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: step_screenshotsWhereInput | step_screenshotsWhereInput[]
    OR?: step_screenshotsWhereInput[]
    NOT?: step_screenshotsWhereInput | step_screenshotsWhereInput[]
    run_id?: StringFilter<"step_screenshots"> | string
    test_case_id?: IntNullableFilter<"step_screenshots"> | number | null
    step_index?: StringFilter<"step_screenshots"> | string
    step_description?: StringNullableFilter<"step_screenshots"> | string | null
    status?: Enumstep_screenshots_statusFilter<"step_screenshots"> | $Enums.step_screenshots_status
    file_path?: StringFilter<"step_screenshots"> | string
    file_name?: StringFilter<"step_screenshots"> | string
    file_size?: BigIntNullableFilter<"step_screenshots"> | bigint | number | null
    mime_type?: StringNullableFilter<"step_screenshots"> | string | null
    created_at?: DateTimeNullableFilter<"step_screenshots"> | Date | string | null
    file_exists?: BoolFilter<"step_screenshots"> | boolean
    test_cases?: XOR<Test_casesNullableScalarRelationFilter, test_casesWhereInput> | null
  }, "id">

  export type step_screenshotsOrderByWithAggregationInput = {
    id?: SortOrder
    run_id?: SortOrder
    test_case_id?: SortOrderInput | SortOrder
    step_index?: SortOrder
    step_description?: SortOrderInput | SortOrder
    status?: SortOrder
    file_path?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrderInput | SortOrder
    mime_type?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    file_exists?: SortOrder
    _count?: step_screenshotsCountOrderByAggregateInput
    _avg?: step_screenshotsAvgOrderByAggregateInput
    _max?: step_screenshotsMaxOrderByAggregateInput
    _min?: step_screenshotsMinOrderByAggregateInput
    _sum?: step_screenshotsSumOrderByAggregateInput
  }

  export type step_screenshotsScalarWhereWithAggregatesInput = {
    AND?: step_screenshotsScalarWhereWithAggregatesInput | step_screenshotsScalarWhereWithAggregatesInput[]
    OR?: step_screenshotsScalarWhereWithAggregatesInput[]
    NOT?: step_screenshotsScalarWhereWithAggregatesInput | step_screenshotsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"step_screenshots"> | number
    run_id?: StringWithAggregatesFilter<"step_screenshots"> | string
    test_case_id?: IntNullableWithAggregatesFilter<"step_screenshots"> | number | null
    step_index?: StringWithAggregatesFilter<"step_screenshots"> | string
    step_description?: StringNullableWithAggregatesFilter<"step_screenshots"> | string | null
    status?: Enumstep_screenshots_statusWithAggregatesFilter<"step_screenshots"> | $Enums.step_screenshots_status
    file_path?: StringWithAggregatesFilter<"step_screenshots"> | string
    file_name?: StringWithAggregatesFilter<"step_screenshots"> | string
    file_size?: BigIntNullableWithAggregatesFilter<"step_screenshots"> | bigint | number | null
    mime_type?: StringNullableWithAggregatesFilter<"step_screenshots"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"step_screenshots"> | Date | string | null
    file_exists?: BoolWithAggregatesFilter<"step_screenshots"> | boolean
  }

  export type suite_case_mapWhereInput = {
    AND?: suite_case_mapWhereInput | suite_case_mapWhereInput[]
    OR?: suite_case_mapWhereInput[]
    NOT?: suite_case_mapWhereInput | suite_case_mapWhereInput[]
    suite_id?: IntFilter<"suite_case_map"> | number
    case_id?: IntFilter<"suite_case_map"> | number
    test_suites?: XOR<Test_suitesScalarRelationFilter, test_suitesWhereInput>
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
  }

  export type suite_case_mapOrderByWithRelationInput = {
    suite_id?: SortOrder
    case_id?: SortOrder
    test_suites?: test_suitesOrderByWithRelationInput
    test_cases?: test_casesOrderByWithRelationInput
  }

  export type suite_case_mapWhereUniqueInput = Prisma.AtLeast<{
    suite_id_case_id?: suite_case_mapSuite_idCase_idCompoundUniqueInput
    AND?: suite_case_mapWhereInput | suite_case_mapWhereInput[]
    OR?: suite_case_mapWhereInput[]
    NOT?: suite_case_mapWhereInput | suite_case_mapWhereInput[]
    suite_id?: IntFilter<"suite_case_map"> | number
    case_id?: IntFilter<"suite_case_map"> | number
    test_suites?: XOR<Test_suitesScalarRelationFilter, test_suitesWhereInput>
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
  }, "suite_id_case_id">

  export type suite_case_mapOrderByWithAggregationInput = {
    suite_id?: SortOrder
    case_id?: SortOrder
    _count?: suite_case_mapCountOrderByAggregateInput
    _avg?: suite_case_mapAvgOrderByAggregateInput
    _max?: suite_case_mapMaxOrderByAggregateInput
    _min?: suite_case_mapMinOrderByAggregateInput
    _sum?: suite_case_mapSumOrderByAggregateInput
  }

  export type suite_case_mapScalarWhereWithAggregatesInput = {
    AND?: suite_case_mapScalarWhereWithAggregatesInput | suite_case_mapScalarWhereWithAggregatesInput[]
    OR?: suite_case_mapScalarWhereWithAggregatesInput[]
    NOT?: suite_case_mapScalarWhereWithAggregatesInput | suite_case_mapScalarWhereWithAggregatesInput[]
    suite_id?: IntWithAggregatesFilter<"suite_case_map"> | number
    case_id?: IntWithAggregatesFilter<"suite_case_map"> | number
  }

  export type test_casesWhereInput = {
    AND?: test_casesWhereInput | test_casesWhereInput[]
    OR?: test_casesWhereInput[]
    NOT?: test_casesWhereInput | test_casesWhereInput[]
    id?: IntFilter<"test_cases"> | number
    title?: StringFilter<"test_cases"> | string
    steps?: JsonNullableFilter<"test_cases">
    tags?: JsonNullableFilter<"test_cases">
    system?: StringNullableFilter<"test_cases"> | string | null
    module?: StringNullableFilter<"test_cases"> | string | null
    project?: StringNullableFilter<"test_cases"> | string | null
    created_at?: DateTimeNullableFilter<"test_cases"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"test_cases"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"test_cases"> | Date | string | null
    patch_proposals?: Case_patch_proposalsListRelationFilter
    case_versions?: Case_versionsListRelationFilter
    step_screenshots?: Step_screenshotsListRelationFilter
    suite_case_map?: Suite_case_mapListRelationFilter
    test_case_executions?: Test_case_executionsListRelationFilter
    test_run_results?: Test_run_resultsListRelationFilter
  }

  export type test_casesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    steps?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    module?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    patch_proposals?: case_patch_proposalsOrderByRelationAggregateInput
    case_versions?: case_versionsOrderByRelationAggregateInput
    step_screenshots?: step_screenshotsOrderByRelationAggregateInput
    suite_case_map?: suite_case_mapOrderByRelationAggregateInput
    test_case_executions?: test_case_executionsOrderByRelationAggregateInput
    test_run_results?: test_run_resultsOrderByRelationAggregateInput
    _relevance?: test_casesOrderByRelevanceInput
  }

  export type test_casesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: test_casesWhereInput | test_casesWhereInput[]
    OR?: test_casesWhereInput[]
    NOT?: test_casesWhereInput | test_casesWhereInput[]
    title?: StringFilter<"test_cases"> | string
    steps?: JsonNullableFilter<"test_cases">
    tags?: JsonNullableFilter<"test_cases">
    system?: StringNullableFilter<"test_cases"> | string | null
    module?: StringNullableFilter<"test_cases"> | string | null
    project?: StringNullableFilter<"test_cases"> | string | null
    created_at?: DateTimeNullableFilter<"test_cases"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"test_cases"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"test_cases"> | Date | string | null
    patch_proposals?: Case_patch_proposalsListRelationFilter
    case_versions?: Case_versionsListRelationFilter
    step_screenshots?: Step_screenshotsListRelationFilter
    suite_case_map?: Suite_case_mapListRelationFilter
    test_case_executions?: Test_case_executionsListRelationFilter
    test_run_results?: Test_run_resultsListRelationFilter
  }, "id">

  export type test_casesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    steps?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    module?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: test_casesCountOrderByAggregateInput
    _avg?: test_casesAvgOrderByAggregateInput
    _max?: test_casesMaxOrderByAggregateInput
    _min?: test_casesMinOrderByAggregateInput
    _sum?: test_casesSumOrderByAggregateInput
  }

  export type test_casesScalarWhereWithAggregatesInput = {
    AND?: test_casesScalarWhereWithAggregatesInput | test_casesScalarWhereWithAggregatesInput[]
    OR?: test_casesScalarWhereWithAggregatesInput[]
    NOT?: test_casesScalarWhereWithAggregatesInput | test_casesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"test_cases"> | number
    title?: StringWithAggregatesFilter<"test_cases"> | string
    steps?: JsonNullableWithAggregatesFilter<"test_cases">
    tags?: JsonNullableWithAggregatesFilter<"test_cases">
    system?: StringNullableWithAggregatesFilter<"test_cases"> | string | null
    module?: StringNullableWithAggregatesFilter<"test_cases"> | string | null
    project?: StringNullableWithAggregatesFilter<"test_cases"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"test_cases"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"test_cases"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"test_cases"> | Date | string | null
  }

  export type test_run_resultsWhereInput = {
    AND?: test_run_resultsWhereInput | test_run_resultsWhereInput[]
    OR?: test_run_resultsWhereInput[]
    NOT?: test_run_resultsWhereInput | test_run_resultsWhereInput[]
    id?: IntFilter<"test_run_results"> | number
    run_id?: IntFilter<"test_run_results"> | number
    case_id?: IntFilter<"test_run_results"> | number
    status?: Enumtest_run_results_statusFilter<"test_run_results"> | $Enums.test_run_results_status
    duration_ms?: IntNullableFilter<"test_run_results"> | number | null
    screenshot_url?: StringNullableFilter<"test_run_results"> | string | null
    executed_at?: DateTimeNullableFilter<"test_run_results"> | Date | string | null
    attachments?: AttachmentsListRelationFilter
    test_runs?: XOR<Test_runsScalarRelationFilter, test_runsWhereInput>
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
  }

  export type test_run_resultsOrderByWithRelationInput = {
    id?: SortOrder
    run_id?: SortOrder
    case_id?: SortOrder
    status?: SortOrder
    duration_ms?: SortOrderInput | SortOrder
    screenshot_url?: SortOrderInput | SortOrder
    executed_at?: SortOrderInput | SortOrder
    attachments?: attachmentsOrderByRelationAggregateInput
    test_runs?: test_runsOrderByWithRelationInput
    test_cases?: test_casesOrderByWithRelationInput
    _relevance?: test_run_resultsOrderByRelevanceInput
  }

  export type test_run_resultsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: test_run_resultsWhereInput | test_run_resultsWhereInput[]
    OR?: test_run_resultsWhereInput[]
    NOT?: test_run_resultsWhereInput | test_run_resultsWhereInput[]
    run_id?: IntFilter<"test_run_results"> | number
    case_id?: IntFilter<"test_run_results"> | number
    status?: Enumtest_run_results_statusFilter<"test_run_results"> | $Enums.test_run_results_status
    duration_ms?: IntNullableFilter<"test_run_results"> | number | null
    screenshot_url?: StringNullableFilter<"test_run_results"> | string | null
    executed_at?: DateTimeNullableFilter<"test_run_results"> | Date | string | null
    attachments?: AttachmentsListRelationFilter
    test_runs?: XOR<Test_runsScalarRelationFilter, test_runsWhereInput>
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
  }, "id">

  export type test_run_resultsOrderByWithAggregationInput = {
    id?: SortOrder
    run_id?: SortOrder
    case_id?: SortOrder
    status?: SortOrder
    duration_ms?: SortOrderInput | SortOrder
    screenshot_url?: SortOrderInput | SortOrder
    executed_at?: SortOrderInput | SortOrder
    _count?: test_run_resultsCountOrderByAggregateInput
    _avg?: test_run_resultsAvgOrderByAggregateInput
    _max?: test_run_resultsMaxOrderByAggregateInput
    _min?: test_run_resultsMinOrderByAggregateInput
    _sum?: test_run_resultsSumOrderByAggregateInput
  }

  export type test_run_resultsScalarWhereWithAggregatesInput = {
    AND?: test_run_resultsScalarWhereWithAggregatesInput | test_run_resultsScalarWhereWithAggregatesInput[]
    OR?: test_run_resultsScalarWhereWithAggregatesInput[]
    NOT?: test_run_resultsScalarWhereWithAggregatesInput | test_run_resultsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"test_run_results"> | number
    run_id?: IntWithAggregatesFilter<"test_run_results"> | number
    case_id?: IntWithAggregatesFilter<"test_run_results"> | number
    status?: Enumtest_run_results_statusWithAggregatesFilter<"test_run_results"> | $Enums.test_run_results_status
    duration_ms?: IntNullableWithAggregatesFilter<"test_run_results"> | number | null
    screenshot_url?: StringNullableWithAggregatesFilter<"test_run_results"> | string | null
    executed_at?: DateTimeNullableWithAggregatesFilter<"test_run_results"> | Date | string | null
  }

  export type test_runsWhereInput = {
    AND?: test_runsWhereInput | test_runsWhereInput[]
    OR?: test_runsWhereInput[]
    NOT?: test_runsWhereInput | test_runsWhereInput[]
    id?: IntFilter<"test_runs"> | number
    suite_id?: IntFilter<"test_runs"> | number
    trigger_user_id?: IntFilter<"test_runs"> | number
    status?: Enumtest_runs_statusFilter<"test_runs"> | $Enums.test_runs_status
    started_at?: DateTimeNullableFilter<"test_runs"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"test_runs"> | Date | string | null
    ai_runs?: Ai_runsListRelationFilter
    reports?: ReportsListRelationFilter
    test_run_results?: Test_run_resultsListRelationFilter
    test_suites?: XOR<Test_suitesScalarRelationFilter, test_suitesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type test_runsOrderByWithRelationInput = {
    id?: SortOrder
    suite_id?: SortOrder
    trigger_user_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    ai_runs?: ai_runsOrderByRelationAggregateInput
    reports?: reportsOrderByRelationAggregateInput
    test_run_results?: test_run_resultsOrderByRelationAggregateInput
    test_suites?: test_suitesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type test_runsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: test_runsWhereInput | test_runsWhereInput[]
    OR?: test_runsWhereInput[]
    NOT?: test_runsWhereInput | test_runsWhereInput[]
    suite_id?: IntFilter<"test_runs"> | number
    trigger_user_id?: IntFilter<"test_runs"> | number
    status?: Enumtest_runs_statusFilter<"test_runs"> | $Enums.test_runs_status
    started_at?: DateTimeNullableFilter<"test_runs"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"test_runs"> | Date | string | null
    ai_runs?: Ai_runsListRelationFilter
    reports?: ReportsListRelationFilter
    test_run_results?: Test_run_resultsListRelationFilter
    test_suites?: XOR<Test_suitesScalarRelationFilter, test_suitesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type test_runsOrderByWithAggregationInput = {
    id?: SortOrder
    suite_id?: SortOrder
    trigger_user_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    _count?: test_runsCountOrderByAggregateInput
    _avg?: test_runsAvgOrderByAggregateInput
    _max?: test_runsMaxOrderByAggregateInput
    _min?: test_runsMinOrderByAggregateInput
    _sum?: test_runsSumOrderByAggregateInput
  }

  export type test_runsScalarWhereWithAggregatesInput = {
    AND?: test_runsScalarWhereWithAggregatesInput | test_runsScalarWhereWithAggregatesInput[]
    OR?: test_runsScalarWhereWithAggregatesInput[]
    NOT?: test_runsScalarWhereWithAggregatesInput | test_runsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"test_runs"> | number
    suite_id?: IntWithAggregatesFilter<"test_runs"> | number
    trigger_user_id?: IntWithAggregatesFilter<"test_runs"> | number
    status?: Enumtest_runs_statusWithAggregatesFilter<"test_runs"> | $Enums.test_runs_status
    started_at?: DateTimeNullableWithAggregatesFilter<"test_runs"> | Date | string | null
    finished_at?: DateTimeNullableWithAggregatesFilter<"test_runs"> | Date | string | null
  }

  export type test_suitesWhereInput = {
    AND?: test_suitesWhereInput | test_suitesWhereInput[]
    OR?: test_suitesWhereInput[]
    NOT?: test_suitesWhereInput | test_suitesWhereInput[]
    id?: IntFilter<"test_suites"> | number
    name?: StringFilter<"test_suites"> | string
    owner_id?: IntFilter<"test_suites"> | number
    project?: StringNullableFilter<"test_suites"> | string | null
    metadata?: JsonNullableFilter<"test_suites">
    created_at?: DateTimeNullableFilter<"test_suites"> | Date | string | null
    suite_case_map?: Suite_case_mapListRelationFilter
    test_runs?: Test_runsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type test_suitesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    project?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    suite_case_map?: suite_case_mapOrderByRelationAggregateInput
    test_runs?: test_runsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    _relevance?: test_suitesOrderByRelevanceInput
  }

  export type test_suitesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: test_suitesWhereInput | test_suitesWhereInput[]
    OR?: test_suitesWhereInput[]
    NOT?: test_suitesWhereInput | test_suitesWhereInput[]
    name?: StringFilter<"test_suites"> | string
    owner_id?: IntFilter<"test_suites"> | number
    project?: StringNullableFilter<"test_suites"> | string | null
    metadata?: JsonNullableFilter<"test_suites">
    created_at?: DateTimeNullableFilter<"test_suites"> | Date | string | null
    suite_case_map?: Suite_case_mapListRelationFilter
    test_runs?: Test_runsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type test_suitesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    project?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: test_suitesCountOrderByAggregateInput
    _avg?: test_suitesAvgOrderByAggregateInput
    _max?: test_suitesMaxOrderByAggregateInput
    _min?: test_suitesMinOrderByAggregateInput
    _sum?: test_suitesSumOrderByAggregateInput
  }

  export type test_suitesScalarWhereWithAggregatesInput = {
    AND?: test_suitesScalarWhereWithAggregatesInput | test_suitesScalarWhereWithAggregatesInput[]
    OR?: test_suitesScalarWhereWithAggregatesInput[]
    NOT?: test_suitesScalarWhereWithAggregatesInput | test_suitesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"test_suites"> | number
    name?: StringWithAggregatesFilter<"test_suites"> | string
    owner_id?: IntWithAggregatesFilter<"test_suites"> | number
    project?: StringNullableWithAggregatesFilter<"test_suites"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"test_suites">
    created_at?: DateTimeNullableWithAggregatesFilter<"test_suites"> | Date | string | null
  }

  export type user_rolesWhereInput = {
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    user_id?: IntFilter<"user_roles"> | number
    role_id?: IntFilter<"user_roles"> | number
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type user_rolesOrderByWithRelationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    users?: usersOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type user_rolesWhereUniqueInput = Prisma.AtLeast<{
    user_id_role_id?: user_rolesUser_idRole_idCompoundUniqueInput
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    user_id?: IntFilter<"user_roles"> | number
    role_id?: IntFilter<"user_roles"> | number
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "user_id_role_id">

  export type user_rolesOrderByWithAggregationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    _count?: user_rolesCountOrderByAggregateInput
    _avg?: user_rolesAvgOrderByAggregateInput
    _max?: user_rolesMaxOrderByAggregateInput
    _min?: user_rolesMinOrderByAggregateInput
    _sum?: user_rolesSumOrderByAggregateInput
  }

  export type user_rolesScalarWhereWithAggregatesInput = {
    AND?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    OR?: user_rolesScalarWhereWithAggregatesInput[]
    NOT?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"user_roles"> | number
    role_id?: IntWithAggregatesFilter<"user_roles"> | number
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    email?: StringFilter<"users"> | string
    username?: StringFilter<"users"> | string
    account_name?: StringNullableFilter<"users"> | string | null
    password_hash?: StringFilter<"users"> | string
    project?: StringNullableFilter<"users"> | string | null
    is_super_admin?: BoolFilter<"users"> | boolean
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    ai_generation_sessions?: Ai_generation_sessionsListRelationFilter
    api_tokens?: Api_tokensListRelationFilter
    audit_logs?: Audit_logsListRelationFilter
    bulk_edit_sessions?: Bulk_edit_sessionsListRelationFilter
    case_versions?: Case_versionsListRelationFilter
    functional_test_cases?: Functional_test_casesListRelationFilter
    requirement_documents?: Requirement_documentsListRelationFilter
    test_case_executions?: Test_case_executionsListRelationFilter
    test_runs?: Test_runsListRelationFilter
    test_suites?: Test_suitesListRelationFilter
    user_roles?: User_rolesListRelationFilter
    functional_test_executions?: Functional_test_executionsListRelationFilter
    test_plans?: Test_plansListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    account_name?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    project?: SortOrderInput | SortOrder
    is_super_admin?: SortOrder
    created_at?: SortOrderInput | SortOrder
    ai_generation_sessions?: ai_generation_sessionsOrderByRelationAggregateInput
    api_tokens?: api_tokensOrderByRelationAggregateInput
    audit_logs?: audit_logsOrderByRelationAggregateInput
    bulk_edit_sessions?: bulk_edit_sessionsOrderByRelationAggregateInput
    case_versions?: case_versionsOrderByRelationAggregateInput
    functional_test_cases?: functional_test_casesOrderByRelationAggregateInput
    requirement_documents?: requirement_documentsOrderByRelationAggregateInput
    test_case_executions?: test_case_executionsOrderByRelationAggregateInput
    test_runs?: test_runsOrderByRelationAggregateInput
    test_suites?: test_suitesOrderByRelationAggregateInput
    user_roles?: user_rolesOrderByRelationAggregateInput
    functional_test_executions?: functional_test_executionsOrderByRelationAggregateInput
    test_plans?: test_plansOrderByRelationAggregateInput
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    username?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    account_name?: StringNullableFilter<"users"> | string | null
    password_hash?: StringFilter<"users"> | string
    project?: StringNullableFilter<"users"> | string | null
    is_super_admin?: BoolFilter<"users"> | boolean
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    ai_generation_sessions?: Ai_generation_sessionsListRelationFilter
    api_tokens?: Api_tokensListRelationFilter
    audit_logs?: Audit_logsListRelationFilter
    bulk_edit_sessions?: Bulk_edit_sessionsListRelationFilter
    case_versions?: Case_versionsListRelationFilter
    functional_test_cases?: Functional_test_casesListRelationFilter
    requirement_documents?: Requirement_documentsListRelationFilter
    test_case_executions?: Test_case_executionsListRelationFilter
    test_runs?: Test_runsListRelationFilter
    test_suites?: Test_suitesListRelationFilter
    user_roles?: User_rolesListRelationFilter
    functional_test_executions?: Functional_test_executionsListRelationFilter
    test_plans?: Test_plansListRelationFilter
  }, "id" | "email" | "username">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    account_name?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    project?: SortOrderInput | SortOrder
    is_super_admin?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    email?: StringWithAggregatesFilter<"users"> | string
    username?: StringWithAggregatesFilter<"users"> | string
    account_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    password_hash?: StringWithAggregatesFilter<"users"> | string
    project?: StringNullableWithAggregatesFilter<"users"> | string | null
    is_super_admin?: BoolWithAggregatesFilter<"users"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type run_artifactsWhereInput = {
    AND?: run_artifactsWhereInput | run_artifactsWhereInput[]
    OR?: run_artifactsWhereInput[]
    NOT?: run_artifactsWhereInput | run_artifactsWhereInput[]
    id?: IntFilter<"run_artifacts"> | number
    runId?: StringFilter<"run_artifacts"> | string
    type?: StringFilter<"run_artifacts"> | string
    filename?: StringFilter<"run_artifacts"> | string
    size?: BigIntFilter<"run_artifacts"> | bigint | number
    createdAt?: DateTimeFilter<"run_artifacts"> | Date | string
  }

  export type run_artifactsOrderByWithRelationInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    _relevance?: run_artifactsOrderByRelevanceInput
  }

  export type run_artifactsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: run_artifactsWhereInput | run_artifactsWhereInput[]
    OR?: run_artifactsWhereInput[]
    NOT?: run_artifactsWhereInput | run_artifactsWhereInput[]
    runId?: StringFilter<"run_artifacts"> | string
    type?: StringFilter<"run_artifacts"> | string
    filename?: StringFilter<"run_artifacts"> | string
    size?: BigIntFilter<"run_artifacts"> | bigint | number
    createdAt?: DateTimeFilter<"run_artifacts"> | Date | string
  }, "id">

  export type run_artifactsOrderByWithAggregationInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    _count?: run_artifactsCountOrderByAggregateInput
    _avg?: run_artifactsAvgOrderByAggregateInput
    _max?: run_artifactsMaxOrderByAggregateInput
    _min?: run_artifactsMinOrderByAggregateInput
    _sum?: run_artifactsSumOrderByAggregateInput
  }

  export type run_artifactsScalarWhereWithAggregatesInput = {
    AND?: run_artifactsScalarWhereWithAggregatesInput | run_artifactsScalarWhereWithAggregatesInput[]
    OR?: run_artifactsScalarWhereWithAggregatesInput[]
    NOT?: run_artifactsScalarWhereWithAggregatesInput | run_artifactsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"run_artifacts"> | number
    runId?: StringWithAggregatesFilter<"run_artifacts"> | string
    type?: StringWithAggregatesFilter<"run_artifacts"> | string
    filename?: StringWithAggregatesFilter<"run_artifacts"> | string
    size?: BigIntWithAggregatesFilter<"run_artifacts"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"run_artifacts"> | Date | string
  }

  export type case_versionsWhereInput = {
    AND?: case_versionsWhereInput | case_versionsWhereInput[]
    OR?: case_versionsWhereInput[]
    NOT?: case_versionsWhereInput | case_versionsWhereInput[]
    id?: IntFilter<"case_versions"> | number
    case_id?: IntFilter<"case_versions"> | number
    version?: IntFilter<"case_versions"> | number
    steps?: JsonNullableFilter<"case_versions">
    tags?: JsonNullableFilter<"case_versions">
    system?: StringNullableFilter<"case_versions"> | string | null
    module?: StringNullableFilter<"case_versions"> | string | null
    meta?: JsonNullableFilter<"case_versions">
    created_by?: IntNullableFilter<"case_versions"> | number | null
    created_at?: DateTimeNullableFilter<"case_versions"> | Date | string | null
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type case_versionsOrderByWithRelationInput = {
    id?: SortOrder
    case_id?: SortOrder
    version?: SortOrder
    steps?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    module?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    test_cases?: test_casesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    _relevance?: case_versionsOrderByRelevanceInput
  }

  export type case_versionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    case_id_version?: case_versionsCase_idVersionCompoundUniqueInput
    AND?: case_versionsWhereInput | case_versionsWhereInput[]
    OR?: case_versionsWhereInput[]
    NOT?: case_versionsWhereInput | case_versionsWhereInput[]
    case_id?: IntFilter<"case_versions"> | number
    version?: IntFilter<"case_versions"> | number
    steps?: JsonNullableFilter<"case_versions">
    tags?: JsonNullableFilter<"case_versions">
    system?: StringNullableFilter<"case_versions"> | string | null
    module?: StringNullableFilter<"case_versions"> | string | null
    meta?: JsonNullableFilter<"case_versions">
    created_by?: IntNullableFilter<"case_versions"> | number | null
    created_at?: DateTimeNullableFilter<"case_versions"> | Date | string | null
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id" | "case_id_version">

  export type case_versionsOrderByWithAggregationInput = {
    id?: SortOrder
    case_id?: SortOrder
    version?: SortOrder
    steps?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    module?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: case_versionsCountOrderByAggregateInput
    _avg?: case_versionsAvgOrderByAggregateInput
    _max?: case_versionsMaxOrderByAggregateInput
    _min?: case_versionsMinOrderByAggregateInput
    _sum?: case_versionsSumOrderByAggregateInput
  }

  export type case_versionsScalarWhereWithAggregatesInput = {
    AND?: case_versionsScalarWhereWithAggregatesInput | case_versionsScalarWhereWithAggregatesInput[]
    OR?: case_versionsScalarWhereWithAggregatesInput[]
    NOT?: case_versionsScalarWhereWithAggregatesInput | case_versionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"case_versions"> | number
    case_id?: IntWithAggregatesFilter<"case_versions"> | number
    version?: IntWithAggregatesFilter<"case_versions"> | number
    steps?: JsonNullableWithAggregatesFilter<"case_versions">
    tags?: JsonNullableWithAggregatesFilter<"case_versions">
    system?: StringNullableWithAggregatesFilter<"case_versions"> | string | null
    module?: StringNullableWithAggregatesFilter<"case_versions"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"case_versions">
    created_by?: IntNullableWithAggregatesFilter<"case_versions"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"case_versions"> | Date | string | null
  }

  export type bulk_edit_sessionsWhereInput = {
    AND?: bulk_edit_sessionsWhereInput | bulk_edit_sessionsWhereInput[]
    OR?: bulk_edit_sessionsWhereInput[]
    NOT?: bulk_edit_sessionsWhereInput | bulk_edit_sessionsWhereInput[]
    id?: IntFilter<"bulk_edit_sessions"> | number
    system?: StringFilter<"bulk_edit_sessions"> | string
    module?: StringFilter<"bulk_edit_sessions"> | string
    tag_filter?: JsonNullableFilter<"bulk_edit_sessions">
    priority_filter?: StringNullableFilter<"bulk_edit_sessions"> | string | null
    change_brief?: StringFilter<"bulk_edit_sessions"> | string
    status?: Enumbulk_edit_sessions_statusFilter<"bulk_edit_sessions"> | $Enums.bulk_edit_sessions_status
    created_by?: IntFilter<"bulk_edit_sessions"> | number
    created_at?: DateTimeNullableFilter<"bulk_edit_sessions"> | Date | string | null
    applied_at?: DateTimeNullableFilter<"bulk_edit_sessions"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    proposals?: Case_patch_proposalsListRelationFilter
  }

  export type bulk_edit_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    system?: SortOrder
    module?: SortOrder
    tag_filter?: SortOrderInput | SortOrder
    priority_filter?: SortOrderInput | SortOrder
    change_brief?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrderInput | SortOrder
    applied_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    proposals?: case_patch_proposalsOrderByRelationAggregateInput
    _relevance?: bulk_edit_sessionsOrderByRelevanceInput
  }

  export type bulk_edit_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bulk_edit_sessionsWhereInput | bulk_edit_sessionsWhereInput[]
    OR?: bulk_edit_sessionsWhereInput[]
    NOT?: bulk_edit_sessionsWhereInput | bulk_edit_sessionsWhereInput[]
    system?: StringFilter<"bulk_edit_sessions"> | string
    module?: StringFilter<"bulk_edit_sessions"> | string
    tag_filter?: JsonNullableFilter<"bulk_edit_sessions">
    priority_filter?: StringNullableFilter<"bulk_edit_sessions"> | string | null
    change_brief?: StringFilter<"bulk_edit_sessions"> | string
    status?: Enumbulk_edit_sessions_statusFilter<"bulk_edit_sessions"> | $Enums.bulk_edit_sessions_status
    created_by?: IntFilter<"bulk_edit_sessions"> | number
    created_at?: DateTimeNullableFilter<"bulk_edit_sessions"> | Date | string | null
    applied_at?: DateTimeNullableFilter<"bulk_edit_sessions"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    proposals?: Case_patch_proposalsListRelationFilter
  }, "id">

  export type bulk_edit_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    system?: SortOrder
    module?: SortOrder
    tag_filter?: SortOrderInput | SortOrder
    priority_filter?: SortOrderInput | SortOrder
    change_brief?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrderInput | SortOrder
    applied_at?: SortOrderInput | SortOrder
    _count?: bulk_edit_sessionsCountOrderByAggregateInput
    _avg?: bulk_edit_sessionsAvgOrderByAggregateInput
    _max?: bulk_edit_sessionsMaxOrderByAggregateInput
    _min?: bulk_edit_sessionsMinOrderByAggregateInput
    _sum?: bulk_edit_sessionsSumOrderByAggregateInput
  }

  export type bulk_edit_sessionsScalarWhereWithAggregatesInput = {
    AND?: bulk_edit_sessionsScalarWhereWithAggregatesInput | bulk_edit_sessionsScalarWhereWithAggregatesInput[]
    OR?: bulk_edit_sessionsScalarWhereWithAggregatesInput[]
    NOT?: bulk_edit_sessionsScalarWhereWithAggregatesInput | bulk_edit_sessionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bulk_edit_sessions"> | number
    system?: StringWithAggregatesFilter<"bulk_edit_sessions"> | string
    module?: StringWithAggregatesFilter<"bulk_edit_sessions"> | string
    tag_filter?: JsonNullableWithAggregatesFilter<"bulk_edit_sessions">
    priority_filter?: StringNullableWithAggregatesFilter<"bulk_edit_sessions"> | string | null
    change_brief?: StringWithAggregatesFilter<"bulk_edit_sessions"> | string
    status?: Enumbulk_edit_sessions_statusWithAggregatesFilter<"bulk_edit_sessions"> | $Enums.bulk_edit_sessions_status
    created_by?: IntWithAggregatesFilter<"bulk_edit_sessions"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"bulk_edit_sessions"> | Date | string | null
    applied_at?: DateTimeNullableWithAggregatesFilter<"bulk_edit_sessions"> | Date | string | null
  }

  export type case_patch_proposalsWhereInput = {
    AND?: case_patch_proposalsWhereInput | case_patch_proposalsWhereInput[]
    OR?: case_patch_proposalsWhereInput[]
    NOT?: case_patch_proposalsWhereInput | case_patch_proposalsWhereInput[]
    id?: IntFilter<"case_patch_proposals"> | number
    session_id?: IntFilter<"case_patch_proposals"> | number
    case_id?: IntFilter<"case_patch_proposals"> | number
    diff_json?: JsonFilter<"case_patch_proposals">
    ai_rationale?: StringNullableFilter<"case_patch_proposals"> | string | null
    side_effects?: JsonNullableFilter<"case_patch_proposals">
    risk_level?: Enumproposal_risk_levelFilter<"case_patch_proposals"> | $Enums.proposal_risk_level
    recall_reason?: StringNullableFilter<"case_patch_proposals"> | string | null
    old_hash?: StringFilter<"case_patch_proposals"> | string
    new_hash?: StringNullableFilter<"case_patch_proposals"> | string | null
    apply_status?: Enumproposal_apply_statusFilter<"case_patch_proposals"> | $Enums.proposal_apply_status
    created_at?: DateTimeNullableFilter<"case_patch_proposals"> | Date | string | null
    applied_at?: DateTimeNullableFilter<"case_patch_proposals"> | Date | string | null
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
    session?: XOR<Bulk_edit_sessionsScalarRelationFilter, bulk_edit_sessionsWhereInput>
  }

  export type case_patch_proposalsOrderByWithRelationInput = {
    id?: SortOrder
    session_id?: SortOrder
    case_id?: SortOrder
    diff_json?: SortOrder
    ai_rationale?: SortOrderInput | SortOrder
    side_effects?: SortOrderInput | SortOrder
    risk_level?: SortOrder
    recall_reason?: SortOrderInput | SortOrder
    old_hash?: SortOrder
    new_hash?: SortOrderInput | SortOrder
    apply_status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    applied_at?: SortOrderInput | SortOrder
    test_cases?: test_casesOrderByWithRelationInput
    session?: bulk_edit_sessionsOrderByWithRelationInput
    _relevance?: case_patch_proposalsOrderByRelevanceInput
  }

  export type case_patch_proposalsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: case_patch_proposalsWhereInput | case_patch_proposalsWhereInput[]
    OR?: case_patch_proposalsWhereInput[]
    NOT?: case_patch_proposalsWhereInput | case_patch_proposalsWhereInput[]
    session_id?: IntFilter<"case_patch_proposals"> | number
    case_id?: IntFilter<"case_patch_proposals"> | number
    diff_json?: JsonFilter<"case_patch_proposals">
    ai_rationale?: StringNullableFilter<"case_patch_proposals"> | string | null
    side_effects?: JsonNullableFilter<"case_patch_proposals">
    risk_level?: Enumproposal_risk_levelFilter<"case_patch_proposals"> | $Enums.proposal_risk_level
    recall_reason?: StringNullableFilter<"case_patch_proposals"> | string | null
    old_hash?: StringFilter<"case_patch_proposals"> | string
    new_hash?: StringNullableFilter<"case_patch_proposals"> | string | null
    apply_status?: Enumproposal_apply_statusFilter<"case_patch_proposals"> | $Enums.proposal_apply_status
    created_at?: DateTimeNullableFilter<"case_patch_proposals"> | Date | string | null
    applied_at?: DateTimeNullableFilter<"case_patch_proposals"> | Date | string | null
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
    session?: XOR<Bulk_edit_sessionsScalarRelationFilter, bulk_edit_sessionsWhereInput>
  }, "id">

  export type case_patch_proposalsOrderByWithAggregationInput = {
    id?: SortOrder
    session_id?: SortOrder
    case_id?: SortOrder
    diff_json?: SortOrder
    ai_rationale?: SortOrderInput | SortOrder
    side_effects?: SortOrderInput | SortOrder
    risk_level?: SortOrder
    recall_reason?: SortOrderInput | SortOrder
    old_hash?: SortOrder
    new_hash?: SortOrderInput | SortOrder
    apply_status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    applied_at?: SortOrderInput | SortOrder
    _count?: case_patch_proposalsCountOrderByAggregateInput
    _avg?: case_patch_proposalsAvgOrderByAggregateInput
    _max?: case_patch_proposalsMaxOrderByAggregateInput
    _min?: case_patch_proposalsMinOrderByAggregateInput
    _sum?: case_patch_proposalsSumOrderByAggregateInput
  }

  export type case_patch_proposalsScalarWhereWithAggregatesInput = {
    AND?: case_patch_proposalsScalarWhereWithAggregatesInput | case_patch_proposalsScalarWhereWithAggregatesInput[]
    OR?: case_patch_proposalsScalarWhereWithAggregatesInput[]
    NOT?: case_patch_proposalsScalarWhereWithAggregatesInput | case_patch_proposalsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"case_patch_proposals"> | number
    session_id?: IntWithAggregatesFilter<"case_patch_proposals"> | number
    case_id?: IntWithAggregatesFilter<"case_patch_proposals"> | number
    diff_json?: JsonWithAggregatesFilter<"case_patch_proposals">
    ai_rationale?: StringNullableWithAggregatesFilter<"case_patch_proposals"> | string | null
    side_effects?: JsonNullableWithAggregatesFilter<"case_patch_proposals">
    risk_level?: Enumproposal_risk_levelWithAggregatesFilter<"case_patch_proposals"> | $Enums.proposal_risk_level
    recall_reason?: StringNullableWithAggregatesFilter<"case_patch_proposals"> | string | null
    old_hash?: StringWithAggregatesFilter<"case_patch_proposals"> | string
    new_hash?: StringNullableWithAggregatesFilter<"case_patch_proposals"> | string | null
    apply_status?: Enumproposal_apply_statusWithAggregatesFilter<"case_patch_proposals"> | $Enums.proposal_apply_status
    created_at?: DateTimeNullableWithAggregatesFilter<"case_patch_proposals"> | Date | string | null
    applied_at?: DateTimeNullableWithAggregatesFilter<"case_patch_proposals"> | Date | string | null
  }

  export type test_case_executionsWhereInput = {
    AND?: test_case_executionsWhereInput | test_case_executionsWhereInput[]
    OR?: test_case_executionsWhereInput[]
    NOT?: test_case_executionsWhereInput | test_case_executionsWhereInput[]
    id?: StringFilter<"test_case_executions"> | string
    test_case_id?: IntFilter<"test_case_executions"> | number
    test_case_title?: StringFilter<"test_case_executions"> | string
    environment?: StringFilter<"test_case_executions"> | string
    execution_mode?: StringFilter<"test_case_executions"> | string
    status?: Enumtest_case_execution_statusFilter<"test_case_executions"> | $Enums.test_case_execution_status
    executor_user_id?: IntNullableFilter<"test_case_executions"> | number | null
    executor_project?: StringNullableFilter<"test_case_executions"> | string | null
    queued_at?: DateTimeFilter<"test_case_executions"> | Date | string
    started_at?: DateTimeNullableFilter<"test_case_executions"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"test_case_executions"> | Date | string | null
    duration_ms?: IntNullableFilter<"test_case_executions"> | number | null
    total_steps?: IntFilter<"test_case_executions"> | number
    completed_steps?: IntFilter<"test_case_executions"> | number
    passed_steps?: IntFilter<"test_case_executions"> | number
    failed_steps?: IntFilter<"test_case_executions"> | number
    progress?: IntFilter<"test_case_executions"> | number
    error_message?: StringNullableFilter<"test_case_executions"> | string | null
    execution_logs?: JsonNullableFilter<"test_case_executions">
    screenshots?: JsonNullableFilter<"test_case_executions">
    artifacts?: JsonNullableFilter<"test_case_executions">
    metadata?: JsonNullableFilter<"test_case_executions">
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
  }

  export type test_case_executionsOrderByWithRelationInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_title?: SortOrder
    environment?: SortOrder
    execution_mode?: SortOrder
    status?: SortOrder
    executor_user_id?: SortOrderInput | SortOrder
    executor_project?: SortOrderInput | SortOrder
    queued_at?: SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    duration_ms?: SortOrderInput | SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    progress?: SortOrder
    error_message?: SortOrderInput | SortOrder
    execution_logs?: SortOrderInput | SortOrder
    screenshots?: SortOrderInput | SortOrder
    artifacts?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    test_cases?: test_casesOrderByWithRelationInput
    _relevance?: test_case_executionsOrderByRelevanceInput
  }

  export type test_case_executionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: test_case_executionsWhereInput | test_case_executionsWhereInput[]
    OR?: test_case_executionsWhereInput[]
    NOT?: test_case_executionsWhereInput | test_case_executionsWhereInput[]
    test_case_id?: IntFilter<"test_case_executions"> | number
    test_case_title?: StringFilter<"test_case_executions"> | string
    environment?: StringFilter<"test_case_executions"> | string
    execution_mode?: StringFilter<"test_case_executions"> | string
    status?: Enumtest_case_execution_statusFilter<"test_case_executions"> | $Enums.test_case_execution_status
    executor_user_id?: IntNullableFilter<"test_case_executions"> | number | null
    executor_project?: StringNullableFilter<"test_case_executions"> | string | null
    queued_at?: DateTimeFilter<"test_case_executions"> | Date | string
    started_at?: DateTimeNullableFilter<"test_case_executions"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"test_case_executions"> | Date | string | null
    duration_ms?: IntNullableFilter<"test_case_executions"> | number | null
    total_steps?: IntFilter<"test_case_executions"> | number
    completed_steps?: IntFilter<"test_case_executions"> | number
    passed_steps?: IntFilter<"test_case_executions"> | number
    failed_steps?: IntFilter<"test_case_executions"> | number
    progress?: IntFilter<"test_case_executions"> | number
    error_message?: StringNullableFilter<"test_case_executions"> | string | null
    execution_logs?: JsonNullableFilter<"test_case_executions">
    screenshots?: JsonNullableFilter<"test_case_executions">
    artifacts?: JsonNullableFilter<"test_case_executions">
    metadata?: JsonNullableFilter<"test_case_executions">
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    test_cases?: XOR<Test_casesScalarRelationFilter, test_casesWhereInput>
  }, "id">

  export type test_case_executionsOrderByWithAggregationInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_title?: SortOrder
    environment?: SortOrder
    execution_mode?: SortOrder
    status?: SortOrder
    executor_user_id?: SortOrderInput | SortOrder
    executor_project?: SortOrderInput | SortOrder
    queued_at?: SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    duration_ms?: SortOrderInput | SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    progress?: SortOrder
    error_message?: SortOrderInput | SortOrder
    execution_logs?: SortOrderInput | SortOrder
    screenshots?: SortOrderInput | SortOrder
    artifacts?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: test_case_executionsCountOrderByAggregateInput
    _avg?: test_case_executionsAvgOrderByAggregateInput
    _max?: test_case_executionsMaxOrderByAggregateInput
    _min?: test_case_executionsMinOrderByAggregateInput
    _sum?: test_case_executionsSumOrderByAggregateInput
  }

  export type test_case_executionsScalarWhereWithAggregatesInput = {
    AND?: test_case_executionsScalarWhereWithAggregatesInput | test_case_executionsScalarWhereWithAggregatesInput[]
    OR?: test_case_executionsScalarWhereWithAggregatesInput[]
    NOT?: test_case_executionsScalarWhereWithAggregatesInput | test_case_executionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"test_case_executions"> | string
    test_case_id?: IntWithAggregatesFilter<"test_case_executions"> | number
    test_case_title?: StringWithAggregatesFilter<"test_case_executions"> | string
    environment?: StringWithAggregatesFilter<"test_case_executions"> | string
    execution_mode?: StringWithAggregatesFilter<"test_case_executions"> | string
    status?: Enumtest_case_execution_statusWithAggregatesFilter<"test_case_executions"> | $Enums.test_case_execution_status
    executor_user_id?: IntNullableWithAggregatesFilter<"test_case_executions"> | number | null
    executor_project?: StringNullableWithAggregatesFilter<"test_case_executions"> | string | null
    queued_at?: DateTimeWithAggregatesFilter<"test_case_executions"> | Date | string
    started_at?: DateTimeNullableWithAggregatesFilter<"test_case_executions"> | Date | string | null
    finished_at?: DateTimeNullableWithAggregatesFilter<"test_case_executions"> | Date | string | null
    duration_ms?: IntNullableWithAggregatesFilter<"test_case_executions"> | number | null
    total_steps?: IntWithAggregatesFilter<"test_case_executions"> | number
    completed_steps?: IntWithAggregatesFilter<"test_case_executions"> | number
    passed_steps?: IntWithAggregatesFilter<"test_case_executions"> | number
    failed_steps?: IntWithAggregatesFilter<"test_case_executions"> | number
    progress?: IntWithAggregatesFilter<"test_case_executions"> | number
    error_message?: StringNullableWithAggregatesFilter<"test_case_executions"> | string | null
    execution_logs?: JsonNullableWithAggregatesFilter<"test_case_executions">
    screenshots?: JsonNullableWithAggregatesFilter<"test_case_executions">
    artifacts?: JsonNullableWithAggregatesFilter<"test_case_executions">
    metadata?: JsonNullableWithAggregatesFilter<"test_case_executions">
  }

  export type functional_test_casesWhereInput = {
    AND?: functional_test_casesWhereInput | functional_test_casesWhereInput[]
    OR?: functional_test_casesWhereInput[]
    NOT?: functional_test_casesWhereInput | functional_test_casesWhereInput[]
    id?: IntFilter<"functional_test_cases"> | number
    case_id?: StringNullableFilter<"functional_test_cases"> | string | null
    name?: StringFilter<"functional_test_cases"> | string
    description?: StringNullableFilter<"functional_test_cases"> | string | null
    system?: StringNullableFilter<"functional_test_cases"> | string | null
    module?: StringNullableFilter<"functional_test_cases"> | string | null
    priority?: Enumfunctional_test_priorityFilter<"functional_test_cases"> | $Enums.functional_test_priority
    tags?: StringNullableFilter<"functional_test_cases"> | string | null
    status?: Enumfunctional_test_statusFilter<"functional_test_cases"> | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFilter<"functional_test_cases"> | $Enums.functional_test_source
    ai_session_id?: StringNullableFilter<"functional_test_cases"> | string | null
    creator_id?: IntFilter<"functional_test_cases"> | number
    test_type?: StringNullableFilter<"functional_test_cases"> | string | null
    preconditions?: StringNullableFilter<"functional_test_cases"> | string | null
    test_data?: StringNullableFilter<"functional_test_cases"> | string | null
    section_id?: StringNullableFilter<"functional_test_cases"> | string | null
    section_name?: StringNullableFilter<"functional_test_cases"> | string | null
    scenario_name?: StringNullableFilter<"functional_test_cases"> | string | null
    scenario_description?: StringNullableFilter<"functional_test_cases"> | string | null
    batch_number?: IntNullableFilter<"functional_test_cases"> | number | null
    coverage_areas?: StringNullableFilter<"functional_test_cases"> | string | null
    created_at?: DateTimeFilter<"functional_test_cases"> | Date | string
    updated_at?: DateTimeFilter<"functional_test_cases"> | Date | string
    case_type?: Enumfunctional_case_typeFilter<"functional_test_cases"> | $Enums.functional_case_type
    project_version_id?: IntNullableFilter<"functional_test_cases"> | number | null
    requirement_source?: StringNullableFilter<"functional_test_cases"> | string | null
    section_description?: StringNullableFilter<"functional_test_cases"> | string | null
    expected_result?: StringNullableFilter<"functional_test_cases"> | string | null
    risk_level?: Enumfunctional_risk_levelFilter<"functional_test_cases"> | $Enums.functional_risk_level
    steps?: StringNullableFilter<"functional_test_cases"> | string | null
    test_point_name?: StringNullableFilter<"functional_test_cases"> | string | null
    test_purpose?: StringNullableFilter<"functional_test_cases"> | string | null
    requirement_doc_id?: IntNullableFilter<"functional_test_cases"> | number | null
    deleted_at?: DateTimeNullableFilter<"functional_test_cases"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    project_version?: XOR<Project_versionsNullableScalarRelationFilter, project_versionsWhereInput> | null
    requirement_doc?: XOR<Requirement_documentsNullableScalarRelationFilter, requirement_documentsWhereInput> | null
    executions?: Functional_test_executionsListRelationFilter
  }

  export type functional_test_casesOrderByWithRelationInput = {
    id?: SortOrder
    case_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    module?: SortOrderInput | SortOrder
    priority?: SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrder
    ai_session_id?: SortOrderInput | SortOrder
    creator_id?: SortOrder
    test_type?: SortOrderInput | SortOrder
    preconditions?: SortOrderInput | SortOrder
    test_data?: SortOrderInput | SortOrder
    section_id?: SortOrderInput | SortOrder
    section_name?: SortOrderInput | SortOrder
    scenario_name?: SortOrderInput | SortOrder
    scenario_description?: SortOrderInput | SortOrder
    batch_number?: SortOrderInput | SortOrder
    coverage_areas?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    case_type?: SortOrder
    project_version_id?: SortOrderInput | SortOrder
    requirement_source?: SortOrderInput | SortOrder
    section_description?: SortOrderInput | SortOrder
    expected_result?: SortOrderInput | SortOrder
    risk_level?: SortOrder
    steps?: SortOrderInput | SortOrder
    test_point_name?: SortOrderInput | SortOrder
    test_purpose?: SortOrderInput | SortOrder
    requirement_doc_id?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    project_version?: project_versionsOrderByWithRelationInput
    requirement_doc?: requirement_documentsOrderByWithRelationInput
    executions?: functional_test_executionsOrderByRelationAggregateInput
    _relevance?: functional_test_casesOrderByRelevanceInput
  }

  export type functional_test_casesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: functional_test_casesWhereInput | functional_test_casesWhereInput[]
    OR?: functional_test_casesWhereInput[]
    NOT?: functional_test_casesWhereInput | functional_test_casesWhereInput[]
    case_id?: StringNullableFilter<"functional_test_cases"> | string | null
    name?: StringFilter<"functional_test_cases"> | string
    description?: StringNullableFilter<"functional_test_cases"> | string | null
    system?: StringNullableFilter<"functional_test_cases"> | string | null
    module?: StringNullableFilter<"functional_test_cases"> | string | null
    priority?: Enumfunctional_test_priorityFilter<"functional_test_cases"> | $Enums.functional_test_priority
    tags?: StringNullableFilter<"functional_test_cases"> | string | null
    status?: Enumfunctional_test_statusFilter<"functional_test_cases"> | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFilter<"functional_test_cases"> | $Enums.functional_test_source
    ai_session_id?: StringNullableFilter<"functional_test_cases"> | string | null
    creator_id?: IntFilter<"functional_test_cases"> | number
    test_type?: StringNullableFilter<"functional_test_cases"> | string | null
    preconditions?: StringNullableFilter<"functional_test_cases"> | string | null
    test_data?: StringNullableFilter<"functional_test_cases"> | string | null
    section_id?: StringNullableFilter<"functional_test_cases"> | string | null
    section_name?: StringNullableFilter<"functional_test_cases"> | string | null
    scenario_name?: StringNullableFilter<"functional_test_cases"> | string | null
    scenario_description?: StringNullableFilter<"functional_test_cases"> | string | null
    batch_number?: IntNullableFilter<"functional_test_cases"> | number | null
    coverage_areas?: StringNullableFilter<"functional_test_cases"> | string | null
    created_at?: DateTimeFilter<"functional_test_cases"> | Date | string
    updated_at?: DateTimeFilter<"functional_test_cases"> | Date | string
    case_type?: Enumfunctional_case_typeFilter<"functional_test_cases"> | $Enums.functional_case_type
    project_version_id?: IntNullableFilter<"functional_test_cases"> | number | null
    requirement_source?: StringNullableFilter<"functional_test_cases"> | string | null
    section_description?: StringNullableFilter<"functional_test_cases"> | string | null
    expected_result?: StringNullableFilter<"functional_test_cases"> | string | null
    risk_level?: Enumfunctional_risk_levelFilter<"functional_test_cases"> | $Enums.functional_risk_level
    steps?: StringNullableFilter<"functional_test_cases"> | string | null
    test_point_name?: StringNullableFilter<"functional_test_cases"> | string | null
    test_purpose?: StringNullableFilter<"functional_test_cases"> | string | null
    requirement_doc_id?: IntNullableFilter<"functional_test_cases"> | number | null
    deleted_at?: DateTimeNullableFilter<"functional_test_cases"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    project_version?: XOR<Project_versionsNullableScalarRelationFilter, project_versionsWhereInput> | null
    requirement_doc?: XOR<Requirement_documentsNullableScalarRelationFilter, requirement_documentsWhereInput> | null
    executions?: Functional_test_executionsListRelationFilter
  }, "id">

  export type functional_test_casesOrderByWithAggregationInput = {
    id?: SortOrder
    case_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    module?: SortOrderInput | SortOrder
    priority?: SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrder
    ai_session_id?: SortOrderInput | SortOrder
    creator_id?: SortOrder
    test_type?: SortOrderInput | SortOrder
    preconditions?: SortOrderInput | SortOrder
    test_data?: SortOrderInput | SortOrder
    section_id?: SortOrderInput | SortOrder
    section_name?: SortOrderInput | SortOrder
    scenario_name?: SortOrderInput | SortOrder
    scenario_description?: SortOrderInput | SortOrder
    batch_number?: SortOrderInput | SortOrder
    coverage_areas?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    case_type?: SortOrder
    project_version_id?: SortOrderInput | SortOrder
    requirement_source?: SortOrderInput | SortOrder
    section_description?: SortOrderInput | SortOrder
    expected_result?: SortOrderInput | SortOrder
    risk_level?: SortOrder
    steps?: SortOrderInput | SortOrder
    test_point_name?: SortOrderInput | SortOrder
    test_purpose?: SortOrderInput | SortOrder
    requirement_doc_id?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: functional_test_casesCountOrderByAggregateInput
    _avg?: functional_test_casesAvgOrderByAggregateInput
    _max?: functional_test_casesMaxOrderByAggregateInput
    _min?: functional_test_casesMinOrderByAggregateInput
    _sum?: functional_test_casesSumOrderByAggregateInput
  }

  export type functional_test_casesScalarWhereWithAggregatesInput = {
    AND?: functional_test_casesScalarWhereWithAggregatesInput | functional_test_casesScalarWhereWithAggregatesInput[]
    OR?: functional_test_casesScalarWhereWithAggregatesInput[]
    NOT?: functional_test_casesScalarWhereWithAggregatesInput | functional_test_casesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"functional_test_cases"> | number
    case_id?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    name?: StringWithAggregatesFilter<"functional_test_cases"> | string
    description?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    system?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    module?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    priority?: Enumfunctional_test_priorityWithAggregatesFilter<"functional_test_cases"> | $Enums.functional_test_priority
    tags?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    status?: Enumfunctional_test_statusWithAggregatesFilter<"functional_test_cases"> | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceWithAggregatesFilter<"functional_test_cases"> | $Enums.functional_test_source
    ai_session_id?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    creator_id?: IntWithAggregatesFilter<"functional_test_cases"> | number
    test_type?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    preconditions?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    test_data?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    section_id?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    section_name?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    scenario_name?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    scenario_description?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    batch_number?: IntNullableWithAggregatesFilter<"functional_test_cases"> | number | null
    coverage_areas?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"functional_test_cases"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"functional_test_cases"> | Date | string
    case_type?: Enumfunctional_case_typeWithAggregatesFilter<"functional_test_cases"> | $Enums.functional_case_type
    project_version_id?: IntNullableWithAggregatesFilter<"functional_test_cases"> | number | null
    requirement_source?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    section_description?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    expected_result?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    risk_level?: Enumfunctional_risk_levelWithAggregatesFilter<"functional_test_cases"> | $Enums.functional_risk_level
    steps?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    test_point_name?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    test_purpose?: StringNullableWithAggregatesFilter<"functional_test_cases"> | string | null
    requirement_doc_id?: IntNullableWithAggregatesFilter<"functional_test_cases"> | number | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"functional_test_cases"> | Date | string | null
  }

  export type ai_generation_sessionsWhereInput = {
    AND?: ai_generation_sessionsWhereInput | ai_generation_sessionsWhereInput[]
    OR?: ai_generation_sessionsWhereInput[]
    NOT?: ai_generation_sessionsWhereInput | ai_generation_sessionsWhereInput[]
    id?: StringFilter<"ai_generation_sessions"> | string
    user_id?: IntFilter<"ai_generation_sessions"> | number
    axure_filename?: StringFilter<"ai_generation_sessions"> | string
    axure_file_size?: IntFilter<"ai_generation_sessions"> | number
    project_name?: StringNullableFilter<"ai_generation_sessions"> | string | null
    system_type?: StringNullableFilter<"ai_generation_sessions"> | string | null
    business_domain?: StringNullableFilter<"ai_generation_sessions"> | string | null
    requirement_doc?: StringNullableFilter<"ai_generation_sessions"> | string | null
    page_count?: IntFilter<"ai_generation_sessions"> | number
    element_count?: IntFilter<"ai_generation_sessions"> | number
    interaction_count?: IntFilter<"ai_generation_sessions"> | number
    total_generated?: IntFilter<"ai_generation_sessions"> | number
    total_saved?: IntFilter<"ai_generation_sessions"> | number
    batches?: JsonNullableFilter<"ai_generation_sessions">
    pre_analysis_result?: JsonNullableFilter<"ai_generation_sessions">
    enhanced_data?: JsonNullableFilter<"ai_generation_sessions">
    created_at?: DateTimeFilter<"ai_generation_sessions"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    requirement_documents?: Requirement_documentsListRelationFilter
  }

  export type ai_generation_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    axure_filename?: SortOrder
    axure_file_size?: SortOrder
    project_name?: SortOrderInput | SortOrder
    system_type?: SortOrderInput | SortOrder
    business_domain?: SortOrderInput | SortOrder
    requirement_doc?: SortOrderInput | SortOrder
    page_count?: SortOrder
    element_count?: SortOrder
    interaction_count?: SortOrder
    total_generated?: SortOrder
    total_saved?: SortOrder
    batches?: SortOrderInput | SortOrder
    pre_analysis_result?: SortOrderInput | SortOrder
    enhanced_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    users?: usersOrderByWithRelationInput
    requirement_documents?: requirement_documentsOrderByRelationAggregateInput
    _relevance?: ai_generation_sessionsOrderByRelevanceInput
  }

  export type ai_generation_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ai_generation_sessionsWhereInput | ai_generation_sessionsWhereInput[]
    OR?: ai_generation_sessionsWhereInput[]
    NOT?: ai_generation_sessionsWhereInput | ai_generation_sessionsWhereInput[]
    user_id?: IntFilter<"ai_generation_sessions"> | number
    axure_filename?: StringFilter<"ai_generation_sessions"> | string
    axure_file_size?: IntFilter<"ai_generation_sessions"> | number
    project_name?: StringNullableFilter<"ai_generation_sessions"> | string | null
    system_type?: StringNullableFilter<"ai_generation_sessions"> | string | null
    business_domain?: StringNullableFilter<"ai_generation_sessions"> | string | null
    requirement_doc?: StringNullableFilter<"ai_generation_sessions"> | string | null
    page_count?: IntFilter<"ai_generation_sessions"> | number
    element_count?: IntFilter<"ai_generation_sessions"> | number
    interaction_count?: IntFilter<"ai_generation_sessions"> | number
    total_generated?: IntFilter<"ai_generation_sessions"> | number
    total_saved?: IntFilter<"ai_generation_sessions"> | number
    batches?: JsonNullableFilter<"ai_generation_sessions">
    pre_analysis_result?: JsonNullableFilter<"ai_generation_sessions">
    enhanced_data?: JsonNullableFilter<"ai_generation_sessions">
    created_at?: DateTimeFilter<"ai_generation_sessions"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    requirement_documents?: Requirement_documentsListRelationFilter
  }, "id">

  export type ai_generation_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    axure_filename?: SortOrder
    axure_file_size?: SortOrder
    project_name?: SortOrderInput | SortOrder
    system_type?: SortOrderInput | SortOrder
    business_domain?: SortOrderInput | SortOrder
    requirement_doc?: SortOrderInput | SortOrder
    page_count?: SortOrder
    element_count?: SortOrder
    interaction_count?: SortOrder
    total_generated?: SortOrder
    total_saved?: SortOrder
    batches?: SortOrderInput | SortOrder
    pre_analysis_result?: SortOrderInput | SortOrder
    enhanced_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ai_generation_sessionsCountOrderByAggregateInput
    _avg?: ai_generation_sessionsAvgOrderByAggregateInput
    _max?: ai_generation_sessionsMaxOrderByAggregateInput
    _min?: ai_generation_sessionsMinOrderByAggregateInput
    _sum?: ai_generation_sessionsSumOrderByAggregateInput
  }

  export type ai_generation_sessionsScalarWhereWithAggregatesInput = {
    AND?: ai_generation_sessionsScalarWhereWithAggregatesInput | ai_generation_sessionsScalarWhereWithAggregatesInput[]
    OR?: ai_generation_sessionsScalarWhereWithAggregatesInput[]
    NOT?: ai_generation_sessionsScalarWhereWithAggregatesInput | ai_generation_sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ai_generation_sessions"> | string
    user_id?: IntWithAggregatesFilter<"ai_generation_sessions"> | number
    axure_filename?: StringWithAggregatesFilter<"ai_generation_sessions"> | string
    axure_file_size?: IntWithAggregatesFilter<"ai_generation_sessions"> | number
    project_name?: StringNullableWithAggregatesFilter<"ai_generation_sessions"> | string | null
    system_type?: StringNullableWithAggregatesFilter<"ai_generation_sessions"> | string | null
    business_domain?: StringNullableWithAggregatesFilter<"ai_generation_sessions"> | string | null
    requirement_doc?: StringNullableWithAggregatesFilter<"ai_generation_sessions"> | string | null
    page_count?: IntWithAggregatesFilter<"ai_generation_sessions"> | number
    element_count?: IntWithAggregatesFilter<"ai_generation_sessions"> | number
    interaction_count?: IntWithAggregatesFilter<"ai_generation_sessions"> | number
    total_generated?: IntWithAggregatesFilter<"ai_generation_sessions"> | number
    total_saved?: IntWithAggregatesFilter<"ai_generation_sessions"> | number
    batches?: JsonNullableWithAggregatesFilter<"ai_generation_sessions">
    pre_analysis_result?: JsonNullableWithAggregatesFilter<"ai_generation_sessions">
    enhanced_data?: JsonNullableWithAggregatesFilter<"ai_generation_sessions">
    created_at?: DateTimeWithAggregatesFilter<"ai_generation_sessions"> | Date | string
  }

  export type requirement_documentsWhereInput = {
    AND?: requirement_documentsWhereInput | requirement_documentsWhereInput[]
    OR?: requirement_documentsWhereInput[]
    NOT?: requirement_documentsWhereInput | requirement_documentsWhereInput[]
    id?: IntFilter<"requirement_documents"> | number
    title?: StringFilter<"requirement_documents"> | string
    content?: StringFilter<"requirement_documents"> | string
    summary?: StringNullableFilter<"requirement_documents"> | string | null
    source_filename?: StringNullableFilter<"requirement_documents"> | string | null
    ai_session_id?: StringNullableFilter<"requirement_documents"> | string | null
    project_id?: IntNullableFilter<"requirement_documents"> | number | null
    project_version_id?: IntNullableFilter<"requirement_documents"> | number | null
    creator_id?: IntFilter<"requirement_documents"> | number
    scenario_count?: IntFilter<"requirement_documents"> | number
    test_case_count?: IntFilter<"requirement_documents"> | number
    status?: Enumrequirement_doc_statusFilter<"requirement_documents"> | $Enums.requirement_doc_status
    created_at?: DateTimeFilter<"requirement_documents"> | Date | string
    updated_at?: DateTimeFilter<"requirement_documents"> | Date | string
    module?: StringNullableFilter<"requirement_documents"> | string | null
    system?: StringNullableFilter<"requirement_documents"> | string | null
    test_cases?: Functional_test_casesListRelationFilter
    ai_session?: XOR<Ai_generation_sessionsNullableScalarRelationFilter, ai_generation_sessionsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    project?: XOR<SystemsNullableScalarRelationFilter, systemsWhereInput> | null
    project_version?: XOR<Project_versionsNullableScalarRelationFilter, project_versionsWhereInput> | null
  }

  export type requirement_documentsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    source_filename?: SortOrderInput | SortOrder
    ai_session_id?: SortOrderInput | SortOrder
    project_id?: SortOrderInput | SortOrder
    project_version_id?: SortOrderInput | SortOrder
    creator_id?: SortOrder
    scenario_count?: SortOrder
    test_case_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    module?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    test_cases?: functional_test_casesOrderByRelationAggregateInput
    ai_session?: ai_generation_sessionsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    project?: systemsOrderByWithRelationInput
    project_version?: project_versionsOrderByWithRelationInput
    _relevance?: requirement_documentsOrderByRelevanceInput
  }

  export type requirement_documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: requirement_documentsWhereInput | requirement_documentsWhereInput[]
    OR?: requirement_documentsWhereInput[]
    NOT?: requirement_documentsWhereInput | requirement_documentsWhereInput[]
    title?: StringFilter<"requirement_documents"> | string
    content?: StringFilter<"requirement_documents"> | string
    summary?: StringNullableFilter<"requirement_documents"> | string | null
    source_filename?: StringNullableFilter<"requirement_documents"> | string | null
    ai_session_id?: StringNullableFilter<"requirement_documents"> | string | null
    project_id?: IntNullableFilter<"requirement_documents"> | number | null
    project_version_id?: IntNullableFilter<"requirement_documents"> | number | null
    creator_id?: IntFilter<"requirement_documents"> | number
    scenario_count?: IntFilter<"requirement_documents"> | number
    test_case_count?: IntFilter<"requirement_documents"> | number
    status?: Enumrequirement_doc_statusFilter<"requirement_documents"> | $Enums.requirement_doc_status
    created_at?: DateTimeFilter<"requirement_documents"> | Date | string
    updated_at?: DateTimeFilter<"requirement_documents"> | Date | string
    module?: StringNullableFilter<"requirement_documents"> | string | null
    system?: StringNullableFilter<"requirement_documents"> | string | null
    test_cases?: Functional_test_casesListRelationFilter
    ai_session?: XOR<Ai_generation_sessionsNullableScalarRelationFilter, ai_generation_sessionsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    project?: XOR<SystemsNullableScalarRelationFilter, systemsWhereInput> | null
    project_version?: XOR<Project_versionsNullableScalarRelationFilter, project_versionsWhereInput> | null
  }, "id">

  export type requirement_documentsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    source_filename?: SortOrderInput | SortOrder
    ai_session_id?: SortOrderInput | SortOrder
    project_id?: SortOrderInput | SortOrder
    project_version_id?: SortOrderInput | SortOrder
    creator_id?: SortOrder
    scenario_count?: SortOrder
    test_case_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    module?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    _count?: requirement_documentsCountOrderByAggregateInput
    _avg?: requirement_documentsAvgOrderByAggregateInput
    _max?: requirement_documentsMaxOrderByAggregateInput
    _min?: requirement_documentsMinOrderByAggregateInput
    _sum?: requirement_documentsSumOrderByAggregateInput
  }

  export type requirement_documentsScalarWhereWithAggregatesInput = {
    AND?: requirement_documentsScalarWhereWithAggregatesInput | requirement_documentsScalarWhereWithAggregatesInput[]
    OR?: requirement_documentsScalarWhereWithAggregatesInput[]
    NOT?: requirement_documentsScalarWhereWithAggregatesInput | requirement_documentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"requirement_documents"> | number
    title?: StringWithAggregatesFilter<"requirement_documents"> | string
    content?: StringWithAggregatesFilter<"requirement_documents"> | string
    summary?: StringNullableWithAggregatesFilter<"requirement_documents"> | string | null
    source_filename?: StringNullableWithAggregatesFilter<"requirement_documents"> | string | null
    ai_session_id?: StringNullableWithAggregatesFilter<"requirement_documents"> | string | null
    project_id?: IntNullableWithAggregatesFilter<"requirement_documents"> | number | null
    project_version_id?: IntNullableWithAggregatesFilter<"requirement_documents"> | number | null
    creator_id?: IntWithAggregatesFilter<"requirement_documents"> | number
    scenario_count?: IntWithAggregatesFilter<"requirement_documents"> | number
    test_case_count?: IntWithAggregatesFilter<"requirement_documents"> | number
    status?: Enumrequirement_doc_statusWithAggregatesFilter<"requirement_documents"> | $Enums.requirement_doc_status
    created_at?: DateTimeWithAggregatesFilter<"requirement_documents"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"requirement_documents"> | Date | string
    module?: StringNullableWithAggregatesFilter<"requirement_documents"> | string | null
    system?: StringNullableWithAggregatesFilter<"requirement_documents"> | string | null
  }

  export type systemsWhereInput = {
    AND?: systemsWhereInput | systemsWhereInput[]
    OR?: systemsWhereInput[]
    NOT?: systemsWhereInput | systemsWhereInput[]
    id?: IntFilter<"systems"> | number
    name?: StringFilter<"systems"> | string
    short_name?: StringNullableFilter<"systems"> | string | null
    description?: StringNullableFilter<"systems"> | string | null
    status?: Enumsystem_statusFilter<"systems"> | $Enums.system_status
    sort_order?: IntFilter<"systems"> | number
    created_at?: DateTimeFilter<"systems"> | Date | string
    updated_at?: DateTimeFilter<"systems"> | Date | string
    versions?: Project_versionsListRelationFilter
    requirement_documents?: Requirement_documentsListRelationFilter
  }

  export type systemsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    versions?: project_versionsOrderByRelationAggregateInput
    requirement_documents?: requirement_documentsOrderByRelationAggregateInput
    _relevance?: systemsOrderByRelevanceInput
  }

  export type systemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: systemsWhereInput | systemsWhereInput[]
    OR?: systemsWhereInput[]
    NOT?: systemsWhereInput | systemsWhereInput[]
    short_name?: StringNullableFilter<"systems"> | string | null
    description?: StringNullableFilter<"systems"> | string | null
    status?: Enumsystem_statusFilter<"systems"> | $Enums.system_status
    sort_order?: IntFilter<"systems"> | number
    created_at?: DateTimeFilter<"systems"> | Date | string
    updated_at?: DateTimeFilter<"systems"> | Date | string
    versions?: Project_versionsListRelationFilter
    requirement_documents?: Requirement_documentsListRelationFilter
  }, "id" | "name">

  export type systemsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: systemsCountOrderByAggregateInput
    _avg?: systemsAvgOrderByAggregateInput
    _max?: systemsMaxOrderByAggregateInput
    _min?: systemsMinOrderByAggregateInput
    _sum?: systemsSumOrderByAggregateInput
  }

  export type systemsScalarWhereWithAggregatesInput = {
    AND?: systemsScalarWhereWithAggregatesInput | systemsScalarWhereWithAggregatesInput[]
    OR?: systemsScalarWhereWithAggregatesInput[]
    NOT?: systemsScalarWhereWithAggregatesInput | systemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"systems"> | number
    name?: StringWithAggregatesFilter<"systems"> | string
    short_name?: StringNullableWithAggregatesFilter<"systems"> | string | null
    description?: StringNullableWithAggregatesFilter<"systems"> | string | null
    status?: Enumsystem_statusWithAggregatesFilter<"systems"> | $Enums.system_status
    sort_order?: IntWithAggregatesFilter<"systems"> | number
    created_at?: DateTimeWithAggregatesFilter<"systems"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"systems"> | Date | string
  }

  export type project_versionsWhereInput = {
    AND?: project_versionsWhereInput | project_versionsWhereInput[]
    OR?: project_versionsWhereInput[]
    NOT?: project_versionsWhereInput | project_versionsWhereInput[]
    id?: IntFilter<"project_versions"> | number
    project_id?: IntFilter<"project_versions"> | number
    version_name?: StringFilter<"project_versions"> | string
    version_code?: StringFilter<"project_versions"> | string
    description?: StringNullableFilter<"project_versions"> | string | null
    is_main?: BoolFilter<"project_versions"> | boolean
    status?: Enumsystem_statusFilter<"project_versions"> | $Enums.system_status
    release_date?: DateTimeNullableFilter<"project_versions"> | Date | string | null
    created_at?: DateTimeFilter<"project_versions"> | Date | string
    updated_at?: DateTimeFilter<"project_versions"> | Date | string
    functional_test_cases?: Functional_test_casesListRelationFilter
    project?: XOR<SystemsScalarRelationFilter, systemsWhereInput>
    requirement_documents?: Requirement_documentsListRelationFilter
  }

  export type project_versionsOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    version_name?: SortOrder
    version_code?: SortOrder
    description?: SortOrderInput | SortOrder
    is_main?: SortOrder
    status?: SortOrder
    release_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    functional_test_cases?: functional_test_casesOrderByRelationAggregateInput
    project?: systemsOrderByWithRelationInput
    requirement_documents?: requirement_documentsOrderByRelationAggregateInput
    _relevance?: project_versionsOrderByRelevanceInput
  }

  export type project_versionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    project_id_version_code?: project_versionsProject_idVersion_codeCompoundUniqueInput
    AND?: project_versionsWhereInput | project_versionsWhereInput[]
    OR?: project_versionsWhereInput[]
    NOT?: project_versionsWhereInput | project_versionsWhereInput[]
    project_id?: IntFilter<"project_versions"> | number
    version_name?: StringFilter<"project_versions"> | string
    version_code?: StringFilter<"project_versions"> | string
    description?: StringNullableFilter<"project_versions"> | string | null
    is_main?: BoolFilter<"project_versions"> | boolean
    status?: Enumsystem_statusFilter<"project_versions"> | $Enums.system_status
    release_date?: DateTimeNullableFilter<"project_versions"> | Date | string | null
    created_at?: DateTimeFilter<"project_versions"> | Date | string
    updated_at?: DateTimeFilter<"project_versions"> | Date | string
    functional_test_cases?: Functional_test_casesListRelationFilter
    project?: XOR<SystemsScalarRelationFilter, systemsWhereInput>
    requirement_documents?: Requirement_documentsListRelationFilter
  }, "id" | "project_id_version_code">

  export type project_versionsOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    version_name?: SortOrder
    version_code?: SortOrder
    description?: SortOrderInput | SortOrder
    is_main?: SortOrder
    status?: SortOrder
    release_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: project_versionsCountOrderByAggregateInput
    _avg?: project_versionsAvgOrderByAggregateInput
    _max?: project_versionsMaxOrderByAggregateInput
    _min?: project_versionsMinOrderByAggregateInput
    _sum?: project_versionsSumOrderByAggregateInput
  }

  export type project_versionsScalarWhereWithAggregatesInput = {
    AND?: project_versionsScalarWhereWithAggregatesInput | project_versionsScalarWhereWithAggregatesInput[]
    OR?: project_versionsScalarWhereWithAggregatesInput[]
    NOT?: project_versionsScalarWhereWithAggregatesInput | project_versionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"project_versions"> | number
    project_id?: IntWithAggregatesFilter<"project_versions"> | number
    version_name?: StringWithAggregatesFilter<"project_versions"> | string
    version_code?: StringWithAggregatesFilter<"project_versions"> | string
    description?: StringNullableWithAggregatesFilter<"project_versions"> | string | null
    is_main?: BoolWithAggregatesFilter<"project_versions"> | boolean
    status?: Enumsystem_statusWithAggregatesFilter<"project_versions"> | $Enums.system_status
    release_date?: DateTimeNullableWithAggregatesFilter<"project_versions"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"project_versions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"project_versions"> | Date | string
  }

  export type functional_test_executionsWhereInput = {
    AND?: functional_test_executionsWhereInput | functional_test_executionsWhereInput[]
    OR?: functional_test_executionsWhereInput[]
    NOT?: functional_test_executionsWhereInput | functional_test_executionsWhereInput[]
    id?: StringFilter<"functional_test_executions"> | string
    test_case_id?: IntFilter<"functional_test_executions"> | number
    test_case_name?: StringFilter<"functional_test_executions"> | string
    final_result?: Enumfunctional_execution_resultFilter<"functional_test_executions"> | $Enums.functional_execution_result
    actual_result?: StringFilter<"functional_test_executions"> | string
    comments?: StringNullableFilter<"functional_test_executions"> | string | null
    duration_ms?: IntNullableFilter<"functional_test_executions"> | number | null
    executed_at?: DateTimeFilter<"functional_test_executions"> | Date | string
    executor_id?: IntFilter<"functional_test_executions"> | number
    executor_project?: StringNullableFilter<"functional_test_executions"> | string | null
    step_results?: JsonNullableFilter<"functional_test_executions">
    total_steps?: IntFilter<"functional_test_executions"> | number
    completed_steps?: IntFilter<"functional_test_executions"> | number
    passed_steps?: IntFilter<"functional_test_executions"> | number
    failed_steps?: IntFilter<"functional_test_executions"> | number
    blocked_steps?: IntFilter<"functional_test_executions"> | number
    screenshots?: JsonNullableFilter<"functional_test_executions">
    attachments?: JsonNullableFilter<"functional_test_executions">
    metadata?: JsonNullableFilter<"functional_test_executions">
    test_case?: XOR<Functional_test_casesScalarRelationFilter, functional_test_casesWhereInput>
    executor?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type functional_test_executionsOrderByWithRelationInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_name?: SortOrder
    final_result?: SortOrder
    actual_result?: SortOrder
    comments?: SortOrderInput | SortOrder
    duration_ms?: SortOrderInput | SortOrder
    executed_at?: SortOrder
    executor_id?: SortOrder
    executor_project?: SortOrderInput | SortOrder
    step_results?: SortOrderInput | SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    blocked_steps?: SortOrder
    screenshots?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    test_case?: functional_test_casesOrderByWithRelationInput
    executor?: usersOrderByWithRelationInput
    _relevance?: functional_test_executionsOrderByRelevanceInput
  }

  export type functional_test_executionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: functional_test_executionsWhereInput | functional_test_executionsWhereInput[]
    OR?: functional_test_executionsWhereInput[]
    NOT?: functional_test_executionsWhereInput | functional_test_executionsWhereInput[]
    test_case_id?: IntFilter<"functional_test_executions"> | number
    test_case_name?: StringFilter<"functional_test_executions"> | string
    final_result?: Enumfunctional_execution_resultFilter<"functional_test_executions"> | $Enums.functional_execution_result
    actual_result?: StringFilter<"functional_test_executions"> | string
    comments?: StringNullableFilter<"functional_test_executions"> | string | null
    duration_ms?: IntNullableFilter<"functional_test_executions"> | number | null
    executed_at?: DateTimeFilter<"functional_test_executions"> | Date | string
    executor_id?: IntFilter<"functional_test_executions"> | number
    executor_project?: StringNullableFilter<"functional_test_executions"> | string | null
    step_results?: JsonNullableFilter<"functional_test_executions">
    total_steps?: IntFilter<"functional_test_executions"> | number
    completed_steps?: IntFilter<"functional_test_executions"> | number
    passed_steps?: IntFilter<"functional_test_executions"> | number
    failed_steps?: IntFilter<"functional_test_executions"> | number
    blocked_steps?: IntFilter<"functional_test_executions"> | number
    screenshots?: JsonNullableFilter<"functional_test_executions">
    attachments?: JsonNullableFilter<"functional_test_executions">
    metadata?: JsonNullableFilter<"functional_test_executions">
    test_case?: XOR<Functional_test_casesScalarRelationFilter, functional_test_casesWhereInput>
    executor?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type functional_test_executionsOrderByWithAggregationInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_name?: SortOrder
    final_result?: SortOrder
    actual_result?: SortOrder
    comments?: SortOrderInput | SortOrder
    duration_ms?: SortOrderInput | SortOrder
    executed_at?: SortOrder
    executor_id?: SortOrder
    executor_project?: SortOrderInput | SortOrder
    step_results?: SortOrderInput | SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    blocked_steps?: SortOrder
    screenshots?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: functional_test_executionsCountOrderByAggregateInput
    _avg?: functional_test_executionsAvgOrderByAggregateInput
    _max?: functional_test_executionsMaxOrderByAggregateInput
    _min?: functional_test_executionsMinOrderByAggregateInput
    _sum?: functional_test_executionsSumOrderByAggregateInput
  }

  export type functional_test_executionsScalarWhereWithAggregatesInput = {
    AND?: functional_test_executionsScalarWhereWithAggregatesInput | functional_test_executionsScalarWhereWithAggregatesInput[]
    OR?: functional_test_executionsScalarWhereWithAggregatesInput[]
    NOT?: functional_test_executionsScalarWhereWithAggregatesInput | functional_test_executionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"functional_test_executions"> | string
    test_case_id?: IntWithAggregatesFilter<"functional_test_executions"> | number
    test_case_name?: StringWithAggregatesFilter<"functional_test_executions"> | string
    final_result?: Enumfunctional_execution_resultWithAggregatesFilter<"functional_test_executions"> | $Enums.functional_execution_result
    actual_result?: StringWithAggregatesFilter<"functional_test_executions"> | string
    comments?: StringNullableWithAggregatesFilter<"functional_test_executions"> | string | null
    duration_ms?: IntNullableWithAggregatesFilter<"functional_test_executions"> | number | null
    executed_at?: DateTimeWithAggregatesFilter<"functional_test_executions"> | Date | string
    executor_id?: IntWithAggregatesFilter<"functional_test_executions"> | number
    executor_project?: StringNullableWithAggregatesFilter<"functional_test_executions"> | string | null
    step_results?: JsonNullableWithAggregatesFilter<"functional_test_executions">
    total_steps?: IntWithAggregatesFilter<"functional_test_executions"> | number
    completed_steps?: IntWithAggregatesFilter<"functional_test_executions"> | number
    passed_steps?: IntWithAggregatesFilter<"functional_test_executions"> | number
    failed_steps?: IntWithAggregatesFilter<"functional_test_executions"> | number
    blocked_steps?: IntWithAggregatesFilter<"functional_test_executions"> | number
    screenshots?: JsonNullableWithAggregatesFilter<"functional_test_executions">
    attachments?: JsonNullableWithAggregatesFilter<"functional_test_executions">
    metadata?: JsonNullableWithAggregatesFilter<"functional_test_executions">
  }

  export type test_plansWhereInput = {
    AND?: test_plansWhereInput | test_plansWhereInput[]
    OR?: test_plansWhereInput[]
    NOT?: test_plansWhereInput | test_plansWhereInput[]
    id?: IntFilter<"test_plans"> | number
    name?: StringFilter<"test_plans"> | string
    short_name?: StringNullableFilter<"test_plans"> | string | null
    description?: StringNullableFilter<"test_plans"> | string | null
    project?: StringNullableFilter<"test_plans"> | string | null
    plan_type?: Enumtest_plan_typeFilter<"test_plans"> | $Enums.test_plan_type
    status?: Enumtest_plan_statusFilter<"test_plans"> | $Enums.test_plan_status
    members?: JsonNullableFilter<"test_plans">
    owner_id?: IntFilter<"test_plans"> | number
    start_date?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    end_date?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    created_at?: DateTimeFilter<"test_plans"> | Date | string
    updated_at?: DateTimeFilter<"test_plans"> | Date | string
    deleted_at?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    owner?: XOR<UsersScalarRelationFilter, usersWhereInput>
    plan_cases?: Test_plan_casesListRelationFilter
    plan_executions?: Test_plan_executionsListRelationFilter
  }

  export type test_plansOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    plan_type?: SortOrder
    status?: SortOrder
    members?: SortOrderInput | SortOrder
    owner_id?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    owner?: usersOrderByWithRelationInput
    plan_cases?: test_plan_casesOrderByRelationAggregateInput
    plan_executions?: test_plan_executionsOrderByRelationAggregateInput
    _relevance?: test_plansOrderByRelevanceInput
  }

  export type test_plansWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: test_plansWhereInput | test_plansWhereInput[]
    OR?: test_plansWhereInput[]
    NOT?: test_plansWhereInput | test_plansWhereInput[]
    name?: StringFilter<"test_plans"> | string
    short_name?: StringNullableFilter<"test_plans"> | string | null
    description?: StringNullableFilter<"test_plans"> | string | null
    project?: StringNullableFilter<"test_plans"> | string | null
    plan_type?: Enumtest_plan_typeFilter<"test_plans"> | $Enums.test_plan_type
    status?: Enumtest_plan_statusFilter<"test_plans"> | $Enums.test_plan_status
    members?: JsonNullableFilter<"test_plans">
    owner_id?: IntFilter<"test_plans"> | number
    start_date?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    end_date?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    created_at?: DateTimeFilter<"test_plans"> | Date | string
    updated_at?: DateTimeFilter<"test_plans"> | Date | string
    deleted_at?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    owner?: XOR<UsersScalarRelationFilter, usersWhereInput>
    plan_cases?: Test_plan_casesListRelationFilter
    plan_executions?: Test_plan_executionsListRelationFilter
  }, "id">

  export type test_plansOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    plan_type?: SortOrder
    status?: SortOrder
    members?: SortOrderInput | SortOrder
    owner_id?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: test_plansCountOrderByAggregateInput
    _avg?: test_plansAvgOrderByAggregateInput
    _max?: test_plansMaxOrderByAggregateInput
    _min?: test_plansMinOrderByAggregateInput
    _sum?: test_plansSumOrderByAggregateInput
  }

  export type test_plansScalarWhereWithAggregatesInput = {
    AND?: test_plansScalarWhereWithAggregatesInput | test_plansScalarWhereWithAggregatesInput[]
    OR?: test_plansScalarWhereWithAggregatesInput[]
    NOT?: test_plansScalarWhereWithAggregatesInput | test_plansScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"test_plans"> | number
    name?: StringWithAggregatesFilter<"test_plans"> | string
    short_name?: StringNullableWithAggregatesFilter<"test_plans"> | string | null
    description?: StringNullableWithAggregatesFilter<"test_plans"> | string | null
    project?: StringNullableWithAggregatesFilter<"test_plans"> | string | null
    plan_type?: Enumtest_plan_typeWithAggregatesFilter<"test_plans"> | $Enums.test_plan_type
    status?: Enumtest_plan_statusWithAggregatesFilter<"test_plans"> | $Enums.test_plan_status
    members?: JsonNullableWithAggregatesFilter<"test_plans">
    owner_id?: IntWithAggregatesFilter<"test_plans"> | number
    start_date?: DateTimeNullableWithAggregatesFilter<"test_plans"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"test_plans"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"test_plans"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"test_plans"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"test_plans"> | Date | string | null
  }

  export type test_plan_casesWhereInput = {
    AND?: test_plan_casesWhereInput | test_plan_casesWhereInput[]
    OR?: test_plan_casesWhereInput[]
    NOT?: test_plan_casesWhereInput | test_plan_casesWhereInput[]
    id?: IntFilter<"test_plan_cases"> | number
    plan_id?: IntFilter<"test_plan_cases"> | number
    case_id?: IntFilter<"test_plan_cases"> | number
    case_type?: StringFilter<"test_plan_cases"> | string
    case_name?: StringFilter<"test_plan_cases"> | string
    sort_order?: IntFilter<"test_plan_cases"> | number
    is_executed?: BoolFilter<"test_plan_cases"> | boolean
    execution_result?: StringNullableFilter<"test_plan_cases"> | string | null
    created_at?: DateTimeFilter<"test_plan_cases"> | Date | string
    plan?: XOR<Test_plansScalarRelationFilter, test_plansWhereInput>
  }

  export type test_plan_casesOrderByWithRelationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    case_id?: SortOrder
    case_type?: SortOrder
    case_name?: SortOrder
    sort_order?: SortOrder
    is_executed?: SortOrder
    execution_result?: SortOrderInput | SortOrder
    created_at?: SortOrder
    plan?: test_plansOrderByWithRelationInput
    _relevance?: test_plan_casesOrderByRelevanceInput
  }

  export type test_plan_casesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    plan_id_case_id_case_type?: test_plan_casesPlan_idCase_idCase_typeCompoundUniqueInput
    AND?: test_plan_casesWhereInput | test_plan_casesWhereInput[]
    OR?: test_plan_casesWhereInput[]
    NOT?: test_plan_casesWhereInput | test_plan_casesWhereInput[]
    plan_id?: IntFilter<"test_plan_cases"> | number
    case_id?: IntFilter<"test_plan_cases"> | number
    case_type?: StringFilter<"test_plan_cases"> | string
    case_name?: StringFilter<"test_plan_cases"> | string
    sort_order?: IntFilter<"test_plan_cases"> | number
    is_executed?: BoolFilter<"test_plan_cases"> | boolean
    execution_result?: StringNullableFilter<"test_plan_cases"> | string | null
    created_at?: DateTimeFilter<"test_plan_cases"> | Date | string
    plan?: XOR<Test_plansScalarRelationFilter, test_plansWhereInput>
  }, "id" | "plan_id_case_id_case_type">

  export type test_plan_casesOrderByWithAggregationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    case_id?: SortOrder
    case_type?: SortOrder
    case_name?: SortOrder
    sort_order?: SortOrder
    is_executed?: SortOrder
    execution_result?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: test_plan_casesCountOrderByAggregateInput
    _avg?: test_plan_casesAvgOrderByAggregateInput
    _max?: test_plan_casesMaxOrderByAggregateInput
    _min?: test_plan_casesMinOrderByAggregateInput
    _sum?: test_plan_casesSumOrderByAggregateInput
  }

  export type test_plan_casesScalarWhereWithAggregatesInput = {
    AND?: test_plan_casesScalarWhereWithAggregatesInput | test_plan_casesScalarWhereWithAggregatesInput[]
    OR?: test_plan_casesScalarWhereWithAggregatesInput[]
    NOT?: test_plan_casesScalarWhereWithAggregatesInput | test_plan_casesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"test_plan_cases"> | number
    plan_id?: IntWithAggregatesFilter<"test_plan_cases"> | number
    case_id?: IntWithAggregatesFilter<"test_plan_cases"> | number
    case_type?: StringWithAggregatesFilter<"test_plan_cases"> | string
    case_name?: StringWithAggregatesFilter<"test_plan_cases"> | string
    sort_order?: IntWithAggregatesFilter<"test_plan_cases"> | number
    is_executed?: BoolWithAggregatesFilter<"test_plan_cases"> | boolean
    execution_result?: StringNullableWithAggregatesFilter<"test_plan_cases"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"test_plan_cases"> | Date | string
  }

  export type test_plan_executionsWhereInput = {
    AND?: test_plan_executionsWhereInput | test_plan_executionsWhereInput[]
    OR?: test_plan_executionsWhereInput[]
    NOT?: test_plan_executionsWhereInput | test_plan_executionsWhereInput[]
    id?: StringFilter<"test_plan_executions"> | string
    plan_id?: IntFilter<"test_plan_executions"> | number
    plan_name?: StringFilter<"test_plan_executions"> | string
    executor_id?: IntFilter<"test_plan_executions"> | number
    executor_name?: StringFilter<"test_plan_executions"> | string
    execution_type?: StringFilter<"test_plan_executions"> | string
    status?: StringFilter<"test_plan_executions"> | string
    progress?: IntFilter<"test_plan_executions"> | number
    total_cases?: IntFilter<"test_plan_executions"> | number
    completed_cases?: IntFilter<"test_plan_executions"> | number
    passed_cases?: IntFilter<"test_plan_executions"> | number
    failed_cases?: IntFilter<"test_plan_executions"> | number
    blocked_cases?: IntFilter<"test_plan_executions"> | number
    skipped_cases?: IntFilter<"test_plan_executions"> | number
    started_at?: DateTimeFilter<"test_plan_executions"> | Date | string
    finished_at?: DateTimeNullableFilter<"test_plan_executions"> | Date | string | null
    duration_ms?: IntNullableFilter<"test_plan_executions"> | number | null
    execution_results?: JsonNullableFilter<"test_plan_executions">
    error_message?: StringNullableFilter<"test_plan_executions"> | string | null
    metadata?: JsonNullableFilter<"test_plan_executions">
    plan?: XOR<Test_plansScalarRelationFilter, test_plansWhereInput>
  }

  export type test_plan_executionsOrderByWithRelationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    plan_name?: SortOrder
    executor_id?: SortOrder
    executor_name?: SortOrder
    execution_type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    total_cases?: SortOrder
    completed_cases?: SortOrder
    passed_cases?: SortOrder
    failed_cases?: SortOrder
    blocked_cases?: SortOrder
    skipped_cases?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrderInput | SortOrder
    duration_ms?: SortOrderInput | SortOrder
    execution_results?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    plan?: test_plansOrderByWithRelationInput
    _relevance?: test_plan_executionsOrderByRelevanceInput
  }

  export type test_plan_executionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: test_plan_executionsWhereInput | test_plan_executionsWhereInput[]
    OR?: test_plan_executionsWhereInput[]
    NOT?: test_plan_executionsWhereInput | test_plan_executionsWhereInput[]
    plan_id?: IntFilter<"test_plan_executions"> | number
    plan_name?: StringFilter<"test_plan_executions"> | string
    executor_id?: IntFilter<"test_plan_executions"> | number
    executor_name?: StringFilter<"test_plan_executions"> | string
    execution_type?: StringFilter<"test_plan_executions"> | string
    status?: StringFilter<"test_plan_executions"> | string
    progress?: IntFilter<"test_plan_executions"> | number
    total_cases?: IntFilter<"test_plan_executions"> | number
    completed_cases?: IntFilter<"test_plan_executions"> | number
    passed_cases?: IntFilter<"test_plan_executions"> | number
    failed_cases?: IntFilter<"test_plan_executions"> | number
    blocked_cases?: IntFilter<"test_plan_executions"> | number
    skipped_cases?: IntFilter<"test_plan_executions"> | number
    started_at?: DateTimeFilter<"test_plan_executions"> | Date | string
    finished_at?: DateTimeNullableFilter<"test_plan_executions"> | Date | string | null
    duration_ms?: IntNullableFilter<"test_plan_executions"> | number | null
    execution_results?: JsonNullableFilter<"test_plan_executions">
    error_message?: StringNullableFilter<"test_plan_executions"> | string | null
    metadata?: JsonNullableFilter<"test_plan_executions">
    plan?: XOR<Test_plansScalarRelationFilter, test_plansWhereInput>
  }, "id">

  export type test_plan_executionsOrderByWithAggregationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    plan_name?: SortOrder
    executor_id?: SortOrder
    executor_name?: SortOrder
    execution_type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    total_cases?: SortOrder
    completed_cases?: SortOrder
    passed_cases?: SortOrder
    failed_cases?: SortOrder
    blocked_cases?: SortOrder
    skipped_cases?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrderInput | SortOrder
    duration_ms?: SortOrderInput | SortOrder
    execution_results?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: test_plan_executionsCountOrderByAggregateInput
    _avg?: test_plan_executionsAvgOrderByAggregateInput
    _max?: test_plan_executionsMaxOrderByAggregateInput
    _min?: test_plan_executionsMinOrderByAggregateInput
    _sum?: test_plan_executionsSumOrderByAggregateInput
  }

  export type test_plan_executionsScalarWhereWithAggregatesInput = {
    AND?: test_plan_executionsScalarWhereWithAggregatesInput | test_plan_executionsScalarWhereWithAggregatesInput[]
    OR?: test_plan_executionsScalarWhereWithAggregatesInput[]
    NOT?: test_plan_executionsScalarWhereWithAggregatesInput | test_plan_executionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"test_plan_executions"> | string
    plan_id?: IntWithAggregatesFilter<"test_plan_executions"> | number
    plan_name?: StringWithAggregatesFilter<"test_plan_executions"> | string
    executor_id?: IntWithAggregatesFilter<"test_plan_executions"> | number
    executor_name?: StringWithAggregatesFilter<"test_plan_executions"> | string
    execution_type?: StringWithAggregatesFilter<"test_plan_executions"> | string
    status?: StringWithAggregatesFilter<"test_plan_executions"> | string
    progress?: IntWithAggregatesFilter<"test_plan_executions"> | number
    total_cases?: IntWithAggregatesFilter<"test_plan_executions"> | number
    completed_cases?: IntWithAggregatesFilter<"test_plan_executions"> | number
    passed_cases?: IntWithAggregatesFilter<"test_plan_executions"> | number
    failed_cases?: IntWithAggregatesFilter<"test_plan_executions"> | number
    blocked_cases?: IntWithAggregatesFilter<"test_plan_executions"> | number
    skipped_cases?: IntWithAggregatesFilter<"test_plan_executions"> | number
    started_at?: DateTimeWithAggregatesFilter<"test_plan_executions"> | Date | string
    finished_at?: DateTimeNullableWithAggregatesFilter<"test_plan_executions"> | Date | string | null
    duration_ms?: IntNullableWithAggregatesFilter<"test_plan_executions"> | number | null
    execution_results?: JsonNullableWithAggregatesFilter<"test_plan_executions">
    error_message?: StringNullableWithAggregatesFilter<"test_plan_executions"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"test_plan_executions">
  }

  export type ai_element_cacheWhereInput = {
    AND?: ai_element_cacheWhereInput | ai_element_cacheWhereInput[]
    OR?: ai_element_cacheWhereInput[]
    NOT?: ai_element_cacheWhereInput | ai_element_cacheWhereInput[]
    id?: IntFilter<"ai_element_cache"> | number
    cache_key?: StringFilter<"ai_element_cache"> | string
    url?: StringFilter<"ai_element_cache"> | string
    selector?: StringFilter<"ai_element_cache"> | string
    snapshot_fp?: StringFilter<"ai_element_cache"> | string
    element_ref?: StringFilter<"ai_element_cache"> | string
    element_text?: StringFilter<"ai_element_cache"> | string
    confidence?: IntFilter<"ai_element_cache"> | number
    hit_count?: IntFilter<"ai_element_cache"> | number
    last_hit_at?: DateTimeNullableFilter<"ai_element_cache"> | Date | string | null
    created_at?: DateTimeFilter<"ai_element_cache"> | Date | string
    expires_at?: DateTimeFilter<"ai_element_cache"> | Date | string
  }

  export type ai_element_cacheOrderByWithRelationInput = {
    id?: SortOrder
    cache_key?: SortOrder
    url?: SortOrder
    selector?: SortOrder
    snapshot_fp?: SortOrder
    element_ref?: SortOrder
    element_text?: SortOrder
    confidence?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    _relevance?: ai_element_cacheOrderByRelevanceInput
  }

  export type ai_element_cacheWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cache_key?: string
    AND?: ai_element_cacheWhereInput | ai_element_cacheWhereInput[]
    OR?: ai_element_cacheWhereInput[]
    NOT?: ai_element_cacheWhereInput | ai_element_cacheWhereInput[]
    url?: StringFilter<"ai_element_cache"> | string
    selector?: StringFilter<"ai_element_cache"> | string
    snapshot_fp?: StringFilter<"ai_element_cache"> | string
    element_ref?: StringFilter<"ai_element_cache"> | string
    element_text?: StringFilter<"ai_element_cache"> | string
    confidence?: IntFilter<"ai_element_cache"> | number
    hit_count?: IntFilter<"ai_element_cache"> | number
    last_hit_at?: DateTimeNullableFilter<"ai_element_cache"> | Date | string | null
    created_at?: DateTimeFilter<"ai_element_cache"> | Date | string
    expires_at?: DateTimeFilter<"ai_element_cache"> | Date | string
  }, "id" | "cache_key">

  export type ai_element_cacheOrderByWithAggregationInput = {
    id?: SortOrder
    cache_key?: SortOrder
    url?: SortOrder
    selector?: SortOrder
    snapshot_fp?: SortOrder
    element_ref?: SortOrder
    element_text?: SortOrder
    confidence?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    _count?: ai_element_cacheCountOrderByAggregateInput
    _avg?: ai_element_cacheAvgOrderByAggregateInput
    _max?: ai_element_cacheMaxOrderByAggregateInput
    _min?: ai_element_cacheMinOrderByAggregateInput
    _sum?: ai_element_cacheSumOrderByAggregateInput
  }

  export type ai_element_cacheScalarWhereWithAggregatesInput = {
    AND?: ai_element_cacheScalarWhereWithAggregatesInput | ai_element_cacheScalarWhereWithAggregatesInput[]
    OR?: ai_element_cacheScalarWhereWithAggregatesInput[]
    NOT?: ai_element_cacheScalarWhereWithAggregatesInput | ai_element_cacheScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_element_cache"> | number
    cache_key?: StringWithAggregatesFilter<"ai_element_cache"> | string
    url?: StringWithAggregatesFilter<"ai_element_cache"> | string
    selector?: StringWithAggregatesFilter<"ai_element_cache"> | string
    snapshot_fp?: StringWithAggregatesFilter<"ai_element_cache"> | string
    element_ref?: StringWithAggregatesFilter<"ai_element_cache"> | string
    element_text?: StringWithAggregatesFilter<"ai_element_cache"> | string
    confidence?: IntWithAggregatesFilter<"ai_element_cache"> | number
    hit_count?: IntWithAggregatesFilter<"ai_element_cache"> | number
    last_hit_at?: DateTimeNullableWithAggregatesFilter<"ai_element_cache"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"ai_element_cache"> | Date | string
    expires_at?: DateTimeWithAggregatesFilter<"ai_element_cache"> | Date | string
  }

  export type ai_assertion_cacheWhereInput = {
    AND?: ai_assertion_cacheWhereInput | ai_assertion_cacheWhereInput[]
    OR?: ai_assertion_cacheWhereInput[]
    NOT?: ai_assertion_cacheWhereInput | ai_assertion_cacheWhereInput[]
    id?: IntFilter<"ai_assertion_cache"> | number
    cache_key?: StringFilter<"ai_assertion_cache"> | string
    assertion_desc?: StringFilter<"ai_assertion_cache"> | string
    page_elements_fp?: StringFilter<"ai_assertion_cache"> | string
    command_name?: StringFilter<"ai_assertion_cache"> | string
    command_args?: JsonNullableFilter<"ai_assertion_cache">
    assertion_info?: JsonNullableFilter<"ai_assertion_cache">
    hit_count?: IntFilter<"ai_assertion_cache"> | number
    last_hit_at?: DateTimeNullableFilter<"ai_assertion_cache"> | Date | string | null
    created_at?: DateTimeFilter<"ai_assertion_cache"> | Date | string
    expires_at?: DateTimeFilter<"ai_assertion_cache"> | Date | string
  }

  export type ai_assertion_cacheOrderByWithRelationInput = {
    id?: SortOrder
    cache_key?: SortOrder
    assertion_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    command_args?: SortOrderInput | SortOrder
    assertion_info?: SortOrderInput | SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    _relevance?: ai_assertion_cacheOrderByRelevanceInput
  }

  export type ai_assertion_cacheWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cache_key?: string
    AND?: ai_assertion_cacheWhereInput | ai_assertion_cacheWhereInput[]
    OR?: ai_assertion_cacheWhereInput[]
    NOT?: ai_assertion_cacheWhereInput | ai_assertion_cacheWhereInput[]
    assertion_desc?: StringFilter<"ai_assertion_cache"> | string
    page_elements_fp?: StringFilter<"ai_assertion_cache"> | string
    command_name?: StringFilter<"ai_assertion_cache"> | string
    command_args?: JsonNullableFilter<"ai_assertion_cache">
    assertion_info?: JsonNullableFilter<"ai_assertion_cache">
    hit_count?: IntFilter<"ai_assertion_cache"> | number
    last_hit_at?: DateTimeNullableFilter<"ai_assertion_cache"> | Date | string | null
    created_at?: DateTimeFilter<"ai_assertion_cache"> | Date | string
    expires_at?: DateTimeFilter<"ai_assertion_cache"> | Date | string
  }, "id" | "cache_key">

  export type ai_assertion_cacheOrderByWithAggregationInput = {
    id?: SortOrder
    cache_key?: SortOrder
    assertion_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    command_args?: SortOrderInput | SortOrder
    assertion_info?: SortOrderInput | SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    _count?: ai_assertion_cacheCountOrderByAggregateInput
    _avg?: ai_assertion_cacheAvgOrderByAggregateInput
    _max?: ai_assertion_cacheMaxOrderByAggregateInput
    _min?: ai_assertion_cacheMinOrderByAggregateInput
    _sum?: ai_assertion_cacheSumOrderByAggregateInput
  }

  export type ai_assertion_cacheScalarWhereWithAggregatesInput = {
    AND?: ai_assertion_cacheScalarWhereWithAggregatesInput | ai_assertion_cacheScalarWhereWithAggregatesInput[]
    OR?: ai_assertion_cacheScalarWhereWithAggregatesInput[]
    NOT?: ai_assertion_cacheScalarWhereWithAggregatesInput | ai_assertion_cacheScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_assertion_cache"> | number
    cache_key?: StringWithAggregatesFilter<"ai_assertion_cache"> | string
    assertion_desc?: StringWithAggregatesFilter<"ai_assertion_cache"> | string
    page_elements_fp?: StringWithAggregatesFilter<"ai_assertion_cache"> | string
    command_name?: StringWithAggregatesFilter<"ai_assertion_cache"> | string
    command_args?: JsonNullableWithAggregatesFilter<"ai_assertion_cache">
    assertion_info?: JsonNullableWithAggregatesFilter<"ai_assertion_cache">
    hit_count?: IntWithAggregatesFilter<"ai_assertion_cache"> | number
    last_hit_at?: DateTimeNullableWithAggregatesFilter<"ai_assertion_cache"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"ai_assertion_cache"> | Date | string
    expires_at?: DateTimeWithAggregatesFilter<"ai_assertion_cache"> | Date | string
  }

  export type ai_operation_cacheWhereInput = {
    AND?: ai_operation_cacheWhereInput | ai_operation_cacheWhereInput[]
    OR?: ai_operation_cacheWhereInput[]
    NOT?: ai_operation_cacheWhereInput | ai_operation_cacheWhereInput[]
    id?: IntFilter<"ai_operation_cache"> | number
    cache_key?: StringFilter<"ai_operation_cache"> | string
    operation_desc?: StringFilter<"ai_operation_cache"> | string
    page_elements_fp?: StringFilter<"ai_operation_cache"> | string
    command_name?: StringFilter<"ai_operation_cache"> | string
    command_args?: JsonNullableFilter<"ai_operation_cache">
    hit_count?: IntFilter<"ai_operation_cache"> | number
    last_hit_at?: DateTimeNullableFilter<"ai_operation_cache"> | Date | string | null
    created_at?: DateTimeFilter<"ai_operation_cache"> | Date | string
    expires_at?: DateTimeFilter<"ai_operation_cache"> | Date | string
  }

  export type ai_operation_cacheOrderByWithRelationInput = {
    id?: SortOrder
    cache_key?: SortOrder
    operation_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    command_args?: SortOrderInput | SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    _relevance?: ai_operation_cacheOrderByRelevanceInput
  }

  export type ai_operation_cacheWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cache_key?: string
    AND?: ai_operation_cacheWhereInput | ai_operation_cacheWhereInput[]
    OR?: ai_operation_cacheWhereInput[]
    NOT?: ai_operation_cacheWhereInput | ai_operation_cacheWhereInput[]
    operation_desc?: StringFilter<"ai_operation_cache"> | string
    page_elements_fp?: StringFilter<"ai_operation_cache"> | string
    command_name?: StringFilter<"ai_operation_cache"> | string
    command_args?: JsonNullableFilter<"ai_operation_cache">
    hit_count?: IntFilter<"ai_operation_cache"> | number
    last_hit_at?: DateTimeNullableFilter<"ai_operation_cache"> | Date | string | null
    created_at?: DateTimeFilter<"ai_operation_cache"> | Date | string
    expires_at?: DateTimeFilter<"ai_operation_cache"> | Date | string
  }, "id" | "cache_key">

  export type ai_operation_cacheOrderByWithAggregationInput = {
    id?: SortOrder
    cache_key?: SortOrder
    operation_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    command_args?: SortOrderInput | SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    _count?: ai_operation_cacheCountOrderByAggregateInput
    _avg?: ai_operation_cacheAvgOrderByAggregateInput
    _max?: ai_operation_cacheMaxOrderByAggregateInput
    _min?: ai_operation_cacheMinOrderByAggregateInput
    _sum?: ai_operation_cacheSumOrderByAggregateInput
  }

  export type ai_operation_cacheScalarWhereWithAggregatesInput = {
    AND?: ai_operation_cacheScalarWhereWithAggregatesInput | ai_operation_cacheScalarWhereWithAggregatesInput[]
    OR?: ai_operation_cacheScalarWhereWithAggregatesInput[]
    NOT?: ai_operation_cacheScalarWhereWithAggregatesInput | ai_operation_cacheScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_operation_cache"> | number
    cache_key?: StringWithAggregatesFilter<"ai_operation_cache"> | string
    operation_desc?: StringWithAggregatesFilter<"ai_operation_cache"> | string
    page_elements_fp?: StringWithAggregatesFilter<"ai_operation_cache"> | string
    command_name?: StringWithAggregatesFilter<"ai_operation_cache"> | string
    command_args?: JsonNullableWithAggregatesFilter<"ai_operation_cache">
    hit_count?: IntWithAggregatesFilter<"ai_operation_cache"> | number
    last_hit_at?: DateTimeNullableWithAggregatesFilter<"ai_operation_cache"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"ai_operation_cache"> | Date | string
    expires_at?: DateTimeWithAggregatesFilter<"ai_operation_cache"> | Date | string
  }

  export type ai_promptsCreateInput = {
    name: string
    version: number
    template: string
    created_at?: Date | string | null
    ai_runs?: ai_runsCreateNestedManyWithoutAi_promptsInput
  }

  export type ai_promptsUncheckedCreateInput = {
    id?: number
    name: string
    version: number
    template: string
    created_at?: Date | string | null
    ai_runs?: ai_runsUncheckedCreateNestedManyWithoutAi_promptsInput
  }

  export type ai_promptsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    template?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUpdateManyWithoutAi_promptsNestedInput
  }

  export type ai_promptsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    template?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUncheckedUpdateManyWithoutAi_promptsNestedInput
  }

  export type ai_promptsCreateManyInput = {
    id?: number
    name: string
    version: number
    template: string
    created_at?: Date | string | null
  }

  export type ai_promptsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    template?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_promptsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    template?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_runsCreateInput = {
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
    ai_prompts: ai_promptsCreateNestedOneWithoutAi_runsInput
    test_runs?: test_runsCreateNestedOneWithoutAi_runsInput
  }

  export type ai_runsUncheckedCreateInput = {
    id?: number
    prompt_id: number
    run_id?: number | null
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
  }

  export type ai_runsUpdateInput = {
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_prompts?: ai_promptsUpdateOneRequiredWithoutAi_runsNestedInput
    test_runs?: test_runsUpdateOneWithoutAi_runsNestedInput
  }

  export type ai_runsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt_id?: IntFieldUpdateOperationsInput | number
    run_id?: NullableIntFieldUpdateOperationsInput | number | null
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_runsCreateManyInput = {
    id?: number
    prompt_id: number
    run_id?: number | null
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
  }

  export type ai_runsUpdateManyMutationInput = {
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_runsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt_id?: IntFieldUpdateOperationsInput | number
    run_id?: NullableIntFieldUpdateOperationsInput | number | null
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type api_tokensCreateInput = {
    token_hash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    created_at?: Date | string | null
    users: usersCreateNestedOneWithoutApi_tokensInput
  }

  export type api_tokensUncheckedCreateInput = {
    id?: number
    user_id: number
    token_hash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type api_tokensUpdateInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutApi_tokensNestedInput
  }

  export type api_tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type api_tokensCreateManyInput = {
    id?: number
    user_id: number
    token_hash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type api_tokensUpdateManyMutationInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type api_tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attachmentsCreateInput = {
    file_key: string
    mime_type?: string | null
    size_bytes?: bigint | number | null
    created_at?: Date | string | null
    test_run_results: test_run_resultsCreateNestedOneWithoutAttachmentsInput
  }

  export type attachmentsUncheckedCreateInput = {
    id?: number
    run_result_id: number
    file_key: string
    mime_type?: string | null
    size_bytes?: bigint | number | null
    created_at?: Date | string | null
  }

  export type attachmentsUpdateInput = {
    file_key?: StringFieldUpdateOperationsInput | string
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_run_results?: test_run_resultsUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type attachmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_result_id?: IntFieldUpdateOperationsInput | number
    file_key?: StringFieldUpdateOperationsInput | string
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attachmentsCreateManyInput = {
    id?: number
    run_result_id: number
    file_key: string
    mime_type?: string | null
    size_bytes?: bigint | number | null
    created_at?: Date | string | null
  }

  export type attachmentsUpdateManyMutationInput = {
    file_key?: StringFieldUpdateOperationsInput | string
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attachmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_result_id?: IntFieldUpdateOperationsInput | number
    file_key?: StringFieldUpdateOperationsInput | string
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logsCreateInput = {
    id?: bigint | number
    action: string
    target_type?: string | null
    target_id?: bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    users?: usersCreateNestedOneWithoutAudit_logsInput
  }

  export type audit_logsUncheckedCreateInput = {
    id?: bigint | number
    user_id?: number | null
    action: string
    target_type?: string | null
    target_id?: bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type audit_logsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutAudit_logsNestedInput
  }

  export type audit_logsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logsCreateManyInput = {
    id?: bigint | number
    user_id?: number | null
    action: string
    target_type?: string | null
    target_id?: bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type audit_logsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feature_flagsCreateInput = {
    flag_name: string
    is_enabled?: boolean | null
    rollout_percentage?: number | null
    updated_at?: Date | string | null
  }

  export type feature_flagsUncheckedCreateInput = {
    flag_name: string
    is_enabled?: boolean | null
    rollout_percentage?: number | null
    updated_at?: Date | string | null
  }

  export type feature_flagsUpdateInput = {
    flag_name?: StringFieldUpdateOperationsInput | string
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rollout_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feature_flagsUncheckedUpdateInput = {
    flag_name?: StringFieldUpdateOperationsInput | string
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rollout_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feature_flagsCreateManyInput = {
    flag_name: string
    is_enabled?: boolean | null
    rollout_percentage?: number | null
    updated_at?: Date | string | null
  }

  export type feature_flagsUpdateManyMutationInput = {
    flag_name?: StringFieldUpdateOperationsInput | string
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rollout_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feature_flagsUncheckedUpdateManyInput = {
    flag_name?: StringFieldUpdateOperationsInput | string
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rollout_percentage?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type job_logsCreateInput = {
    id?: bigint | number
    job_name: string
    status: $Enums.job_logs_status
    message?: string | null
    started_at?: Date | string | null
    ended_at?: Date | string | null
  }

  export type job_logsUncheckedCreateInput = {
    id?: bigint | number
    job_name: string
    status: $Enums.job_logs_status
    message?: string | null
    started_at?: Date | string | null
    ended_at?: Date | string | null
  }

  export type job_logsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    job_name?: StringFieldUpdateOperationsInput | string
    status?: Enumjob_logs_statusFieldUpdateOperationsInput | $Enums.job_logs_status
    message?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type job_logsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    job_name?: StringFieldUpdateOperationsInput | string
    status?: Enumjob_logs_statusFieldUpdateOperationsInput | $Enums.job_logs_status
    message?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type job_logsCreateManyInput = {
    id?: bigint | number
    job_name: string
    status: $Enums.job_logs_status
    message?: string | null
    started_at?: Date | string | null
    ended_at?: Date | string | null
  }

  export type job_logsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    job_name?: StringFieldUpdateOperationsInput | string
    status?: Enumjob_logs_statusFieldUpdateOperationsInput | $Enums.job_logs_status
    message?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type job_logsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    job_name?: StringFieldUpdateOperationsInput | string
    status?: Enumjob_logs_statusFieldUpdateOperationsInput | $Enums.job_logs_status
    message?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type metrics_dailyCreateInput = {
    metric_date: Date | string
    suite_id: number
    pass_rate?: Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: number | null
  }

  export type metrics_dailyUncheckedCreateInput = {
    metric_date: Date | string
    suite_id: number
    pass_rate?: Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: number | null
  }

  export type metrics_dailyUpdateInput = {
    metric_date?: DateTimeFieldUpdateOperationsInput | Date | string
    suite_id?: IntFieldUpdateOperationsInput | number
    pass_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type metrics_dailyUncheckedUpdateInput = {
    metric_date?: DateTimeFieldUpdateOperationsInput | Date | string
    suite_id?: IntFieldUpdateOperationsInput | number
    pass_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type metrics_dailyCreateManyInput = {
    metric_date: Date | string
    suite_id: number
    pass_rate?: Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: number | null
  }

  export type metrics_dailyUpdateManyMutationInput = {
    metric_date?: DateTimeFieldUpdateOperationsInput | Date | string
    suite_id?: IntFieldUpdateOperationsInput | number
    pass_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type metrics_dailyUncheckedUpdateManyInput = {
    metric_date?: DateTimeFieldUpdateOperationsInput | Date | string
    suite_id?: IntFieldUpdateOperationsInput | number
    pass_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    avg_duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportsCreateInput = {
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: Date | string | null
    test_runs: test_runsCreateNestedOneWithoutReportsInput
  }

  export type reportsUncheckedCreateInput = {
    id?: number
    run_id: number
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: Date | string | null
  }

  export type reportsUpdateInput = {
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_runs?: test_runsUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: IntFieldUpdateOperationsInput | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportsCreateManyInput = {
    id?: number
    run_id: number
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: Date | string | null
  }

  export type reportsUpdateManyMutationInput = {
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: IntFieldUpdateOperationsInput | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesCreateInput = {
    name: string
    user_roles?: user_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    name: string
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    user_roles?: user_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    user_roles?: user_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    name: string
  }

  export type rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type settingsCreateInput = {
    key: string
    value?: string | null
    updated_at?: Date | string | null
  }

  export type settingsUncheckedCreateInput = {
    key: string
    value?: string | null
    updated_at?: Date | string | null
  }

  export type settingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settingsUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settingsCreateManyInput = {
    key: string
    value?: string | null
    updated_at?: Date | string | null
  }

  export type settingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settingsUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type step_screenshotsCreateInput = {
    run_id: string
    step_index: string
    step_description?: string | null
    status: $Enums.step_screenshots_status
    file_path: string
    file_name: string
    file_size?: bigint | number | null
    mime_type?: string | null
    created_at?: Date | string | null
    file_exists?: boolean
    test_cases?: test_casesCreateNestedOneWithoutStep_screenshotsInput
  }

  export type step_screenshotsUncheckedCreateInput = {
    id?: number
    run_id: string
    test_case_id?: number | null
    step_index: string
    step_description?: string | null
    status: $Enums.step_screenshots_status
    file_path: string
    file_name: string
    file_size?: bigint | number | null
    mime_type?: string | null
    created_at?: Date | string | null
    file_exists?: boolean
  }

  export type step_screenshotsUpdateInput = {
    run_id?: StringFieldUpdateOperationsInput | string
    step_index?: StringFieldUpdateOperationsInput | string
    step_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumstep_screenshots_statusFieldUpdateOperationsInput | $Enums.step_screenshots_status
    file_path?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_exists?: BoolFieldUpdateOperationsInput | boolean
    test_cases?: test_casesUpdateOneWithoutStep_screenshotsNestedInput
  }

  export type step_screenshotsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: StringFieldUpdateOperationsInput | string
    test_case_id?: NullableIntFieldUpdateOperationsInput | number | null
    step_index?: StringFieldUpdateOperationsInput | string
    step_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumstep_screenshots_statusFieldUpdateOperationsInput | $Enums.step_screenshots_status
    file_path?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_exists?: BoolFieldUpdateOperationsInput | boolean
  }

  export type step_screenshotsCreateManyInput = {
    id?: number
    run_id: string
    test_case_id?: number | null
    step_index: string
    step_description?: string | null
    status: $Enums.step_screenshots_status
    file_path: string
    file_name: string
    file_size?: bigint | number | null
    mime_type?: string | null
    created_at?: Date | string | null
    file_exists?: boolean
  }

  export type step_screenshotsUpdateManyMutationInput = {
    run_id?: StringFieldUpdateOperationsInput | string
    step_index?: StringFieldUpdateOperationsInput | string
    step_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumstep_screenshots_statusFieldUpdateOperationsInput | $Enums.step_screenshots_status
    file_path?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_exists?: BoolFieldUpdateOperationsInput | boolean
  }

  export type step_screenshotsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: StringFieldUpdateOperationsInput | string
    test_case_id?: NullableIntFieldUpdateOperationsInput | number | null
    step_index?: StringFieldUpdateOperationsInput | string
    step_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumstep_screenshots_statusFieldUpdateOperationsInput | $Enums.step_screenshots_status
    file_path?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_exists?: BoolFieldUpdateOperationsInput | boolean
  }

  export type suite_case_mapCreateInput = {
    test_suites: test_suitesCreateNestedOneWithoutSuite_case_mapInput
    test_cases: test_casesCreateNestedOneWithoutSuite_case_mapInput
  }

  export type suite_case_mapUncheckedCreateInput = {
    suite_id: number
    case_id: number
  }

  export type suite_case_mapUpdateInput = {
    test_suites?: test_suitesUpdateOneRequiredWithoutSuite_case_mapNestedInput
    test_cases?: test_casesUpdateOneRequiredWithoutSuite_case_mapNestedInput
  }

  export type suite_case_mapUncheckedUpdateInput = {
    suite_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
  }

  export type suite_case_mapCreateManyInput = {
    suite_id: number
    case_id: number
  }

  export type suite_case_mapUpdateManyMutationInput = {

  }

  export type suite_case_mapUncheckedUpdateManyInput = {
    suite_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
  }

  export type test_casesCreateInput = {
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesUncheckedCreateInput = {
    id?: number
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsUncheckedCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_casesNestedInput
  }

  export type test_casesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUncheckedUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_casesNestedInput
  }

  export type test_casesCreateManyInput = {
    id?: number
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type test_casesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_casesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_run_resultsCreateInput = {
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
    attachments?: attachmentsCreateNestedManyWithoutTest_run_resultsInput
    test_runs: test_runsCreateNestedOneWithoutTest_run_resultsInput
    test_cases: test_casesCreateNestedOneWithoutTest_run_resultsInput
  }

  export type test_run_resultsUncheckedCreateInput = {
    id?: number
    run_id: number
    case_id: number
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
    attachments?: attachmentsUncheckedCreateNestedManyWithoutTest_run_resultsInput
  }

  export type test_run_resultsUpdateInput = {
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: attachmentsUpdateManyWithoutTest_run_resultsNestedInput
    test_runs?: test_runsUpdateOneRequiredWithoutTest_run_resultsNestedInput
    test_cases?: test_casesUpdateOneRequiredWithoutTest_run_resultsNestedInput
  }

  export type test_run_resultsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: attachmentsUncheckedUpdateManyWithoutTest_run_resultsNestedInput
  }

  export type test_run_resultsCreateManyInput = {
    id?: number
    run_id: number
    case_id: number
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
  }

  export type test_run_resultsUpdateManyMutationInput = {
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_run_resultsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_runsCreateInput = {
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsCreateNestedManyWithoutTest_runsInput
    reports?: reportsCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_runsInput
    test_suites: test_suitesCreateNestedOneWithoutTest_runsInput
    users: usersCreateNestedOneWithoutTest_runsInput
  }

  export type test_runsUncheckedCreateInput = {
    id?: number
    suite_id: number
    trigger_user_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsUncheckedCreateNestedManyWithoutTest_runsInput
    reports?: reportsUncheckedCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_runsInput
  }

  export type test_runsUpdateInput = {
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUpdateManyWithoutTest_runsNestedInput
    reports?: reportsUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_runsNestedInput
    test_suites?: test_suitesUpdateOneRequiredWithoutTest_runsNestedInput
    users?: usersUpdateOneRequiredWithoutTest_runsNestedInput
  }

  export type test_runsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    suite_id?: IntFieldUpdateOperationsInput | number
    trigger_user_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUncheckedUpdateManyWithoutTest_runsNestedInput
    reports?: reportsUncheckedUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_runsNestedInput
  }

  export type test_runsCreateManyInput = {
    id?: number
    suite_id: number
    trigger_user_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
  }

  export type test_runsUpdateManyMutationInput = {
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_runsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    suite_id?: IntFieldUpdateOperationsInput | number
    trigger_user_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_suitesCreateInput = {
    name: string
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_suitesInput
    test_runs?: test_runsCreateNestedManyWithoutTest_suitesInput
    users: usersCreateNestedOneWithoutTest_suitesInput
  }

  export type test_suitesUncheckedCreateInput = {
    id?: number
    name: string
    owner_id: number
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_suitesInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutTest_suitesInput
  }

  export type test_suitesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_suitesNestedInput
    test_runs?: test_runsUpdateManyWithoutTest_suitesNestedInput
    users?: usersUpdateOneRequiredWithoutTest_suitesNestedInput
  }

  export type test_suitesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    owner_id?: IntFieldUpdateOperationsInput | number
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_suitesNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutTest_suitesNestedInput
  }

  export type test_suitesCreateManyInput = {
    id?: number
    name: string
    owner_id: number
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type test_suitesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_suitesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    owner_id?: IntFieldUpdateOperationsInput | number
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_rolesCreateInput = {
    users: usersCreateNestedOneWithoutUser_rolesInput
    roles: rolesCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateInput = {
    user_id: number
    role_id: number
  }

  export type user_rolesUpdateInput = {
    users?: usersUpdateOneRequiredWithoutUser_rolesNestedInput
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesCreateManyInput = {
    user_id: number
    role_id: number
  }

  export type user_rolesUpdateManyMutationInput = {

  }

  export type user_rolesUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type run_artifactsCreateInput = {
    runId: string
    type: string
    filename: string
    size: bigint | number
    createdAt?: Date | string
  }

  export type run_artifactsUncheckedCreateInput = {
    id?: number
    runId: string
    type: string
    filename: string
    size: bigint | number
    createdAt?: Date | string
  }

  export type run_artifactsUpdateInput = {
    runId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type run_artifactsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    runId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type run_artifactsCreateManyInput = {
    id?: number
    runId: string
    type: string
    filename: string
    size: bigint | number
    createdAt?: Date | string
  }

  export type run_artifactsUpdateManyMutationInput = {
    runId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type run_artifactsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    runId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type case_versionsCreateInput = {
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    test_cases: test_casesCreateNestedOneWithoutCase_versionsInput
    users?: usersCreateNestedOneWithoutCase_versionsInput
  }

  export type case_versionsUncheckedCreateInput = {
    id?: number
    case_id: number
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_by?: number | null
    created_at?: Date | string | null
  }

  export type case_versionsUpdateInput = {
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_cases?: test_casesUpdateOneRequiredWithoutCase_versionsNestedInput
    users?: usersUpdateOneWithoutCase_versionsNestedInput
  }

  export type case_versionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_versionsCreateManyInput = {
    id?: number
    case_id: number
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_by?: number | null
    created_at?: Date | string | null
  }

  export type case_versionsUpdateManyMutationInput = {
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_versionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bulk_edit_sessionsCreateInput = {
    system: string
    module: string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: string | null
    change_brief: string
    status?: $Enums.bulk_edit_sessions_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
    users: usersCreateNestedOneWithoutBulk_edit_sessionsInput
    proposals?: case_patch_proposalsCreateNestedManyWithoutSessionInput
  }

  export type bulk_edit_sessionsUncheckedCreateInput = {
    id?: number
    system: string
    module: string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: string | null
    change_brief: string
    status?: $Enums.bulk_edit_sessions_status
    created_by: number
    created_at?: Date | string | null
    applied_at?: Date | string | null
    proposals?: case_patch_proposalsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type bulk_edit_sessionsUpdateInput = {
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutBulk_edit_sessionsNestedInput
    proposals?: case_patch_proposalsUpdateManyWithoutSessionNestedInput
  }

  export type bulk_edit_sessionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_by?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposals?: case_patch_proposalsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type bulk_edit_sessionsCreateManyInput = {
    id?: number
    system: string
    module: string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: string | null
    change_brief: string
    status?: $Enums.bulk_edit_sessions_status
    created_by: number
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type bulk_edit_sessionsUpdateManyMutationInput = {
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bulk_edit_sessionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_by?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_patch_proposalsCreateInput = {
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
    test_cases: test_casesCreateNestedOneWithoutPatch_proposalsInput
    session: bulk_edit_sessionsCreateNestedOneWithoutProposalsInput
  }

  export type case_patch_proposalsUncheckedCreateInput = {
    id?: number
    session_id: number
    case_id: number
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type case_patch_proposalsUpdateInput = {
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_cases?: test_casesUpdateOneRequiredWithoutPatch_proposalsNestedInput
    session?: bulk_edit_sessionsUpdateOneRequiredWithoutProposalsNestedInput
  }

  export type case_patch_proposalsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_patch_proposalsCreateManyInput = {
    id?: number
    session_id: number
    case_id: number
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type case_patch_proposalsUpdateManyMutationInput = {
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_patch_proposalsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_case_executionsCreateInput = {
    id: string
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    users?: usersCreateNestedOneWithoutTest_case_executionsInput
    test_cases: test_casesCreateNestedOneWithoutTest_case_executionsInput
  }

  export type test_case_executionsUncheckedCreateInput = {
    id: string
    test_case_id: number
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_user_id?: number | null
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_case_executionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUpdateOneWithoutTest_case_executionsNestedInput
    test_cases?: test_casesUpdateOneRequiredWithoutTest_case_executionsNestedInput
  }

  export type test_case_executionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_id?: IntFieldUpdateOperationsInput | number
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_case_executionsCreateManyInput = {
    id: string
    test_case_id: number
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_user_id?: number | null
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_case_executionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_case_executionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_id?: IntFieldUpdateOperationsInput | number
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_casesCreateInput = {
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    deleted_at?: Date | string | null
    users: usersCreateNestedOneWithoutFunctional_test_casesInput
    project_version?: project_versionsCreateNestedOneWithoutFunctional_test_casesInput
    requirement_doc?: requirement_documentsCreateNestedOneWithoutTest_casesInput
    executions?: functional_test_executionsCreateNestedManyWithoutTest_caseInput
  }

  export type functional_test_casesUncheckedCreateInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    creator_id: number
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    project_version_id?: number | null
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    requirement_doc_id?: number | null
    deleted_at?: Date | string | null
    executions?: functional_test_executionsUncheckedCreateNestedManyWithoutTest_caseInput
  }

  export type functional_test_casesUpdateInput = {
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutFunctional_test_casesNestedInput
    project_version?: project_versionsUpdateOneWithoutFunctional_test_casesNestedInput
    requirement_doc?: requirement_documentsUpdateOneWithoutTest_casesNestedInput
    executions?: functional_test_executionsUpdateManyWithoutTest_caseNestedInput
  }

  export type functional_test_casesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: functional_test_executionsUncheckedUpdateManyWithoutTest_caseNestedInput
  }

  export type functional_test_casesCreateManyInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    creator_id: number
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    project_version_id?: number | null
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    requirement_doc_id?: number | null
    deleted_at?: Date | string | null
  }

  export type functional_test_casesUpdateManyMutationInput = {
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type functional_test_casesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_generation_sessionsCreateInput = {
    id: string
    axure_filename: string
    axure_file_size: number
    project_name?: string | null
    system_type?: string | null
    business_domain?: string | null
    requirement_doc?: string | null
    page_count?: number
    element_count?: number
    interaction_count?: number
    total_generated?: number
    total_saved?: number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    users: usersCreateNestedOneWithoutAi_generation_sessionsInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutAi_sessionInput
  }

  export type ai_generation_sessionsUncheckedCreateInput = {
    id: string
    user_id: number
    axure_filename: string
    axure_file_size: number
    project_name?: string | null
    system_type?: string | null
    business_domain?: string | null
    requirement_doc?: string | null
    page_count?: number
    element_count?: number
    interaction_count?: number
    total_generated?: number
    total_saved?: number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutAi_sessionInput
  }

  export type ai_generation_sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutAi_generation_sessionsNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutAi_sessionNestedInput
  }

  export type ai_generation_sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutAi_sessionNestedInput
  }

  export type ai_generation_sessionsCreateManyInput = {
    id: string
    user_id: number
    axure_filename: string
    axure_file_size: number
    project_name?: string | null
    system_type?: string | null
    business_domain?: string | null
    requirement_doc?: string | null
    page_count?: number
    element_count?: number
    interaction_count?: number
    total_generated?: number
    total_saved?: number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ai_generation_sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_generation_sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requirement_documentsCreateInput = {
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesCreateNestedManyWithoutRequirement_docInput
    ai_session?: ai_generation_sessionsCreateNestedOneWithoutRequirement_documentsInput
    users: usersCreateNestedOneWithoutRequirement_documentsInput
    project?: systemsCreateNestedOneWithoutRequirement_documentsInput
    project_version?: project_versionsCreateNestedOneWithoutRequirement_documentsInput
  }

  export type requirement_documentsUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_id?: number | null
    project_version_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutRequirement_docInput
  }

  export type requirement_documentsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUpdateManyWithoutRequirement_docNestedInput
    ai_session?: ai_generation_sessionsUpdateOneWithoutRequirement_documentsNestedInput
    users?: usersUpdateOneRequiredWithoutRequirement_documentsNestedInput
    project?: systemsUpdateOneWithoutRequirement_documentsNestedInput
    project_version?: project_versionsUpdateOneWithoutRequirement_documentsNestedInput
  }

  export type requirement_documentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUncheckedUpdateManyWithoutRequirement_docNestedInput
  }

  export type requirement_documentsCreateManyInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_id?: number | null
    project_version_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
  }

  export type requirement_documentsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type requirement_documentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type systemsCreateInput = {
    name: string
    short_name?: string | null
    description?: string | null
    status?: $Enums.system_status
    sort_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    versions?: project_versionsCreateNestedManyWithoutProjectInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutProjectInput
  }

  export type systemsUncheckedCreateInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    status?: $Enums.system_status
    sort_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    versions?: project_versionsUncheckedCreateNestedManyWithoutProjectInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutProjectInput
  }

  export type systemsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    sort_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: project_versionsUpdateManyWithoutProjectNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutProjectNestedInput
  }

  export type systemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    sort_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: project_versionsUncheckedUpdateManyWithoutProjectNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type systemsCreateManyInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    status?: $Enums.system_status
    sort_order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type systemsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    sort_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type systemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    sort_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type project_versionsCreateInput = {
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutProject_versionInput
    project: systemsCreateNestedOneWithoutVersionsInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutProject_versionInput
  }

  export type project_versionsUncheckedCreateInput = {
    id?: number
    project_id: number
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutProject_versionInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutProject_versionInput
  }

  export type project_versionsUpdateInput = {
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    functional_test_cases?: functional_test_casesUpdateManyWithoutProject_versionNestedInput
    project?: systemsUpdateOneRequiredWithoutVersionsNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutProject_versionNestedInput
  }

  export type project_versionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutProject_versionNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutProject_versionNestedInput
  }

  export type project_versionsCreateManyInput = {
    id?: number
    project_id: number
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type project_versionsUpdateManyMutationInput = {
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type project_versionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type functional_test_executionsCreateInput = {
    id?: string
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    test_case: functional_test_casesCreateNestedOneWithoutExecutionsInput
    executor: usersCreateNestedOneWithoutFunctional_test_executionsInput
  }

  export type functional_test_executionsUncheckedCreateInput = {
    id?: string
    test_case_id: number
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_id: number
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    test_case?: functional_test_casesUpdateOneRequiredWithoutExecutionsNestedInput
    executor?: usersUpdateOneRequiredWithoutFunctional_test_executionsNestedInput
  }

  export type functional_test_executionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_id?: IntFieldUpdateOperationsInput | number
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsCreateManyInput = {
    id?: string
    test_case_id: number
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_id: number
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_id?: IntFieldUpdateOperationsInput | number
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plansCreateInput = {
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    owner: usersCreateNestedOneWithoutTest_plansInput
    plan_cases?: test_plan_casesCreateNestedManyWithoutPlanInput
    plan_executions?: test_plan_executionsCreateNestedManyWithoutPlanInput
  }

  export type test_plansUncheckedCreateInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    owner_id: number
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    plan_cases?: test_plan_casesUncheckedCreateNestedManyWithoutPlanInput
    plan_executions?: test_plan_executionsUncheckedCreateNestedManyWithoutPlanInput
  }

  export type test_plansUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: usersUpdateOneRequiredWithoutTest_plansNestedInput
    plan_cases?: test_plan_casesUpdateManyWithoutPlanNestedInput
    plan_executions?: test_plan_executionsUpdateManyWithoutPlanNestedInput
  }

  export type test_plansUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    owner_id?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan_cases?: test_plan_casesUncheckedUpdateManyWithoutPlanNestedInput
    plan_executions?: test_plan_executionsUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type test_plansCreateManyInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    owner_id: number
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type test_plansUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_plansUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    owner_id?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_plan_casesCreateInput = {
    case_id: number
    case_type: string
    case_name: string
    sort_order?: number
    is_executed?: boolean
    execution_result?: string | null
    created_at?: Date | string
    plan: test_plansCreateNestedOneWithoutPlan_casesInput
  }

  export type test_plan_casesUncheckedCreateInput = {
    id?: number
    plan_id: number
    case_id: number
    case_type: string
    case_name: string
    sort_order?: number
    is_executed?: boolean
    execution_result?: string | null
    created_at?: Date | string
  }

  export type test_plan_casesUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    case_type?: StringFieldUpdateOperationsInput | string
    case_name?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    is_executed?: BoolFieldUpdateOperationsInput | boolean
    execution_result?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: test_plansUpdateOneRequiredWithoutPlan_casesNestedInput
  }

  export type test_plan_casesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    case_type?: StringFieldUpdateOperationsInput | string
    case_name?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    is_executed?: BoolFieldUpdateOperationsInput | boolean
    execution_result?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_casesCreateManyInput = {
    id?: number
    plan_id: number
    case_id: number
    case_type: string
    case_name: string
    sort_order?: number
    is_executed?: boolean
    execution_result?: string | null
    created_at?: Date | string
  }

  export type test_plan_casesUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    case_type?: StringFieldUpdateOperationsInput | string
    case_name?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    is_executed?: BoolFieldUpdateOperationsInput | boolean
    execution_result?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_casesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    case_type?: StringFieldUpdateOperationsInput | string
    case_name?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    is_executed?: BoolFieldUpdateOperationsInput | boolean
    execution_result?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_executionsCreateInput = {
    id?: string
    plan_name: string
    executor_id: number
    executor_name: string
    execution_type: string
    status: string
    progress?: number
    total_cases?: number
    completed_cases?: number
    passed_cases?: number
    failed_cases?: number
    blocked_cases?: number
    skipped_cases?: number
    started_at?: Date | string
    finished_at?: Date | string | null
    duration_ms?: number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    plan: test_plansCreateNestedOneWithoutPlan_executionsInput
  }

  export type test_plan_executionsUncheckedCreateInput = {
    id?: string
    plan_id: number
    plan_name: string
    executor_id: number
    executor_name: string
    execution_type: string
    status: string
    progress?: number
    total_cases?: number
    completed_cases?: number
    passed_cases?: number
    failed_cases?: number
    blocked_cases?: number
    skipped_cases?: number
    started_at?: Date | string
    finished_at?: Date | string | null
    duration_ms?: number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_executionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_name?: StringFieldUpdateOperationsInput | string
    execution_type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    total_cases?: IntFieldUpdateOperationsInput | number
    completed_cases?: IntFieldUpdateOperationsInput | number
    passed_cases?: IntFieldUpdateOperationsInput | number
    failed_cases?: IntFieldUpdateOperationsInput | number
    blocked_cases?: IntFieldUpdateOperationsInput | number
    skipped_cases?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    plan?: test_plansUpdateOneRequiredWithoutPlan_executionsNestedInput
  }

  export type test_plan_executionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_name?: StringFieldUpdateOperationsInput | string
    execution_type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    total_cases?: IntFieldUpdateOperationsInput | number
    completed_cases?: IntFieldUpdateOperationsInput | number
    passed_cases?: IntFieldUpdateOperationsInput | number
    failed_cases?: IntFieldUpdateOperationsInput | number
    blocked_cases?: IntFieldUpdateOperationsInput | number
    skipped_cases?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_executionsCreateManyInput = {
    id?: string
    plan_id: number
    plan_name: string
    executor_id: number
    executor_name: string
    execution_type: string
    status: string
    progress?: number
    total_cases?: number
    completed_cases?: number
    passed_cases?: number
    failed_cases?: number
    blocked_cases?: number
    skipped_cases?: number
    started_at?: Date | string
    finished_at?: Date | string | null
    duration_ms?: number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_executionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_name?: StringFieldUpdateOperationsInput | string
    execution_type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    total_cases?: IntFieldUpdateOperationsInput | number
    completed_cases?: IntFieldUpdateOperationsInput | number
    passed_cases?: IntFieldUpdateOperationsInput | number
    failed_cases?: IntFieldUpdateOperationsInput | number
    blocked_cases?: IntFieldUpdateOperationsInput | number
    skipped_cases?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_executionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_name?: StringFieldUpdateOperationsInput | string
    execution_type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    total_cases?: IntFieldUpdateOperationsInput | number
    completed_cases?: IntFieldUpdateOperationsInput | number
    passed_cases?: IntFieldUpdateOperationsInput | number
    failed_cases?: IntFieldUpdateOperationsInput | number
    blocked_cases?: IntFieldUpdateOperationsInput | number
    skipped_cases?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ai_element_cacheCreateInput = {
    cache_key: string
    url: string
    selector: string
    snapshot_fp: string
    element_ref: string
    element_text: string
    confidence?: number
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_element_cacheUncheckedCreateInput = {
    id?: number
    cache_key: string
    url: string
    selector: string
    snapshot_fp: string
    element_ref: string
    element_text: string
    confidence?: number
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_element_cacheUpdateInput = {
    cache_key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    snapshot_fp?: StringFieldUpdateOperationsInput | string
    element_ref?: StringFieldUpdateOperationsInput | string
    element_text?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_element_cacheUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cache_key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    snapshot_fp?: StringFieldUpdateOperationsInput | string
    element_ref?: StringFieldUpdateOperationsInput | string
    element_text?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_element_cacheCreateManyInput = {
    id?: number
    cache_key: string
    url: string
    selector: string
    snapshot_fp: string
    element_ref: string
    element_text: string
    confidence?: number
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_element_cacheUpdateManyMutationInput = {
    cache_key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    snapshot_fp?: StringFieldUpdateOperationsInput | string
    element_ref?: StringFieldUpdateOperationsInput | string
    element_text?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_element_cacheUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cache_key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    snapshot_fp?: StringFieldUpdateOperationsInput | string
    element_ref?: StringFieldUpdateOperationsInput | string
    element_text?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_assertion_cacheCreateInput = {
    cache_key: string
    assertion_desc: string
    page_elements_fp: string
    command_name: string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    assertion_info?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_assertion_cacheUncheckedCreateInput = {
    id?: number
    cache_key: string
    assertion_desc: string
    page_elements_fp: string
    command_name: string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    assertion_info?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_assertion_cacheUpdateInput = {
    cache_key?: StringFieldUpdateOperationsInput | string
    assertion_desc?: StringFieldUpdateOperationsInput | string
    page_elements_fp?: StringFieldUpdateOperationsInput | string
    command_name?: StringFieldUpdateOperationsInput | string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    assertion_info?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_assertion_cacheUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cache_key?: StringFieldUpdateOperationsInput | string
    assertion_desc?: StringFieldUpdateOperationsInput | string
    page_elements_fp?: StringFieldUpdateOperationsInput | string
    command_name?: StringFieldUpdateOperationsInput | string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    assertion_info?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_assertion_cacheCreateManyInput = {
    id?: number
    cache_key: string
    assertion_desc: string
    page_elements_fp: string
    command_name: string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    assertion_info?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_assertion_cacheUpdateManyMutationInput = {
    cache_key?: StringFieldUpdateOperationsInput | string
    assertion_desc?: StringFieldUpdateOperationsInput | string
    page_elements_fp?: StringFieldUpdateOperationsInput | string
    command_name?: StringFieldUpdateOperationsInput | string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    assertion_info?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_assertion_cacheUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cache_key?: StringFieldUpdateOperationsInput | string
    assertion_desc?: StringFieldUpdateOperationsInput | string
    page_elements_fp?: StringFieldUpdateOperationsInput | string
    command_name?: StringFieldUpdateOperationsInput | string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    assertion_info?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_operation_cacheCreateInput = {
    cache_key: string
    operation_desc: string
    page_elements_fp: string
    command_name: string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_operation_cacheUncheckedCreateInput = {
    id?: number
    cache_key: string
    operation_desc: string
    page_elements_fp: string
    command_name: string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_operation_cacheUpdateInput = {
    cache_key?: StringFieldUpdateOperationsInput | string
    operation_desc?: StringFieldUpdateOperationsInput | string
    page_elements_fp?: StringFieldUpdateOperationsInput | string
    command_name?: StringFieldUpdateOperationsInput | string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_operation_cacheUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cache_key?: StringFieldUpdateOperationsInput | string
    operation_desc?: StringFieldUpdateOperationsInput | string
    page_elements_fp?: StringFieldUpdateOperationsInput | string
    command_name?: StringFieldUpdateOperationsInput | string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_operation_cacheCreateManyInput = {
    id?: number
    cache_key: string
    operation_desc: string
    page_elements_fp: string
    command_name: string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: number
    last_hit_at?: Date | string | null
    created_at?: Date | string
    expires_at: Date | string
  }

  export type ai_operation_cacheUpdateManyMutationInput = {
    cache_key?: StringFieldUpdateOperationsInput | string
    operation_desc?: StringFieldUpdateOperationsInput | string
    page_elements_fp?: StringFieldUpdateOperationsInput | string
    command_name?: StringFieldUpdateOperationsInput | string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_operation_cacheUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cache_key?: StringFieldUpdateOperationsInput | string
    operation_desc?: StringFieldUpdateOperationsInput | string
    page_elements_fp?: StringFieldUpdateOperationsInput | string
    command_name?: StringFieldUpdateOperationsInput | string
    command_args?: NullableJsonNullValueInput | InputJsonValue
    hit_count?: IntFieldUpdateOperationsInput | number
    last_hit_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Ai_runsListRelationFilter = {
    every?: ai_runsWhereInput
    some?: ai_runsWhereInput
    none?: ai_runsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ai_runsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ai_promptsOrderByRelevanceInput = {
    fields: ai_promptsOrderByRelevanceFieldEnum | ai_promptsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ai_promptsNameVersionCompoundUniqueInput = {
    name: string
    version: number
  }

  export type ai_promptsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    template?: SortOrder
    created_at?: SortOrder
  }

  export type ai_promptsAvgOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
  }

  export type ai_promptsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    template?: SortOrder
    created_at?: SortOrder
  }

  export type ai_promptsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    template?: SortOrder
    created_at?: SortOrder
  }

  export type ai_promptsSumOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Ai_promptsScalarRelationFilter = {
    is?: ai_promptsWhereInput
    isNot?: ai_promptsWhereInput
  }

  export type Test_runsNullableScalarRelationFilter = {
    is?: test_runsWhereInput | null
    isNot?: test_runsWhereInput | null
  }

  export type ai_runsCountOrderByAggregateInput = {
    id?: SortOrder
    prompt_id?: SortOrder
    run_id?: SortOrder
    token_used?: SortOrder
    cost_usd?: SortOrder
    executed_at?: SortOrder
  }

  export type ai_runsAvgOrderByAggregateInput = {
    id?: SortOrder
    prompt_id?: SortOrder
    run_id?: SortOrder
    token_used?: SortOrder
    cost_usd?: SortOrder
  }

  export type ai_runsMaxOrderByAggregateInput = {
    id?: SortOrder
    prompt_id?: SortOrder
    run_id?: SortOrder
    token_used?: SortOrder
    cost_usd?: SortOrder
    executed_at?: SortOrder
  }

  export type ai_runsMinOrderByAggregateInput = {
    id?: SortOrder
    prompt_id?: SortOrder
    run_id?: SortOrder
    token_used?: SortOrder
    cost_usd?: SortOrder
    executed_at?: SortOrder
  }

  export type ai_runsSumOrderByAggregateInput = {
    id?: SortOrder
    prompt_id?: SortOrder
    run_id?: SortOrder
    token_used?: SortOrder
    cost_usd?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type api_tokensOrderByRelevanceInput = {
    fields: api_tokensOrderByRelevanceFieldEnum | api_tokensOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type api_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    scopes?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type api_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type api_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type api_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type api_tokensSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type Test_run_resultsScalarRelationFilter = {
    is?: test_run_resultsWhereInput
    isNot?: test_run_resultsWhereInput
  }

  export type attachmentsOrderByRelevanceInput = {
    fields: attachmentsOrderByRelevanceFieldEnum | attachmentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type attachmentsCountOrderByAggregateInput = {
    id?: SortOrder
    run_result_id?: SortOrder
    file_key?: SortOrder
    mime_type?: SortOrder
    size_bytes?: SortOrder
    created_at?: SortOrder
  }

  export type attachmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    run_result_id?: SortOrder
    size_bytes?: SortOrder
  }

  export type attachmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    run_result_id?: SortOrder
    file_key?: SortOrder
    mime_type?: SortOrder
    size_bytes?: SortOrder
    created_at?: SortOrder
  }

  export type attachmentsMinOrderByAggregateInput = {
    id?: SortOrder
    run_result_id?: SortOrder
    file_key?: SortOrder
    mime_type?: SortOrder
    size_bytes?: SortOrder
    created_at?: SortOrder
  }

  export type attachmentsSumOrderByAggregateInput = {
    id?: SortOrder
    run_result_id?: SortOrder
    size_bytes?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type audit_logsOrderByRelevanceInput = {
    fields: audit_logsOrderByRelevanceFieldEnum | audit_logsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type audit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    meta?: SortOrder
    created_at?: SortOrder
  }

  export type audit_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    target_id?: SortOrder
  }

  export type audit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    created_at?: SortOrder
  }

  export type audit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    created_at?: SortOrder
  }

  export type audit_logsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    target_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type feature_flagsOrderByRelevanceInput = {
    fields: feature_flagsOrderByRelevanceFieldEnum | feature_flagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type feature_flagsCountOrderByAggregateInput = {
    flag_name?: SortOrder
    is_enabled?: SortOrder
    rollout_percentage?: SortOrder
    updated_at?: SortOrder
  }

  export type feature_flagsAvgOrderByAggregateInput = {
    rollout_percentage?: SortOrder
  }

  export type feature_flagsMaxOrderByAggregateInput = {
    flag_name?: SortOrder
    is_enabled?: SortOrder
    rollout_percentage?: SortOrder
    updated_at?: SortOrder
  }

  export type feature_flagsMinOrderByAggregateInput = {
    flag_name?: SortOrder
    is_enabled?: SortOrder
    rollout_percentage?: SortOrder
    updated_at?: SortOrder
  }

  export type feature_flagsSumOrderByAggregateInput = {
    rollout_percentage?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Enumjob_logs_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.job_logs_status | Enumjob_logs_statusFieldRefInput<$PrismaModel>
    in?: $Enums.job_logs_status[]
    notIn?: $Enums.job_logs_status[]
    not?: NestedEnumjob_logs_statusFilter<$PrismaModel> | $Enums.job_logs_status
  }

  export type job_logsOrderByRelevanceInput = {
    fields: job_logsOrderByRelevanceFieldEnum | job_logsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type job_logsCountOrderByAggregateInput = {
    id?: SortOrder
    job_name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
  }

  export type job_logsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type job_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
  }

  export type job_logsMinOrderByAggregateInput = {
    id?: SortOrder
    job_name?: SortOrder
    status?: SortOrder
    message?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
  }

  export type job_logsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumjob_logs_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.job_logs_status | Enumjob_logs_statusFieldRefInput<$PrismaModel>
    in?: $Enums.job_logs_status[]
    notIn?: $Enums.job_logs_status[]
    not?: NestedEnumjob_logs_statusWithAggregatesFilter<$PrismaModel> | $Enums.job_logs_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjob_logs_statusFilter<$PrismaModel>
    _max?: NestedEnumjob_logs_statusFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type metrics_dailyMetric_dateSuite_idCompoundUniqueInput = {
    metric_date: Date | string
    suite_id: number
  }

  export type metrics_dailyCountOrderByAggregateInput = {
    metric_date?: SortOrder
    suite_id?: SortOrder
    pass_rate?: SortOrder
    avg_duration_ms?: SortOrder
  }

  export type metrics_dailyAvgOrderByAggregateInput = {
    suite_id?: SortOrder
    pass_rate?: SortOrder
    avg_duration_ms?: SortOrder
  }

  export type metrics_dailyMaxOrderByAggregateInput = {
    metric_date?: SortOrder
    suite_id?: SortOrder
    pass_rate?: SortOrder
    avg_duration_ms?: SortOrder
  }

  export type metrics_dailyMinOrderByAggregateInput = {
    metric_date?: SortOrder
    suite_id?: SortOrder
    pass_rate?: SortOrder
    avg_duration_ms?: SortOrder
  }

  export type metrics_dailySumOrderByAggregateInput = {
    suite_id?: SortOrder
    pass_rate?: SortOrder
    avg_duration_ms?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Test_runsScalarRelationFilter = {
    is?: test_runsWhereInput
    isNot?: test_runsWhereInput
  }

  export type reportsCountOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    summary?: SortOrder
    generated_at?: SortOrder
  }

  export type reportsAvgOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
  }

  export type reportsMaxOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    generated_at?: SortOrder
  }

  export type reportsMinOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    generated_at?: SortOrder
  }

  export type reportsSumOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
  }

  export type User_rolesListRelationFilter = {
    every?: user_rolesWhereInput
    some?: user_rolesWhereInput
    none?: user_rolesWhereInput
  }

  export type user_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesOrderByRelevanceInput = {
    fields: rolesOrderByRelevanceFieldEnum | rolesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type settingsOrderByRelevanceInput = {
    fields: settingsOrderByRelevanceFieldEnum | settingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type settingsCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updated_at?: SortOrder
  }

  export type Enumstep_screenshots_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.step_screenshots_status | Enumstep_screenshots_statusFieldRefInput<$PrismaModel>
    in?: $Enums.step_screenshots_status[]
    notIn?: $Enums.step_screenshots_status[]
    not?: NestedEnumstep_screenshots_statusFilter<$PrismaModel> | $Enums.step_screenshots_status
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Test_casesNullableScalarRelationFilter = {
    is?: test_casesWhereInput | null
    isNot?: test_casesWhereInput | null
  }

  export type step_screenshotsOrderByRelevanceInput = {
    fields: step_screenshotsOrderByRelevanceFieldEnum | step_screenshotsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type step_screenshotsCountOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    test_case_id?: SortOrder
    step_index?: SortOrder
    step_description?: SortOrder
    status?: SortOrder
    file_path?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    mime_type?: SortOrder
    created_at?: SortOrder
    file_exists?: SortOrder
  }

  export type step_screenshotsAvgOrderByAggregateInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    file_size?: SortOrder
  }

  export type step_screenshotsMaxOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    test_case_id?: SortOrder
    step_index?: SortOrder
    step_description?: SortOrder
    status?: SortOrder
    file_path?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    mime_type?: SortOrder
    created_at?: SortOrder
    file_exists?: SortOrder
  }

  export type step_screenshotsMinOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    test_case_id?: SortOrder
    step_index?: SortOrder
    step_description?: SortOrder
    status?: SortOrder
    file_path?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    mime_type?: SortOrder
    created_at?: SortOrder
    file_exists?: SortOrder
  }

  export type step_screenshotsSumOrderByAggregateInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    file_size?: SortOrder
  }

  export type Enumstep_screenshots_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.step_screenshots_status | Enumstep_screenshots_statusFieldRefInput<$PrismaModel>
    in?: $Enums.step_screenshots_status[]
    notIn?: $Enums.step_screenshots_status[]
    not?: NestedEnumstep_screenshots_statusWithAggregatesFilter<$PrismaModel> | $Enums.step_screenshots_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstep_screenshots_statusFilter<$PrismaModel>
    _max?: NestedEnumstep_screenshots_statusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Test_suitesScalarRelationFilter = {
    is?: test_suitesWhereInput
    isNot?: test_suitesWhereInput
  }

  export type Test_casesScalarRelationFilter = {
    is?: test_casesWhereInput
    isNot?: test_casesWhereInput
  }

  export type suite_case_mapSuite_idCase_idCompoundUniqueInput = {
    suite_id: number
    case_id: number
  }

  export type suite_case_mapCountOrderByAggregateInput = {
    suite_id?: SortOrder
    case_id?: SortOrder
  }

  export type suite_case_mapAvgOrderByAggregateInput = {
    suite_id?: SortOrder
    case_id?: SortOrder
  }

  export type suite_case_mapMaxOrderByAggregateInput = {
    suite_id?: SortOrder
    case_id?: SortOrder
  }

  export type suite_case_mapMinOrderByAggregateInput = {
    suite_id?: SortOrder
    case_id?: SortOrder
  }

  export type suite_case_mapSumOrderByAggregateInput = {
    suite_id?: SortOrder
    case_id?: SortOrder
  }

  export type Case_patch_proposalsListRelationFilter = {
    every?: case_patch_proposalsWhereInput
    some?: case_patch_proposalsWhereInput
    none?: case_patch_proposalsWhereInput
  }

  export type Case_versionsListRelationFilter = {
    every?: case_versionsWhereInput
    some?: case_versionsWhereInput
    none?: case_versionsWhereInput
  }

  export type Step_screenshotsListRelationFilter = {
    every?: step_screenshotsWhereInput
    some?: step_screenshotsWhereInput
    none?: step_screenshotsWhereInput
  }

  export type Suite_case_mapListRelationFilter = {
    every?: suite_case_mapWhereInput
    some?: suite_case_mapWhereInput
    none?: suite_case_mapWhereInput
  }

  export type Test_case_executionsListRelationFilter = {
    every?: test_case_executionsWhereInput
    some?: test_case_executionsWhereInput
    none?: test_case_executionsWhereInput
  }

  export type Test_run_resultsListRelationFilter = {
    every?: test_run_resultsWhereInput
    some?: test_run_resultsWhereInput
    none?: test_run_resultsWhereInput
  }

  export type case_patch_proposalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type case_versionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type step_screenshotsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type suite_case_mapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_case_executionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_run_resultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_casesOrderByRelevanceInput = {
    fields: test_casesOrderByRelevanceFieldEnum | test_casesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type test_casesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    steps?: SortOrder
    tags?: SortOrder
    system?: SortOrder
    module?: SortOrder
    project?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type test_casesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type test_casesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    system?: SortOrder
    module?: SortOrder
    project?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type test_casesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    system?: SortOrder
    module?: SortOrder
    project?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type test_casesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumtest_run_results_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_run_results_status | Enumtest_run_results_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_run_results_status[]
    notIn?: $Enums.test_run_results_status[]
    not?: NestedEnumtest_run_results_statusFilter<$PrismaModel> | $Enums.test_run_results_status
  }

  export type AttachmentsListRelationFilter = {
    every?: attachmentsWhereInput
    some?: attachmentsWhereInput
    none?: attachmentsWhereInput
  }

  export type attachmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_run_resultsOrderByRelevanceInput = {
    fields: test_run_resultsOrderByRelevanceFieldEnum | test_run_resultsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type test_run_resultsCountOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    case_id?: SortOrder
    status?: SortOrder
    duration_ms?: SortOrder
    screenshot_url?: SortOrder
    executed_at?: SortOrder
  }

  export type test_run_resultsAvgOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    case_id?: SortOrder
    duration_ms?: SortOrder
  }

  export type test_run_resultsMaxOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    case_id?: SortOrder
    status?: SortOrder
    duration_ms?: SortOrder
    screenshot_url?: SortOrder
    executed_at?: SortOrder
  }

  export type test_run_resultsMinOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    case_id?: SortOrder
    status?: SortOrder
    duration_ms?: SortOrder
    screenshot_url?: SortOrder
    executed_at?: SortOrder
  }

  export type test_run_resultsSumOrderByAggregateInput = {
    id?: SortOrder
    run_id?: SortOrder
    case_id?: SortOrder
    duration_ms?: SortOrder
  }

  export type Enumtest_run_results_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_run_results_status | Enumtest_run_results_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_run_results_status[]
    notIn?: $Enums.test_run_results_status[]
    not?: NestedEnumtest_run_results_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_run_results_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_run_results_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_run_results_statusFilter<$PrismaModel>
  }

  export type Enumtest_runs_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_runs_status | Enumtest_runs_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_runs_status[]
    notIn?: $Enums.test_runs_status[]
    not?: NestedEnumtest_runs_statusFilter<$PrismaModel> | $Enums.test_runs_status
  }

  export type ReportsListRelationFilter = {
    every?: reportsWhereInput
    some?: reportsWhereInput
    none?: reportsWhereInput
  }

  export type reportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_runsCountOrderByAggregateInput = {
    id?: SortOrder
    suite_id?: SortOrder
    trigger_user_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
  }

  export type test_runsAvgOrderByAggregateInput = {
    id?: SortOrder
    suite_id?: SortOrder
    trigger_user_id?: SortOrder
  }

  export type test_runsMaxOrderByAggregateInput = {
    id?: SortOrder
    suite_id?: SortOrder
    trigger_user_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
  }

  export type test_runsMinOrderByAggregateInput = {
    id?: SortOrder
    suite_id?: SortOrder
    trigger_user_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
  }

  export type test_runsSumOrderByAggregateInput = {
    id?: SortOrder
    suite_id?: SortOrder
    trigger_user_id?: SortOrder
  }

  export type Enumtest_runs_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_runs_status | Enumtest_runs_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_runs_status[]
    notIn?: $Enums.test_runs_status[]
    not?: NestedEnumtest_runs_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_runs_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_runs_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_runs_statusFilter<$PrismaModel>
  }

  export type Test_runsListRelationFilter = {
    every?: test_runsWhereInput
    some?: test_runsWhereInput
    none?: test_runsWhereInput
  }

  export type test_runsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_suitesOrderByRelevanceInput = {
    fields: test_suitesOrderByRelevanceFieldEnum | test_suitesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type test_suitesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    project?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
  }

  export type test_suitesAvgOrderByAggregateInput = {
    id?: SortOrder
    owner_id?: SortOrder
  }

  export type test_suitesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    project?: SortOrder
    created_at?: SortOrder
  }

  export type test_suitesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    project?: SortOrder
    created_at?: SortOrder
  }

  export type test_suitesSumOrderByAggregateInput = {
    id?: SortOrder
    owner_id?: SortOrder
  }

  export type RolesScalarRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type user_rolesUser_idRole_idCompoundUniqueInput = {
    user_id: number
    role_id: number
  }

  export type user_rolesCountOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_rolesAvgOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_rolesMaxOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_rolesMinOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_rolesSumOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type Ai_generation_sessionsListRelationFilter = {
    every?: ai_generation_sessionsWhereInput
    some?: ai_generation_sessionsWhereInput
    none?: ai_generation_sessionsWhereInput
  }

  export type Api_tokensListRelationFilter = {
    every?: api_tokensWhereInput
    some?: api_tokensWhereInput
    none?: api_tokensWhereInput
  }

  export type Audit_logsListRelationFilter = {
    every?: audit_logsWhereInput
    some?: audit_logsWhereInput
    none?: audit_logsWhereInput
  }

  export type Bulk_edit_sessionsListRelationFilter = {
    every?: bulk_edit_sessionsWhereInput
    some?: bulk_edit_sessionsWhereInput
    none?: bulk_edit_sessionsWhereInput
  }

  export type Functional_test_casesListRelationFilter = {
    every?: functional_test_casesWhereInput
    some?: functional_test_casesWhereInput
    none?: functional_test_casesWhereInput
  }

  export type Requirement_documentsListRelationFilter = {
    every?: requirement_documentsWhereInput
    some?: requirement_documentsWhereInput
    none?: requirement_documentsWhereInput
  }

  export type Test_suitesListRelationFilter = {
    every?: test_suitesWhereInput
    some?: test_suitesWhereInput
    none?: test_suitesWhereInput
  }

  export type Functional_test_executionsListRelationFilter = {
    every?: functional_test_executionsWhereInput
    some?: functional_test_executionsWhereInput
    none?: functional_test_executionsWhereInput
  }

  export type Test_plansListRelationFilter = {
    every?: test_plansWhereInput
    some?: test_plansWhereInput
    none?: test_plansWhereInput
  }

  export type ai_generation_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type api_tokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type audit_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bulk_edit_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type functional_test_casesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type requirement_documentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_suitesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type functional_test_executionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_plansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    account_name?: SortOrder
    password_hash?: SortOrder
    project?: SortOrder
    is_super_admin?: SortOrder
    created_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    account_name?: SortOrder
    password_hash?: SortOrder
    project?: SortOrder
    is_super_admin?: SortOrder
    created_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    account_name?: SortOrder
    password_hash?: SortOrder
    project?: SortOrder
    is_super_admin?: SortOrder
    created_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type run_artifactsOrderByRelevanceInput = {
    fields: run_artifactsOrderByRelevanceFieldEnum | run_artifactsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type run_artifactsCountOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type run_artifactsAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
  }

  export type run_artifactsMaxOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type run_artifactsMinOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type run_artifactsSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
  }

  export type case_versionsOrderByRelevanceInput = {
    fields: case_versionsOrderByRelevanceFieldEnum | case_versionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type case_versionsCase_idVersionCompoundUniqueInput = {
    case_id: number
    version: number
  }

  export type case_versionsCountOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    version?: SortOrder
    steps?: SortOrder
    tags?: SortOrder
    system?: SortOrder
    module?: SortOrder
    meta?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type case_versionsAvgOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    version?: SortOrder
    created_by?: SortOrder
  }

  export type case_versionsMaxOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    version?: SortOrder
    system?: SortOrder
    module?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type case_versionsMinOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    version?: SortOrder
    system?: SortOrder
    module?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type case_versionsSumOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    version?: SortOrder
    created_by?: SortOrder
  }

  export type Enumbulk_edit_sessions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.bulk_edit_sessions_status | Enumbulk_edit_sessions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.bulk_edit_sessions_status[]
    notIn?: $Enums.bulk_edit_sessions_status[]
    not?: NestedEnumbulk_edit_sessions_statusFilter<$PrismaModel> | $Enums.bulk_edit_sessions_status
  }

  export type bulk_edit_sessionsOrderByRelevanceInput = {
    fields: bulk_edit_sessionsOrderByRelevanceFieldEnum | bulk_edit_sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type bulk_edit_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    system?: SortOrder
    module?: SortOrder
    tag_filter?: SortOrder
    priority_filter?: SortOrder
    change_brief?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    applied_at?: SortOrder
  }

  export type bulk_edit_sessionsAvgOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
  }

  export type bulk_edit_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    system?: SortOrder
    module?: SortOrder
    priority_filter?: SortOrder
    change_brief?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    applied_at?: SortOrder
  }

  export type bulk_edit_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    system?: SortOrder
    module?: SortOrder
    priority_filter?: SortOrder
    change_brief?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    applied_at?: SortOrder
  }

  export type bulk_edit_sessionsSumOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
  }

  export type Enumbulk_edit_sessions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.bulk_edit_sessions_status | Enumbulk_edit_sessions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.bulk_edit_sessions_status[]
    notIn?: $Enums.bulk_edit_sessions_status[]
    not?: NestedEnumbulk_edit_sessions_statusWithAggregatesFilter<$PrismaModel> | $Enums.bulk_edit_sessions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbulk_edit_sessions_statusFilter<$PrismaModel>
    _max?: NestedEnumbulk_edit_sessions_statusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Enumproposal_risk_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.proposal_risk_level | Enumproposal_risk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.proposal_risk_level[]
    notIn?: $Enums.proposal_risk_level[]
    not?: NestedEnumproposal_risk_levelFilter<$PrismaModel> | $Enums.proposal_risk_level
  }

  export type Enumproposal_apply_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.proposal_apply_status | Enumproposal_apply_statusFieldRefInput<$PrismaModel>
    in?: $Enums.proposal_apply_status[]
    notIn?: $Enums.proposal_apply_status[]
    not?: NestedEnumproposal_apply_statusFilter<$PrismaModel> | $Enums.proposal_apply_status
  }

  export type Bulk_edit_sessionsScalarRelationFilter = {
    is?: bulk_edit_sessionsWhereInput
    isNot?: bulk_edit_sessionsWhereInput
  }

  export type case_patch_proposalsOrderByRelevanceInput = {
    fields: case_patch_proposalsOrderByRelevanceFieldEnum | case_patch_proposalsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type case_patch_proposalsCountOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    case_id?: SortOrder
    diff_json?: SortOrder
    ai_rationale?: SortOrder
    side_effects?: SortOrder
    risk_level?: SortOrder
    recall_reason?: SortOrder
    old_hash?: SortOrder
    new_hash?: SortOrder
    apply_status?: SortOrder
    created_at?: SortOrder
    applied_at?: SortOrder
  }

  export type case_patch_proposalsAvgOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    case_id?: SortOrder
  }

  export type case_patch_proposalsMaxOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    case_id?: SortOrder
    ai_rationale?: SortOrder
    risk_level?: SortOrder
    recall_reason?: SortOrder
    old_hash?: SortOrder
    new_hash?: SortOrder
    apply_status?: SortOrder
    created_at?: SortOrder
    applied_at?: SortOrder
  }

  export type case_patch_proposalsMinOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    case_id?: SortOrder
    ai_rationale?: SortOrder
    risk_level?: SortOrder
    recall_reason?: SortOrder
    old_hash?: SortOrder
    new_hash?: SortOrder
    apply_status?: SortOrder
    created_at?: SortOrder
    applied_at?: SortOrder
  }

  export type case_patch_proposalsSumOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    case_id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type Enumproposal_risk_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.proposal_risk_level | Enumproposal_risk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.proposal_risk_level[]
    notIn?: $Enums.proposal_risk_level[]
    not?: NestedEnumproposal_risk_levelWithAggregatesFilter<$PrismaModel> | $Enums.proposal_risk_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumproposal_risk_levelFilter<$PrismaModel>
    _max?: NestedEnumproposal_risk_levelFilter<$PrismaModel>
  }

  export type Enumproposal_apply_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.proposal_apply_status | Enumproposal_apply_statusFieldRefInput<$PrismaModel>
    in?: $Enums.proposal_apply_status[]
    notIn?: $Enums.proposal_apply_status[]
    not?: NestedEnumproposal_apply_statusWithAggregatesFilter<$PrismaModel> | $Enums.proposal_apply_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumproposal_apply_statusFilter<$PrismaModel>
    _max?: NestedEnumproposal_apply_statusFilter<$PrismaModel>
  }

  export type Enumtest_case_execution_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_case_execution_status | Enumtest_case_execution_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_case_execution_status[]
    notIn?: $Enums.test_case_execution_status[]
    not?: NestedEnumtest_case_execution_statusFilter<$PrismaModel> | $Enums.test_case_execution_status
  }

  export type test_case_executionsOrderByRelevanceInput = {
    fields: test_case_executionsOrderByRelevanceFieldEnum | test_case_executionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type test_case_executionsCountOrderByAggregateInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_title?: SortOrder
    environment?: SortOrder
    execution_mode?: SortOrder
    status?: SortOrder
    executor_user_id?: SortOrder
    executor_project?: SortOrder
    queued_at?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    duration_ms?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    progress?: SortOrder
    error_message?: SortOrder
    execution_logs?: SortOrder
    screenshots?: SortOrder
    artifacts?: SortOrder
    metadata?: SortOrder
  }

  export type test_case_executionsAvgOrderByAggregateInput = {
    test_case_id?: SortOrder
    executor_user_id?: SortOrder
    duration_ms?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    progress?: SortOrder
  }

  export type test_case_executionsMaxOrderByAggregateInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_title?: SortOrder
    environment?: SortOrder
    execution_mode?: SortOrder
    status?: SortOrder
    executor_user_id?: SortOrder
    executor_project?: SortOrder
    queued_at?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    duration_ms?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    progress?: SortOrder
    error_message?: SortOrder
  }

  export type test_case_executionsMinOrderByAggregateInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_title?: SortOrder
    environment?: SortOrder
    execution_mode?: SortOrder
    status?: SortOrder
    executor_user_id?: SortOrder
    executor_project?: SortOrder
    queued_at?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    duration_ms?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    progress?: SortOrder
    error_message?: SortOrder
  }

  export type test_case_executionsSumOrderByAggregateInput = {
    test_case_id?: SortOrder
    executor_user_id?: SortOrder
    duration_ms?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    progress?: SortOrder
  }

  export type Enumtest_case_execution_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_case_execution_status | Enumtest_case_execution_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_case_execution_status[]
    notIn?: $Enums.test_case_execution_status[]
    not?: NestedEnumtest_case_execution_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_case_execution_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_case_execution_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_case_execution_statusFilter<$PrismaModel>
  }

  export type Enumfunctional_test_priorityFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_priority | Enumfunctional_test_priorityFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_priority[]
    notIn?: $Enums.functional_test_priority[]
    not?: NestedEnumfunctional_test_priorityFilter<$PrismaModel> | $Enums.functional_test_priority
  }

  export type Enumfunctional_test_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_status | Enumfunctional_test_statusFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_status[]
    notIn?: $Enums.functional_test_status[]
    not?: NestedEnumfunctional_test_statusFilter<$PrismaModel> | $Enums.functional_test_status
  }

  export type Enumfunctional_test_sourceFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_source | Enumfunctional_test_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_source[]
    notIn?: $Enums.functional_test_source[]
    not?: NestedEnumfunctional_test_sourceFilter<$PrismaModel> | $Enums.functional_test_source
  }

  export type Enumfunctional_case_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_case_type | Enumfunctional_case_typeFieldRefInput<$PrismaModel>
    in?: $Enums.functional_case_type[]
    notIn?: $Enums.functional_case_type[]
    not?: NestedEnumfunctional_case_typeFilter<$PrismaModel> | $Enums.functional_case_type
  }

  export type Enumfunctional_risk_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_risk_level | Enumfunctional_risk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.functional_risk_level[]
    notIn?: $Enums.functional_risk_level[]
    not?: NestedEnumfunctional_risk_levelFilter<$PrismaModel> | $Enums.functional_risk_level
  }

  export type Project_versionsNullableScalarRelationFilter = {
    is?: project_versionsWhereInput | null
    isNot?: project_versionsWhereInput | null
  }

  export type Requirement_documentsNullableScalarRelationFilter = {
    is?: requirement_documentsWhereInput | null
    isNot?: requirement_documentsWhereInput | null
  }

  export type functional_test_casesOrderByRelevanceInput = {
    fields: functional_test_casesOrderByRelevanceFieldEnum | functional_test_casesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type functional_test_casesCountOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    system?: SortOrder
    module?: SortOrder
    priority?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    source?: SortOrder
    ai_session_id?: SortOrder
    creator_id?: SortOrder
    test_type?: SortOrder
    preconditions?: SortOrder
    test_data?: SortOrder
    section_id?: SortOrder
    section_name?: SortOrder
    scenario_name?: SortOrder
    scenario_description?: SortOrder
    batch_number?: SortOrder
    coverage_areas?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    case_type?: SortOrder
    project_version_id?: SortOrder
    requirement_source?: SortOrder
    section_description?: SortOrder
    expected_result?: SortOrder
    risk_level?: SortOrder
    steps?: SortOrder
    test_point_name?: SortOrder
    test_purpose?: SortOrder
    requirement_doc_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type functional_test_casesAvgOrderByAggregateInput = {
    id?: SortOrder
    creator_id?: SortOrder
    batch_number?: SortOrder
    project_version_id?: SortOrder
    requirement_doc_id?: SortOrder
  }

  export type functional_test_casesMaxOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    system?: SortOrder
    module?: SortOrder
    priority?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    source?: SortOrder
    ai_session_id?: SortOrder
    creator_id?: SortOrder
    test_type?: SortOrder
    preconditions?: SortOrder
    test_data?: SortOrder
    section_id?: SortOrder
    section_name?: SortOrder
    scenario_name?: SortOrder
    scenario_description?: SortOrder
    batch_number?: SortOrder
    coverage_areas?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    case_type?: SortOrder
    project_version_id?: SortOrder
    requirement_source?: SortOrder
    section_description?: SortOrder
    expected_result?: SortOrder
    risk_level?: SortOrder
    steps?: SortOrder
    test_point_name?: SortOrder
    test_purpose?: SortOrder
    requirement_doc_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type functional_test_casesMinOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    system?: SortOrder
    module?: SortOrder
    priority?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    source?: SortOrder
    ai_session_id?: SortOrder
    creator_id?: SortOrder
    test_type?: SortOrder
    preconditions?: SortOrder
    test_data?: SortOrder
    section_id?: SortOrder
    section_name?: SortOrder
    scenario_name?: SortOrder
    scenario_description?: SortOrder
    batch_number?: SortOrder
    coverage_areas?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    case_type?: SortOrder
    project_version_id?: SortOrder
    requirement_source?: SortOrder
    section_description?: SortOrder
    expected_result?: SortOrder
    risk_level?: SortOrder
    steps?: SortOrder
    test_point_name?: SortOrder
    test_purpose?: SortOrder
    requirement_doc_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type functional_test_casesSumOrderByAggregateInput = {
    id?: SortOrder
    creator_id?: SortOrder
    batch_number?: SortOrder
    project_version_id?: SortOrder
    requirement_doc_id?: SortOrder
  }

  export type Enumfunctional_test_priorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_priority | Enumfunctional_test_priorityFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_priority[]
    notIn?: $Enums.functional_test_priority[]
    not?: NestedEnumfunctional_test_priorityWithAggregatesFilter<$PrismaModel> | $Enums.functional_test_priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_test_priorityFilter<$PrismaModel>
    _max?: NestedEnumfunctional_test_priorityFilter<$PrismaModel>
  }

  export type Enumfunctional_test_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_status | Enumfunctional_test_statusFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_status[]
    notIn?: $Enums.functional_test_status[]
    not?: NestedEnumfunctional_test_statusWithAggregatesFilter<$PrismaModel> | $Enums.functional_test_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_test_statusFilter<$PrismaModel>
    _max?: NestedEnumfunctional_test_statusFilter<$PrismaModel>
  }

  export type Enumfunctional_test_sourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_source | Enumfunctional_test_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_source[]
    notIn?: $Enums.functional_test_source[]
    not?: NestedEnumfunctional_test_sourceWithAggregatesFilter<$PrismaModel> | $Enums.functional_test_source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_test_sourceFilter<$PrismaModel>
    _max?: NestedEnumfunctional_test_sourceFilter<$PrismaModel>
  }

  export type Enumfunctional_case_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_case_type | Enumfunctional_case_typeFieldRefInput<$PrismaModel>
    in?: $Enums.functional_case_type[]
    notIn?: $Enums.functional_case_type[]
    not?: NestedEnumfunctional_case_typeWithAggregatesFilter<$PrismaModel> | $Enums.functional_case_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_case_typeFilter<$PrismaModel>
    _max?: NestedEnumfunctional_case_typeFilter<$PrismaModel>
  }

  export type Enumfunctional_risk_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_risk_level | Enumfunctional_risk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.functional_risk_level[]
    notIn?: $Enums.functional_risk_level[]
    not?: NestedEnumfunctional_risk_levelWithAggregatesFilter<$PrismaModel> | $Enums.functional_risk_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_risk_levelFilter<$PrismaModel>
    _max?: NestedEnumfunctional_risk_levelFilter<$PrismaModel>
  }

  export type ai_generation_sessionsOrderByRelevanceInput = {
    fields: ai_generation_sessionsOrderByRelevanceFieldEnum | ai_generation_sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ai_generation_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    axure_filename?: SortOrder
    axure_file_size?: SortOrder
    project_name?: SortOrder
    system_type?: SortOrder
    business_domain?: SortOrder
    requirement_doc?: SortOrder
    page_count?: SortOrder
    element_count?: SortOrder
    interaction_count?: SortOrder
    total_generated?: SortOrder
    total_saved?: SortOrder
    batches?: SortOrder
    pre_analysis_result?: SortOrder
    enhanced_data?: SortOrder
    created_at?: SortOrder
  }

  export type ai_generation_sessionsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    axure_file_size?: SortOrder
    page_count?: SortOrder
    element_count?: SortOrder
    interaction_count?: SortOrder
    total_generated?: SortOrder
    total_saved?: SortOrder
  }

  export type ai_generation_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    axure_filename?: SortOrder
    axure_file_size?: SortOrder
    project_name?: SortOrder
    system_type?: SortOrder
    business_domain?: SortOrder
    requirement_doc?: SortOrder
    page_count?: SortOrder
    element_count?: SortOrder
    interaction_count?: SortOrder
    total_generated?: SortOrder
    total_saved?: SortOrder
    created_at?: SortOrder
  }

  export type ai_generation_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    axure_filename?: SortOrder
    axure_file_size?: SortOrder
    project_name?: SortOrder
    system_type?: SortOrder
    business_domain?: SortOrder
    requirement_doc?: SortOrder
    page_count?: SortOrder
    element_count?: SortOrder
    interaction_count?: SortOrder
    total_generated?: SortOrder
    total_saved?: SortOrder
    created_at?: SortOrder
  }

  export type ai_generation_sessionsSumOrderByAggregateInput = {
    user_id?: SortOrder
    axure_file_size?: SortOrder
    page_count?: SortOrder
    element_count?: SortOrder
    interaction_count?: SortOrder
    total_generated?: SortOrder
    total_saved?: SortOrder
  }

  export type Enumrequirement_doc_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.requirement_doc_status | Enumrequirement_doc_statusFieldRefInput<$PrismaModel>
    in?: $Enums.requirement_doc_status[]
    notIn?: $Enums.requirement_doc_status[]
    not?: NestedEnumrequirement_doc_statusFilter<$PrismaModel> | $Enums.requirement_doc_status
  }

  export type Ai_generation_sessionsNullableScalarRelationFilter = {
    is?: ai_generation_sessionsWhereInput | null
    isNot?: ai_generation_sessionsWhereInput | null
  }

  export type SystemsNullableScalarRelationFilter = {
    is?: systemsWhereInput | null
    isNot?: systemsWhereInput | null
  }

  export type requirement_documentsOrderByRelevanceInput = {
    fields: requirement_documentsOrderByRelevanceFieldEnum | requirement_documentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type requirement_documentsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    source_filename?: SortOrder
    ai_session_id?: SortOrder
    project_id?: SortOrder
    project_version_id?: SortOrder
    creator_id?: SortOrder
    scenario_count?: SortOrder
    test_case_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    module?: SortOrder
    system?: SortOrder
  }

  export type requirement_documentsAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    project_version_id?: SortOrder
    creator_id?: SortOrder
    scenario_count?: SortOrder
    test_case_count?: SortOrder
  }

  export type requirement_documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    source_filename?: SortOrder
    ai_session_id?: SortOrder
    project_id?: SortOrder
    project_version_id?: SortOrder
    creator_id?: SortOrder
    scenario_count?: SortOrder
    test_case_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    module?: SortOrder
    system?: SortOrder
  }

  export type requirement_documentsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    source_filename?: SortOrder
    ai_session_id?: SortOrder
    project_id?: SortOrder
    project_version_id?: SortOrder
    creator_id?: SortOrder
    scenario_count?: SortOrder
    test_case_count?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    module?: SortOrder
    system?: SortOrder
  }

  export type requirement_documentsSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    project_version_id?: SortOrder
    creator_id?: SortOrder
    scenario_count?: SortOrder
    test_case_count?: SortOrder
  }

  export type Enumrequirement_doc_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.requirement_doc_status | Enumrequirement_doc_statusFieldRefInput<$PrismaModel>
    in?: $Enums.requirement_doc_status[]
    notIn?: $Enums.requirement_doc_status[]
    not?: NestedEnumrequirement_doc_statusWithAggregatesFilter<$PrismaModel> | $Enums.requirement_doc_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrequirement_doc_statusFilter<$PrismaModel>
    _max?: NestedEnumrequirement_doc_statusFilter<$PrismaModel>
  }

  export type Enumsystem_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.system_status | Enumsystem_statusFieldRefInput<$PrismaModel>
    in?: $Enums.system_status[]
    notIn?: $Enums.system_status[]
    not?: NestedEnumsystem_statusFilter<$PrismaModel> | $Enums.system_status
  }

  export type Project_versionsListRelationFilter = {
    every?: project_versionsWhereInput
    some?: project_versionsWhereInput
    none?: project_versionsWhereInput
  }

  export type project_versionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type systemsOrderByRelevanceInput = {
    fields: systemsOrderByRelevanceFieldEnum | systemsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type systemsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type systemsAvgOrderByAggregateInput = {
    id?: SortOrder
    sort_order?: SortOrder
  }

  export type systemsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type systemsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type systemsSumOrderByAggregateInput = {
    id?: SortOrder
    sort_order?: SortOrder
  }

  export type Enumsystem_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.system_status | Enumsystem_statusFieldRefInput<$PrismaModel>
    in?: $Enums.system_status[]
    notIn?: $Enums.system_status[]
    not?: NestedEnumsystem_statusWithAggregatesFilter<$PrismaModel> | $Enums.system_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsystem_statusFilter<$PrismaModel>
    _max?: NestedEnumsystem_statusFilter<$PrismaModel>
  }

  export type SystemsScalarRelationFilter = {
    is?: systemsWhereInput
    isNot?: systemsWhereInput
  }

  export type project_versionsOrderByRelevanceInput = {
    fields: project_versionsOrderByRelevanceFieldEnum | project_versionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type project_versionsProject_idVersion_codeCompoundUniqueInput = {
    project_id: number
    version_code: string
  }

  export type project_versionsCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    version_name?: SortOrder
    version_code?: SortOrder
    description?: SortOrder
    is_main?: SortOrder
    status?: SortOrder
    release_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type project_versionsAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
  }

  export type project_versionsMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    version_name?: SortOrder
    version_code?: SortOrder
    description?: SortOrder
    is_main?: SortOrder
    status?: SortOrder
    release_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type project_versionsMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    version_name?: SortOrder
    version_code?: SortOrder
    description?: SortOrder
    is_main?: SortOrder
    status?: SortOrder
    release_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type project_versionsSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
  }

  export type Enumfunctional_execution_resultFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_execution_result | Enumfunctional_execution_resultFieldRefInput<$PrismaModel>
    in?: $Enums.functional_execution_result[]
    notIn?: $Enums.functional_execution_result[]
    not?: NestedEnumfunctional_execution_resultFilter<$PrismaModel> | $Enums.functional_execution_result
  }

  export type Functional_test_casesScalarRelationFilter = {
    is?: functional_test_casesWhereInput
    isNot?: functional_test_casesWhereInput
  }

  export type functional_test_executionsOrderByRelevanceInput = {
    fields: functional_test_executionsOrderByRelevanceFieldEnum | functional_test_executionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type functional_test_executionsCountOrderByAggregateInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_name?: SortOrder
    final_result?: SortOrder
    actual_result?: SortOrder
    comments?: SortOrder
    duration_ms?: SortOrder
    executed_at?: SortOrder
    executor_id?: SortOrder
    executor_project?: SortOrder
    step_results?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    blocked_steps?: SortOrder
    screenshots?: SortOrder
    attachments?: SortOrder
    metadata?: SortOrder
  }

  export type functional_test_executionsAvgOrderByAggregateInput = {
    test_case_id?: SortOrder
    duration_ms?: SortOrder
    executor_id?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    blocked_steps?: SortOrder
  }

  export type functional_test_executionsMaxOrderByAggregateInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_name?: SortOrder
    final_result?: SortOrder
    actual_result?: SortOrder
    comments?: SortOrder
    duration_ms?: SortOrder
    executed_at?: SortOrder
    executor_id?: SortOrder
    executor_project?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    blocked_steps?: SortOrder
  }

  export type functional_test_executionsMinOrderByAggregateInput = {
    id?: SortOrder
    test_case_id?: SortOrder
    test_case_name?: SortOrder
    final_result?: SortOrder
    actual_result?: SortOrder
    comments?: SortOrder
    duration_ms?: SortOrder
    executed_at?: SortOrder
    executor_id?: SortOrder
    executor_project?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    blocked_steps?: SortOrder
  }

  export type functional_test_executionsSumOrderByAggregateInput = {
    test_case_id?: SortOrder
    duration_ms?: SortOrder
    executor_id?: SortOrder
    total_steps?: SortOrder
    completed_steps?: SortOrder
    passed_steps?: SortOrder
    failed_steps?: SortOrder
    blocked_steps?: SortOrder
  }

  export type Enumfunctional_execution_resultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_execution_result | Enumfunctional_execution_resultFieldRefInput<$PrismaModel>
    in?: $Enums.functional_execution_result[]
    notIn?: $Enums.functional_execution_result[]
    not?: NestedEnumfunctional_execution_resultWithAggregatesFilter<$PrismaModel> | $Enums.functional_execution_result
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_execution_resultFilter<$PrismaModel>
    _max?: NestedEnumfunctional_execution_resultFilter<$PrismaModel>
  }

  export type Enumtest_plan_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plan_type | Enumtest_plan_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plan_type[]
    notIn?: $Enums.test_plan_type[]
    not?: NestedEnumtest_plan_typeFilter<$PrismaModel> | $Enums.test_plan_type
  }

  export type Enumtest_plan_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plan_status | Enumtest_plan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_plan_status[]
    notIn?: $Enums.test_plan_status[]
    not?: NestedEnumtest_plan_statusFilter<$PrismaModel> | $Enums.test_plan_status
  }

  export type Test_plan_casesListRelationFilter = {
    every?: test_plan_casesWhereInput
    some?: test_plan_casesWhereInput
    none?: test_plan_casesWhereInput
  }

  export type Test_plan_executionsListRelationFilter = {
    every?: test_plan_executionsWhereInput
    some?: test_plan_executionsWhereInput
    none?: test_plan_executionsWhereInput
  }

  export type test_plan_casesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_plan_executionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_plansOrderByRelevanceInput = {
    fields: test_plansOrderByRelevanceFieldEnum | test_plansOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type test_plansCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    description?: SortOrder
    project?: SortOrder
    plan_type?: SortOrder
    status?: SortOrder
    members?: SortOrder
    owner_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type test_plansAvgOrderByAggregateInput = {
    id?: SortOrder
    owner_id?: SortOrder
  }

  export type test_plansMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    description?: SortOrder
    project?: SortOrder
    plan_type?: SortOrder
    status?: SortOrder
    owner_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type test_plansMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    short_name?: SortOrder
    description?: SortOrder
    project?: SortOrder
    plan_type?: SortOrder
    status?: SortOrder
    owner_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type test_plansSumOrderByAggregateInput = {
    id?: SortOrder
    owner_id?: SortOrder
  }

  export type Enumtest_plan_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plan_type | Enumtest_plan_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plan_type[]
    notIn?: $Enums.test_plan_type[]
    not?: NestedEnumtest_plan_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_plan_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_plan_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_plan_typeFilter<$PrismaModel>
  }

  export type Enumtest_plan_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plan_status | Enumtest_plan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_plan_status[]
    notIn?: $Enums.test_plan_status[]
    not?: NestedEnumtest_plan_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_plan_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_plan_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_plan_statusFilter<$PrismaModel>
  }

  export type Test_plansScalarRelationFilter = {
    is?: test_plansWhereInput
    isNot?: test_plansWhereInput
  }

  export type test_plan_casesOrderByRelevanceInput = {
    fields: test_plan_casesOrderByRelevanceFieldEnum | test_plan_casesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type test_plan_casesPlan_idCase_idCase_typeCompoundUniqueInput = {
    plan_id: number
    case_id: number
    case_type: string
  }

  export type test_plan_casesCountOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    case_id?: SortOrder
    case_type?: SortOrder
    case_name?: SortOrder
    sort_order?: SortOrder
    is_executed?: SortOrder
    execution_result?: SortOrder
    created_at?: SortOrder
  }

  export type test_plan_casesAvgOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    case_id?: SortOrder
    sort_order?: SortOrder
  }

  export type test_plan_casesMaxOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    case_id?: SortOrder
    case_type?: SortOrder
    case_name?: SortOrder
    sort_order?: SortOrder
    is_executed?: SortOrder
    execution_result?: SortOrder
    created_at?: SortOrder
  }

  export type test_plan_casesMinOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    case_id?: SortOrder
    case_type?: SortOrder
    case_name?: SortOrder
    sort_order?: SortOrder
    is_executed?: SortOrder
    execution_result?: SortOrder
    created_at?: SortOrder
  }

  export type test_plan_casesSumOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    case_id?: SortOrder
    sort_order?: SortOrder
  }

  export type test_plan_executionsOrderByRelevanceInput = {
    fields: test_plan_executionsOrderByRelevanceFieldEnum | test_plan_executionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type test_plan_executionsCountOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    plan_name?: SortOrder
    executor_id?: SortOrder
    executor_name?: SortOrder
    execution_type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    total_cases?: SortOrder
    completed_cases?: SortOrder
    passed_cases?: SortOrder
    failed_cases?: SortOrder
    blocked_cases?: SortOrder
    skipped_cases?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    duration_ms?: SortOrder
    execution_results?: SortOrder
    error_message?: SortOrder
    metadata?: SortOrder
  }

  export type test_plan_executionsAvgOrderByAggregateInput = {
    plan_id?: SortOrder
    executor_id?: SortOrder
    progress?: SortOrder
    total_cases?: SortOrder
    completed_cases?: SortOrder
    passed_cases?: SortOrder
    failed_cases?: SortOrder
    blocked_cases?: SortOrder
    skipped_cases?: SortOrder
    duration_ms?: SortOrder
  }

  export type test_plan_executionsMaxOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    plan_name?: SortOrder
    executor_id?: SortOrder
    executor_name?: SortOrder
    execution_type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    total_cases?: SortOrder
    completed_cases?: SortOrder
    passed_cases?: SortOrder
    failed_cases?: SortOrder
    blocked_cases?: SortOrder
    skipped_cases?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    duration_ms?: SortOrder
    error_message?: SortOrder
  }

  export type test_plan_executionsMinOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    plan_name?: SortOrder
    executor_id?: SortOrder
    executor_name?: SortOrder
    execution_type?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    total_cases?: SortOrder
    completed_cases?: SortOrder
    passed_cases?: SortOrder
    failed_cases?: SortOrder
    blocked_cases?: SortOrder
    skipped_cases?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    duration_ms?: SortOrder
    error_message?: SortOrder
  }

  export type test_plan_executionsSumOrderByAggregateInput = {
    plan_id?: SortOrder
    executor_id?: SortOrder
    progress?: SortOrder
    total_cases?: SortOrder
    completed_cases?: SortOrder
    passed_cases?: SortOrder
    failed_cases?: SortOrder
    blocked_cases?: SortOrder
    skipped_cases?: SortOrder
    duration_ms?: SortOrder
  }

  export type ai_element_cacheOrderByRelevanceInput = {
    fields: ai_element_cacheOrderByRelevanceFieldEnum | ai_element_cacheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ai_element_cacheCountOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    url?: SortOrder
    selector?: SortOrder
    snapshot_fp?: SortOrder
    element_ref?: SortOrder
    element_text?: SortOrder
    confidence?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_element_cacheAvgOrderByAggregateInput = {
    id?: SortOrder
    confidence?: SortOrder
    hit_count?: SortOrder
  }

  export type ai_element_cacheMaxOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    url?: SortOrder
    selector?: SortOrder
    snapshot_fp?: SortOrder
    element_ref?: SortOrder
    element_text?: SortOrder
    confidence?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_element_cacheMinOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    url?: SortOrder
    selector?: SortOrder
    snapshot_fp?: SortOrder
    element_ref?: SortOrder
    element_text?: SortOrder
    confidence?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_element_cacheSumOrderByAggregateInput = {
    id?: SortOrder
    confidence?: SortOrder
    hit_count?: SortOrder
  }

  export type ai_assertion_cacheOrderByRelevanceInput = {
    fields: ai_assertion_cacheOrderByRelevanceFieldEnum | ai_assertion_cacheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ai_assertion_cacheCountOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    assertion_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    command_args?: SortOrder
    assertion_info?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_assertion_cacheAvgOrderByAggregateInput = {
    id?: SortOrder
    hit_count?: SortOrder
  }

  export type ai_assertion_cacheMaxOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    assertion_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_assertion_cacheMinOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    assertion_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_assertion_cacheSumOrderByAggregateInput = {
    id?: SortOrder
    hit_count?: SortOrder
  }

  export type ai_operation_cacheOrderByRelevanceInput = {
    fields: ai_operation_cacheOrderByRelevanceFieldEnum | ai_operation_cacheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ai_operation_cacheCountOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    operation_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    command_args?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_operation_cacheAvgOrderByAggregateInput = {
    id?: SortOrder
    hit_count?: SortOrder
  }

  export type ai_operation_cacheMaxOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    operation_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_operation_cacheMinOrderByAggregateInput = {
    id?: SortOrder
    cache_key?: SortOrder
    operation_desc?: SortOrder
    page_elements_fp?: SortOrder
    command_name?: SortOrder
    hit_count?: SortOrder
    last_hit_at?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_operation_cacheSumOrderByAggregateInput = {
    id?: SortOrder
    hit_count?: SortOrder
  }

  export type ai_runsCreateNestedManyWithoutAi_promptsInput = {
    create?: XOR<ai_runsCreateWithoutAi_promptsInput, ai_runsUncheckedCreateWithoutAi_promptsInput> | ai_runsCreateWithoutAi_promptsInput[] | ai_runsUncheckedCreateWithoutAi_promptsInput[]
    connectOrCreate?: ai_runsCreateOrConnectWithoutAi_promptsInput | ai_runsCreateOrConnectWithoutAi_promptsInput[]
    createMany?: ai_runsCreateManyAi_promptsInputEnvelope
    connect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
  }

  export type ai_runsUncheckedCreateNestedManyWithoutAi_promptsInput = {
    create?: XOR<ai_runsCreateWithoutAi_promptsInput, ai_runsUncheckedCreateWithoutAi_promptsInput> | ai_runsCreateWithoutAi_promptsInput[] | ai_runsUncheckedCreateWithoutAi_promptsInput[]
    connectOrCreate?: ai_runsCreateOrConnectWithoutAi_promptsInput | ai_runsCreateOrConnectWithoutAi_promptsInput[]
    createMany?: ai_runsCreateManyAi_promptsInputEnvelope
    connect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ai_runsUpdateManyWithoutAi_promptsNestedInput = {
    create?: XOR<ai_runsCreateWithoutAi_promptsInput, ai_runsUncheckedCreateWithoutAi_promptsInput> | ai_runsCreateWithoutAi_promptsInput[] | ai_runsUncheckedCreateWithoutAi_promptsInput[]
    connectOrCreate?: ai_runsCreateOrConnectWithoutAi_promptsInput | ai_runsCreateOrConnectWithoutAi_promptsInput[]
    upsert?: ai_runsUpsertWithWhereUniqueWithoutAi_promptsInput | ai_runsUpsertWithWhereUniqueWithoutAi_promptsInput[]
    createMany?: ai_runsCreateManyAi_promptsInputEnvelope
    set?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    disconnect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    delete?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    connect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    update?: ai_runsUpdateWithWhereUniqueWithoutAi_promptsInput | ai_runsUpdateWithWhereUniqueWithoutAi_promptsInput[]
    updateMany?: ai_runsUpdateManyWithWhereWithoutAi_promptsInput | ai_runsUpdateManyWithWhereWithoutAi_promptsInput[]
    deleteMany?: ai_runsScalarWhereInput | ai_runsScalarWhereInput[]
  }

  export type ai_runsUncheckedUpdateManyWithoutAi_promptsNestedInput = {
    create?: XOR<ai_runsCreateWithoutAi_promptsInput, ai_runsUncheckedCreateWithoutAi_promptsInput> | ai_runsCreateWithoutAi_promptsInput[] | ai_runsUncheckedCreateWithoutAi_promptsInput[]
    connectOrCreate?: ai_runsCreateOrConnectWithoutAi_promptsInput | ai_runsCreateOrConnectWithoutAi_promptsInput[]
    upsert?: ai_runsUpsertWithWhereUniqueWithoutAi_promptsInput | ai_runsUpsertWithWhereUniqueWithoutAi_promptsInput[]
    createMany?: ai_runsCreateManyAi_promptsInputEnvelope
    set?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    disconnect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    delete?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    connect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    update?: ai_runsUpdateWithWhereUniqueWithoutAi_promptsInput | ai_runsUpdateWithWhereUniqueWithoutAi_promptsInput[]
    updateMany?: ai_runsUpdateManyWithWhereWithoutAi_promptsInput | ai_runsUpdateManyWithWhereWithoutAi_promptsInput[]
    deleteMany?: ai_runsScalarWhereInput | ai_runsScalarWhereInput[]
  }

  export type ai_promptsCreateNestedOneWithoutAi_runsInput = {
    create?: XOR<ai_promptsCreateWithoutAi_runsInput, ai_promptsUncheckedCreateWithoutAi_runsInput>
    connectOrCreate?: ai_promptsCreateOrConnectWithoutAi_runsInput
    connect?: ai_promptsWhereUniqueInput
  }

  export type test_runsCreateNestedOneWithoutAi_runsInput = {
    create?: XOR<test_runsCreateWithoutAi_runsInput, test_runsUncheckedCreateWithoutAi_runsInput>
    connectOrCreate?: test_runsCreateOrConnectWithoutAi_runsInput
    connect?: test_runsWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ai_promptsUpdateOneRequiredWithoutAi_runsNestedInput = {
    create?: XOR<ai_promptsCreateWithoutAi_runsInput, ai_promptsUncheckedCreateWithoutAi_runsInput>
    connectOrCreate?: ai_promptsCreateOrConnectWithoutAi_runsInput
    upsert?: ai_promptsUpsertWithoutAi_runsInput
    connect?: ai_promptsWhereUniqueInput
    update?: XOR<XOR<ai_promptsUpdateToOneWithWhereWithoutAi_runsInput, ai_promptsUpdateWithoutAi_runsInput>, ai_promptsUncheckedUpdateWithoutAi_runsInput>
  }

  export type test_runsUpdateOneWithoutAi_runsNestedInput = {
    create?: XOR<test_runsCreateWithoutAi_runsInput, test_runsUncheckedCreateWithoutAi_runsInput>
    connectOrCreate?: test_runsCreateOrConnectWithoutAi_runsInput
    upsert?: test_runsUpsertWithoutAi_runsInput
    disconnect?: test_runsWhereInput | boolean
    delete?: test_runsWhereInput | boolean
    connect?: test_runsWhereUniqueInput
    update?: XOR<XOR<test_runsUpdateToOneWithWhereWithoutAi_runsInput, test_runsUpdateWithoutAi_runsInput>, test_runsUncheckedUpdateWithoutAi_runsInput>
  }

  export type usersCreateNestedOneWithoutApi_tokensInput = {
    create?: XOR<usersCreateWithoutApi_tokensInput, usersUncheckedCreateWithoutApi_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutApi_tokensInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutApi_tokensNestedInput = {
    create?: XOR<usersCreateWithoutApi_tokensInput, usersUncheckedCreateWithoutApi_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutApi_tokensInput
    upsert?: usersUpsertWithoutApi_tokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutApi_tokensInput, usersUpdateWithoutApi_tokensInput>, usersUncheckedUpdateWithoutApi_tokensInput>
  }

  export type test_run_resultsCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<test_run_resultsCreateWithoutAttachmentsInput, test_run_resultsUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutAttachmentsInput
    connect?: test_run_resultsWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type test_run_resultsUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<test_run_resultsCreateWithoutAttachmentsInput, test_run_resultsUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutAttachmentsInput
    upsert?: test_run_resultsUpsertWithoutAttachmentsInput
    connect?: test_run_resultsWhereUniqueInput
    update?: XOR<XOR<test_run_resultsUpdateToOneWithWhereWithoutAttachmentsInput, test_run_resultsUpdateWithoutAttachmentsInput>, test_run_resultsUncheckedUpdateWithoutAttachmentsInput>
  }

  export type usersCreateNestedOneWithoutAudit_logsInput = {
    create?: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAudit_logsInput
    connect?: usersWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type usersUpdateOneWithoutAudit_logsNestedInput = {
    create?: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAudit_logsInput
    upsert?: usersUpsertWithoutAudit_logsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAudit_logsInput, usersUpdateWithoutAudit_logsInput>, usersUncheckedUpdateWithoutAudit_logsInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type Enumjob_logs_statusFieldUpdateOperationsInput = {
    set?: $Enums.job_logs_status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type test_runsCreateNestedOneWithoutReportsInput = {
    create?: XOR<test_runsCreateWithoutReportsInput, test_runsUncheckedCreateWithoutReportsInput>
    connectOrCreate?: test_runsCreateOrConnectWithoutReportsInput
    connect?: test_runsWhereUniqueInput
  }

  export type test_runsUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<test_runsCreateWithoutReportsInput, test_runsUncheckedCreateWithoutReportsInput>
    connectOrCreate?: test_runsCreateOrConnectWithoutReportsInput
    upsert?: test_runsUpsertWithoutReportsInput
    connect?: test_runsWhereUniqueInput
    update?: XOR<XOR<test_runsUpdateToOneWithWhereWithoutReportsInput, test_runsUpdateWithoutReportsInput>, test_runsUncheckedUpdateWithoutReportsInput>
  }

  export type user_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRolesInput | user_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRolesInput | user_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRolesInput | user_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRolesInput | user_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRolesInput | user_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRolesInput | user_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type test_casesCreateNestedOneWithoutStep_screenshotsInput = {
    create?: XOR<test_casesCreateWithoutStep_screenshotsInput, test_casesUncheckedCreateWithoutStep_screenshotsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutStep_screenshotsInput
    connect?: test_casesWhereUniqueInput
  }

  export type Enumstep_screenshots_statusFieldUpdateOperationsInput = {
    set?: $Enums.step_screenshots_status
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type test_casesUpdateOneWithoutStep_screenshotsNestedInput = {
    create?: XOR<test_casesCreateWithoutStep_screenshotsInput, test_casesUncheckedCreateWithoutStep_screenshotsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutStep_screenshotsInput
    upsert?: test_casesUpsertWithoutStep_screenshotsInput
    disconnect?: test_casesWhereInput | boolean
    delete?: test_casesWhereInput | boolean
    connect?: test_casesWhereUniqueInput
    update?: XOR<XOR<test_casesUpdateToOneWithWhereWithoutStep_screenshotsInput, test_casesUpdateWithoutStep_screenshotsInput>, test_casesUncheckedUpdateWithoutStep_screenshotsInput>
  }

  export type test_suitesCreateNestedOneWithoutSuite_case_mapInput = {
    create?: XOR<test_suitesCreateWithoutSuite_case_mapInput, test_suitesUncheckedCreateWithoutSuite_case_mapInput>
    connectOrCreate?: test_suitesCreateOrConnectWithoutSuite_case_mapInput
    connect?: test_suitesWhereUniqueInput
  }

  export type test_casesCreateNestedOneWithoutSuite_case_mapInput = {
    create?: XOR<test_casesCreateWithoutSuite_case_mapInput, test_casesUncheckedCreateWithoutSuite_case_mapInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutSuite_case_mapInput
    connect?: test_casesWhereUniqueInput
  }

  export type test_suitesUpdateOneRequiredWithoutSuite_case_mapNestedInput = {
    create?: XOR<test_suitesCreateWithoutSuite_case_mapInput, test_suitesUncheckedCreateWithoutSuite_case_mapInput>
    connectOrCreate?: test_suitesCreateOrConnectWithoutSuite_case_mapInput
    upsert?: test_suitesUpsertWithoutSuite_case_mapInput
    connect?: test_suitesWhereUniqueInput
    update?: XOR<XOR<test_suitesUpdateToOneWithWhereWithoutSuite_case_mapInput, test_suitesUpdateWithoutSuite_case_mapInput>, test_suitesUncheckedUpdateWithoutSuite_case_mapInput>
  }

  export type test_casesUpdateOneRequiredWithoutSuite_case_mapNestedInput = {
    create?: XOR<test_casesCreateWithoutSuite_case_mapInput, test_casesUncheckedCreateWithoutSuite_case_mapInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutSuite_case_mapInput
    upsert?: test_casesUpsertWithoutSuite_case_mapInput
    connect?: test_casesWhereUniqueInput
    update?: XOR<XOR<test_casesUpdateToOneWithWhereWithoutSuite_case_mapInput, test_casesUpdateWithoutSuite_case_mapInput>, test_casesUncheckedUpdateWithoutSuite_case_mapInput>
  }

  export type case_patch_proposalsCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<case_patch_proposalsCreateWithoutTest_casesInput, case_patch_proposalsUncheckedCreateWithoutTest_casesInput> | case_patch_proposalsCreateWithoutTest_casesInput[] | case_patch_proposalsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: case_patch_proposalsCreateOrConnectWithoutTest_casesInput | case_patch_proposalsCreateOrConnectWithoutTest_casesInput[]
    createMany?: case_patch_proposalsCreateManyTest_casesInputEnvelope
    connect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
  }

  export type case_versionsCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<case_versionsCreateWithoutTest_casesInput, case_versionsUncheckedCreateWithoutTest_casesInput> | case_versionsCreateWithoutTest_casesInput[] | case_versionsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: case_versionsCreateOrConnectWithoutTest_casesInput | case_versionsCreateOrConnectWithoutTest_casesInput[]
    createMany?: case_versionsCreateManyTest_casesInputEnvelope
    connect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
  }

  export type step_screenshotsCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<step_screenshotsCreateWithoutTest_casesInput, step_screenshotsUncheckedCreateWithoutTest_casesInput> | step_screenshotsCreateWithoutTest_casesInput[] | step_screenshotsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: step_screenshotsCreateOrConnectWithoutTest_casesInput | step_screenshotsCreateOrConnectWithoutTest_casesInput[]
    createMany?: step_screenshotsCreateManyTest_casesInputEnvelope
    connect?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
  }

  export type suite_case_mapCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<suite_case_mapCreateWithoutTest_casesInput, suite_case_mapUncheckedCreateWithoutTest_casesInput> | suite_case_mapCreateWithoutTest_casesInput[] | suite_case_mapUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: suite_case_mapCreateOrConnectWithoutTest_casesInput | suite_case_mapCreateOrConnectWithoutTest_casesInput[]
    createMany?: suite_case_mapCreateManyTest_casesInputEnvelope
    connect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
  }

  export type test_case_executionsCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<test_case_executionsCreateWithoutTest_casesInput, test_case_executionsUncheckedCreateWithoutTest_casesInput> | test_case_executionsCreateWithoutTest_casesInput[] | test_case_executionsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: test_case_executionsCreateOrConnectWithoutTest_casesInput | test_case_executionsCreateOrConnectWithoutTest_casesInput[]
    createMany?: test_case_executionsCreateManyTest_casesInputEnvelope
    connect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
  }

  export type test_run_resultsCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<test_run_resultsCreateWithoutTest_casesInput, test_run_resultsUncheckedCreateWithoutTest_casesInput> | test_run_resultsCreateWithoutTest_casesInput[] | test_run_resultsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutTest_casesInput | test_run_resultsCreateOrConnectWithoutTest_casesInput[]
    createMany?: test_run_resultsCreateManyTest_casesInputEnvelope
    connect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
  }

  export type case_patch_proposalsUncheckedCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<case_patch_proposalsCreateWithoutTest_casesInput, case_patch_proposalsUncheckedCreateWithoutTest_casesInput> | case_patch_proposalsCreateWithoutTest_casesInput[] | case_patch_proposalsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: case_patch_proposalsCreateOrConnectWithoutTest_casesInput | case_patch_proposalsCreateOrConnectWithoutTest_casesInput[]
    createMany?: case_patch_proposalsCreateManyTest_casesInputEnvelope
    connect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
  }

  export type case_versionsUncheckedCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<case_versionsCreateWithoutTest_casesInput, case_versionsUncheckedCreateWithoutTest_casesInput> | case_versionsCreateWithoutTest_casesInput[] | case_versionsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: case_versionsCreateOrConnectWithoutTest_casesInput | case_versionsCreateOrConnectWithoutTest_casesInput[]
    createMany?: case_versionsCreateManyTest_casesInputEnvelope
    connect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
  }

  export type step_screenshotsUncheckedCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<step_screenshotsCreateWithoutTest_casesInput, step_screenshotsUncheckedCreateWithoutTest_casesInput> | step_screenshotsCreateWithoutTest_casesInput[] | step_screenshotsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: step_screenshotsCreateOrConnectWithoutTest_casesInput | step_screenshotsCreateOrConnectWithoutTest_casesInput[]
    createMany?: step_screenshotsCreateManyTest_casesInputEnvelope
    connect?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
  }

  export type suite_case_mapUncheckedCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<suite_case_mapCreateWithoutTest_casesInput, suite_case_mapUncheckedCreateWithoutTest_casesInput> | suite_case_mapCreateWithoutTest_casesInput[] | suite_case_mapUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: suite_case_mapCreateOrConnectWithoutTest_casesInput | suite_case_mapCreateOrConnectWithoutTest_casesInput[]
    createMany?: suite_case_mapCreateManyTest_casesInputEnvelope
    connect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
  }

  export type test_case_executionsUncheckedCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<test_case_executionsCreateWithoutTest_casesInput, test_case_executionsUncheckedCreateWithoutTest_casesInput> | test_case_executionsCreateWithoutTest_casesInput[] | test_case_executionsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: test_case_executionsCreateOrConnectWithoutTest_casesInput | test_case_executionsCreateOrConnectWithoutTest_casesInput[]
    createMany?: test_case_executionsCreateManyTest_casesInputEnvelope
    connect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
  }

  export type test_run_resultsUncheckedCreateNestedManyWithoutTest_casesInput = {
    create?: XOR<test_run_resultsCreateWithoutTest_casesInput, test_run_resultsUncheckedCreateWithoutTest_casesInput> | test_run_resultsCreateWithoutTest_casesInput[] | test_run_resultsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutTest_casesInput | test_run_resultsCreateOrConnectWithoutTest_casesInput[]
    createMany?: test_run_resultsCreateManyTest_casesInputEnvelope
    connect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
  }

  export type case_patch_proposalsUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<case_patch_proposalsCreateWithoutTest_casesInput, case_patch_proposalsUncheckedCreateWithoutTest_casesInput> | case_patch_proposalsCreateWithoutTest_casesInput[] | case_patch_proposalsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: case_patch_proposalsCreateOrConnectWithoutTest_casesInput | case_patch_proposalsCreateOrConnectWithoutTest_casesInput[]
    upsert?: case_patch_proposalsUpsertWithWhereUniqueWithoutTest_casesInput | case_patch_proposalsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: case_patch_proposalsCreateManyTest_casesInputEnvelope
    set?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    disconnect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    delete?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    connect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    update?: case_patch_proposalsUpdateWithWhereUniqueWithoutTest_casesInput | case_patch_proposalsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: case_patch_proposalsUpdateManyWithWhereWithoutTest_casesInput | case_patch_proposalsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: case_patch_proposalsScalarWhereInput | case_patch_proposalsScalarWhereInput[]
  }

  export type case_versionsUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<case_versionsCreateWithoutTest_casesInput, case_versionsUncheckedCreateWithoutTest_casesInput> | case_versionsCreateWithoutTest_casesInput[] | case_versionsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: case_versionsCreateOrConnectWithoutTest_casesInput | case_versionsCreateOrConnectWithoutTest_casesInput[]
    upsert?: case_versionsUpsertWithWhereUniqueWithoutTest_casesInput | case_versionsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: case_versionsCreateManyTest_casesInputEnvelope
    set?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    disconnect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    delete?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    connect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    update?: case_versionsUpdateWithWhereUniqueWithoutTest_casesInput | case_versionsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: case_versionsUpdateManyWithWhereWithoutTest_casesInput | case_versionsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: case_versionsScalarWhereInput | case_versionsScalarWhereInput[]
  }

  export type step_screenshotsUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<step_screenshotsCreateWithoutTest_casesInput, step_screenshotsUncheckedCreateWithoutTest_casesInput> | step_screenshotsCreateWithoutTest_casesInput[] | step_screenshotsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: step_screenshotsCreateOrConnectWithoutTest_casesInput | step_screenshotsCreateOrConnectWithoutTest_casesInput[]
    upsert?: step_screenshotsUpsertWithWhereUniqueWithoutTest_casesInput | step_screenshotsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: step_screenshotsCreateManyTest_casesInputEnvelope
    set?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
    disconnect?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
    delete?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
    connect?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
    update?: step_screenshotsUpdateWithWhereUniqueWithoutTest_casesInput | step_screenshotsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: step_screenshotsUpdateManyWithWhereWithoutTest_casesInput | step_screenshotsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: step_screenshotsScalarWhereInput | step_screenshotsScalarWhereInput[]
  }

  export type suite_case_mapUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<suite_case_mapCreateWithoutTest_casesInput, suite_case_mapUncheckedCreateWithoutTest_casesInput> | suite_case_mapCreateWithoutTest_casesInput[] | suite_case_mapUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: suite_case_mapCreateOrConnectWithoutTest_casesInput | suite_case_mapCreateOrConnectWithoutTest_casesInput[]
    upsert?: suite_case_mapUpsertWithWhereUniqueWithoutTest_casesInput | suite_case_mapUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: suite_case_mapCreateManyTest_casesInputEnvelope
    set?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    disconnect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    delete?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    connect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    update?: suite_case_mapUpdateWithWhereUniqueWithoutTest_casesInput | suite_case_mapUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: suite_case_mapUpdateManyWithWhereWithoutTest_casesInput | suite_case_mapUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: suite_case_mapScalarWhereInput | suite_case_mapScalarWhereInput[]
  }

  export type test_case_executionsUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<test_case_executionsCreateWithoutTest_casesInput, test_case_executionsUncheckedCreateWithoutTest_casesInput> | test_case_executionsCreateWithoutTest_casesInput[] | test_case_executionsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: test_case_executionsCreateOrConnectWithoutTest_casesInput | test_case_executionsCreateOrConnectWithoutTest_casesInput[]
    upsert?: test_case_executionsUpsertWithWhereUniqueWithoutTest_casesInput | test_case_executionsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: test_case_executionsCreateManyTest_casesInputEnvelope
    set?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    disconnect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    delete?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    connect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    update?: test_case_executionsUpdateWithWhereUniqueWithoutTest_casesInput | test_case_executionsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: test_case_executionsUpdateManyWithWhereWithoutTest_casesInput | test_case_executionsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: test_case_executionsScalarWhereInput | test_case_executionsScalarWhereInput[]
  }

  export type test_run_resultsUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<test_run_resultsCreateWithoutTest_casesInput, test_run_resultsUncheckedCreateWithoutTest_casesInput> | test_run_resultsCreateWithoutTest_casesInput[] | test_run_resultsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutTest_casesInput | test_run_resultsCreateOrConnectWithoutTest_casesInput[]
    upsert?: test_run_resultsUpsertWithWhereUniqueWithoutTest_casesInput | test_run_resultsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: test_run_resultsCreateManyTest_casesInputEnvelope
    set?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    disconnect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    delete?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    connect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    update?: test_run_resultsUpdateWithWhereUniqueWithoutTest_casesInput | test_run_resultsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: test_run_resultsUpdateManyWithWhereWithoutTest_casesInput | test_run_resultsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: test_run_resultsScalarWhereInput | test_run_resultsScalarWhereInput[]
  }

  export type case_patch_proposalsUncheckedUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<case_patch_proposalsCreateWithoutTest_casesInput, case_patch_proposalsUncheckedCreateWithoutTest_casesInput> | case_patch_proposalsCreateWithoutTest_casesInput[] | case_patch_proposalsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: case_patch_proposalsCreateOrConnectWithoutTest_casesInput | case_patch_proposalsCreateOrConnectWithoutTest_casesInput[]
    upsert?: case_patch_proposalsUpsertWithWhereUniqueWithoutTest_casesInput | case_patch_proposalsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: case_patch_proposalsCreateManyTest_casesInputEnvelope
    set?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    disconnect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    delete?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    connect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    update?: case_patch_proposalsUpdateWithWhereUniqueWithoutTest_casesInput | case_patch_proposalsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: case_patch_proposalsUpdateManyWithWhereWithoutTest_casesInput | case_patch_proposalsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: case_patch_proposalsScalarWhereInput | case_patch_proposalsScalarWhereInput[]
  }

  export type case_versionsUncheckedUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<case_versionsCreateWithoutTest_casesInput, case_versionsUncheckedCreateWithoutTest_casesInput> | case_versionsCreateWithoutTest_casesInput[] | case_versionsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: case_versionsCreateOrConnectWithoutTest_casesInput | case_versionsCreateOrConnectWithoutTest_casesInput[]
    upsert?: case_versionsUpsertWithWhereUniqueWithoutTest_casesInput | case_versionsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: case_versionsCreateManyTest_casesInputEnvelope
    set?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    disconnect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    delete?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    connect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    update?: case_versionsUpdateWithWhereUniqueWithoutTest_casesInput | case_versionsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: case_versionsUpdateManyWithWhereWithoutTest_casesInput | case_versionsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: case_versionsScalarWhereInput | case_versionsScalarWhereInput[]
  }

  export type step_screenshotsUncheckedUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<step_screenshotsCreateWithoutTest_casesInput, step_screenshotsUncheckedCreateWithoutTest_casesInput> | step_screenshotsCreateWithoutTest_casesInput[] | step_screenshotsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: step_screenshotsCreateOrConnectWithoutTest_casesInput | step_screenshotsCreateOrConnectWithoutTest_casesInput[]
    upsert?: step_screenshotsUpsertWithWhereUniqueWithoutTest_casesInput | step_screenshotsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: step_screenshotsCreateManyTest_casesInputEnvelope
    set?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
    disconnect?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
    delete?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
    connect?: step_screenshotsWhereUniqueInput | step_screenshotsWhereUniqueInput[]
    update?: step_screenshotsUpdateWithWhereUniqueWithoutTest_casesInput | step_screenshotsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: step_screenshotsUpdateManyWithWhereWithoutTest_casesInput | step_screenshotsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: step_screenshotsScalarWhereInput | step_screenshotsScalarWhereInput[]
  }

  export type suite_case_mapUncheckedUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<suite_case_mapCreateWithoutTest_casesInput, suite_case_mapUncheckedCreateWithoutTest_casesInput> | suite_case_mapCreateWithoutTest_casesInput[] | suite_case_mapUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: suite_case_mapCreateOrConnectWithoutTest_casesInput | suite_case_mapCreateOrConnectWithoutTest_casesInput[]
    upsert?: suite_case_mapUpsertWithWhereUniqueWithoutTest_casesInput | suite_case_mapUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: suite_case_mapCreateManyTest_casesInputEnvelope
    set?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    disconnect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    delete?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    connect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    update?: suite_case_mapUpdateWithWhereUniqueWithoutTest_casesInput | suite_case_mapUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: suite_case_mapUpdateManyWithWhereWithoutTest_casesInput | suite_case_mapUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: suite_case_mapScalarWhereInput | suite_case_mapScalarWhereInput[]
  }

  export type test_case_executionsUncheckedUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<test_case_executionsCreateWithoutTest_casesInput, test_case_executionsUncheckedCreateWithoutTest_casesInput> | test_case_executionsCreateWithoutTest_casesInput[] | test_case_executionsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: test_case_executionsCreateOrConnectWithoutTest_casesInput | test_case_executionsCreateOrConnectWithoutTest_casesInput[]
    upsert?: test_case_executionsUpsertWithWhereUniqueWithoutTest_casesInput | test_case_executionsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: test_case_executionsCreateManyTest_casesInputEnvelope
    set?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    disconnect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    delete?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    connect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    update?: test_case_executionsUpdateWithWhereUniqueWithoutTest_casesInput | test_case_executionsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: test_case_executionsUpdateManyWithWhereWithoutTest_casesInput | test_case_executionsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: test_case_executionsScalarWhereInput | test_case_executionsScalarWhereInput[]
  }

  export type test_run_resultsUncheckedUpdateManyWithoutTest_casesNestedInput = {
    create?: XOR<test_run_resultsCreateWithoutTest_casesInput, test_run_resultsUncheckedCreateWithoutTest_casesInput> | test_run_resultsCreateWithoutTest_casesInput[] | test_run_resultsUncheckedCreateWithoutTest_casesInput[]
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutTest_casesInput | test_run_resultsCreateOrConnectWithoutTest_casesInput[]
    upsert?: test_run_resultsUpsertWithWhereUniqueWithoutTest_casesInput | test_run_resultsUpsertWithWhereUniqueWithoutTest_casesInput[]
    createMany?: test_run_resultsCreateManyTest_casesInputEnvelope
    set?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    disconnect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    delete?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    connect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    update?: test_run_resultsUpdateWithWhereUniqueWithoutTest_casesInput | test_run_resultsUpdateWithWhereUniqueWithoutTest_casesInput[]
    updateMany?: test_run_resultsUpdateManyWithWhereWithoutTest_casesInput | test_run_resultsUpdateManyWithWhereWithoutTest_casesInput[]
    deleteMany?: test_run_resultsScalarWhereInput | test_run_resultsScalarWhereInput[]
  }

  export type attachmentsCreateNestedManyWithoutTest_run_resultsInput = {
    create?: XOR<attachmentsCreateWithoutTest_run_resultsInput, attachmentsUncheckedCreateWithoutTest_run_resultsInput> | attachmentsCreateWithoutTest_run_resultsInput[] | attachmentsUncheckedCreateWithoutTest_run_resultsInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutTest_run_resultsInput | attachmentsCreateOrConnectWithoutTest_run_resultsInput[]
    createMany?: attachmentsCreateManyTest_run_resultsInputEnvelope
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
  }

  export type test_runsCreateNestedOneWithoutTest_run_resultsInput = {
    create?: XOR<test_runsCreateWithoutTest_run_resultsInput, test_runsUncheckedCreateWithoutTest_run_resultsInput>
    connectOrCreate?: test_runsCreateOrConnectWithoutTest_run_resultsInput
    connect?: test_runsWhereUniqueInput
  }

  export type test_casesCreateNestedOneWithoutTest_run_resultsInput = {
    create?: XOR<test_casesCreateWithoutTest_run_resultsInput, test_casesUncheckedCreateWithoutTest_run_resultsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutTest_run_resultsInput
    connect?: test_casesWhereUniqueInput
  }

  export type attachmentsUncheckedCreateNestedManyWithoutTest_run_resultsInput = {
    create?: XOR<attachmentsCreateWithoutTest_run_resultsInput, attachmentsUncheckedCreateWithoutTest_run_resultsInput> | attachmentsCreateWithoutTest_run_resultsInput[] | attachmentsUncheckedCreateWithoutTest_run_resultsInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutTest_run_resultsInput | attachmentsCreateOrConnectWithoutTest_run_resultsInput[]
    createMany?: attachmentsCreateManyTest_run_resultsInputEnvelope
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
  }

  export type Enumtest_run_results_statusFieldUpdateOperationsInput = {
    set?: $Enums.test_run_results_status
  }

  export type attachmentsUpdateManyWithoutTest_run_resultsNestedInput = {
    create?: XOR<attachmentsCreateWithoutTest_run_resultsInput, attachmentsUncheckedCreateWithoutTest_run_resultsInput> | attachmentsCreateWithoutTest_run_resultsInput[] | attachmentsUncheckedCreateWithoutTest_run_resultsInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutTest_run_resultsInput | attachmentsCreateOrConnectWithoutTest_run_resultsInput[]
    upsert?: attachmentsUpsertWithWhereUniqueWithoutTest_run_resultsInput | attachmentsUpsertWithWhereUniqueWithoutTest_run_resultsInput[]
    createMany?: attachmentsCreateManyTest_run_resultsInputEnvelope
    set?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    disconnect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    delete?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    update?: attachmentsUpdateWithWhereUniqueWithoutTest_run_resultsInput | attachmentsUpdateWithWhereUniqueWithoutTest_run_resultsInput[]
    updateMany?: attachmentsUpdateManyWithWhereWithoutTest_run_resultsInput | attachmentsUpdateManyWithWhereWithoutTest_run_resultsInput[]
    deleteMany?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
  }

  export type test_runsUpdateOneRequiredWithoutTest_run_resultsNestedInput = {
    create?: XOR<test_runsCreateWithoutTest_run_resultsInput, test_runsUncheckedCreateWithoutTest_run_resultsInput>
    connectOrCreate?: test_runsCreateOrConnectWithoutTest_run_resultsInput
    upsert?: test_runsUpsertWithoutTest_run_resultsInput
    connect?: test_runsWhereUniqueInput
    update?: XOR<XOR<test_runsUpdateToOneWithWhereWithoutTest_run_resultsInput, test_runsUpdateWithoutTest_run_resultsInput>, test_runsUncheckedUpdateWithoutTest_run_resultsInput>
  }

  export type test_casesUpdateOneRequiredWithoutTest_run_resultsNestedInput = {
    create?: XOR<test_casesCreateWithoutTest_run_resultsInput, test_casesUncheckedCreateWithoutTest_run_resultsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutTest_run_resultsInput
    upsert?: test_casesUpsertWithoutTest_run_resultsInput
    connect?: test_casesWhereUniqueInput
    update?: XOR<XOR<test_casesUpdateToOneWithWhereWithoutTest_run_resultsInput, test_casesUpdateWithoutTest_run_resultsInput>, test_casesUncheckedUpdateWithoutTest_run_resultsInput>
  }

  export type attachmentsUncheckedUpdateManyWithoutTest_run_resultsNestedInput = {
    create?: XOR<attachmentsCreateWithoutTest_run_resultsInput, attachmentsUncheckedCreateWithoutTest_run_resultsInput> | attachmentsCreateWithoutTest_run_resultsInput[] | attachmentsUncheckedCreateWithoutTest_run_resultsInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutTest_run_resultsInput | attachmentsCreateOrConnectWithoutTest_run_resultsInput[]
    upsert?: attachmentsUpsertWithWhereUniqueWithoutTest_run_resultsInput | attachmentsUpsertWithWhereUniqueWithoutTest_run_resultsInput[]
    createMany?: attachmentsCreateManyTest_run_resultsInputEnvelope
    set?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    disconnect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    delete?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    update?: attachmentsUpdateWithWhereUniqueWithoutTest_run_resultsInput | attachmentsUpdateWithWhereUniqueWithoutTest_run_resultsInput[]
    updateMany?: attachmentsUpdateManyWithWhereWithoutTest_run_resultsInput | attachmentsUpdateManyWithWhereWithoutTest_run_resultsInput[]
    deleteMany?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
  }

  export type ai_runsCreateNestedManyWithoutTest_runsInput = {
    create?: XOR<ai_runsCreateWithoutTest_runsInput, ai_runsUncheckedCreateWithoutTest_runsInput> | ai_runsCreateWithoutTest_runsInput[] | ai_runsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: ai_runsCreateOrConnectWithoutTest_runsInput | ai_runsCreateOrConnectWithoutTest_runsInput[]
    createMany?: ai_runsCreateManyTest_runsInputEnvelope
    connect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
  }

  export type reportsCreateNestedManyWithoutTest_runsInput = {
    create?: XOR<reportsCreateWithoutTest_runsInput, reportsUncheckedCreateWithoutTest_runsInput> | reportsCreateWithoutTest_runsInput[] | reportsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: reportsCreateOrConnectWithoutTest_runsInput | reportsCreateOrConnectWithoutTest_runsInput[]
    createMany?: reportsCreateManyTest_runsInputEnvelope
    connect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
  }

  export type test_run_resultsCreateNestedManyWithoutTest_runsInput = {
    create?: XOR<test_run_resultsCreateWithoutTest_runsInput, test_run_resultsUncheckedCreateWithoutTest_runsInput> | test_run_resultsCreateWithoutTest_runsInput[] | test_run_resultsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutTest_runsInput | test_run_resultsCreateOrConnectWithoutTest_runsInput[]
    createMany?: test_run_resultsCreateManyTest_runsInputEnvelope
    connect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
  }

  export type test_suitesCreateNestedOneWithoutTest_runsInput = {
    create?: XOR<test_suitesCreateWithoutTest_runsInput, test_suitesUncheckedCreateWithoutTest_runsInput>
    connectOrCreate?: test_suitesCreateOrConnectWithoutTest_runsInput
    connect?: test_suitesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTest_runsInput = {
    create?: XOR<usersCreateWithoutTest_runsInput, usersUncheckedCreateWithoutTest_runsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_runsInput
    connect?: usersWhereUniqueInput
  }

  export type ai_runsUncheckedCreateNestedManyWithoutTest_runsInput = {
    create?: XOR<ai_runsCreateWithoutTest_runsInput, ai_runsUncheckedCreateWithoutTest_runsInput> | ai_runsCreateWithoutTest_runsInput[] | ai_runsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: ai_runsCreateOrConnectWithoutTest_runsInput | ai_runsCreateOrConnectWithoutTest_runsInput[]
    createMany?: ai_runsCreateManyTest_runsInputEnvelope
    connect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
  }

  export type reportsUncheckedCreateNestedManyWithoutTest_runsInput = {
    create?: XOR<reportsCreateWithoutTest_runsInput, reportsUncheckedCreateWithoutTest_runsInput> | reportsCreateWithoutTest_runsInput[] | reportsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: reportsCreateOrConnectWithoutTest_runsInput | reportsCreateOrConnectWithoutTest_runsInput[]
    createMany?: reportsCreateManyTest_runsInputEnvelope
    connect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
  }

  export type test_run_resultsUncheckedCreateNestedManyWithoutTest_runsInput = {
    create?: XOR<test_run_resultsCreateWithoutTest_runsInput, test_run_resultsUncheckedCreateWithoutTest_runsInput> | test_run_resultsCreateWithoutTest_runsInput[] | test_run_resultsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutTest_runsInput | test_run_resultsCreateOrConnectWithoutTest_runsInput[]
    createMany?: test_run_resultsCreateManyTest_runsInputEnvelope
    connect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
  }

  export type Enumtest_runs_statusFieldUpdateOperationsInput = {
    set?: $Enums.test_runs_status
  }

  export type ai_runsUpdateManyWithoutTest_runsNestedInput = {
    create?: XOR<ai_runsCreateWithoutTest_runsInput, ai_runsUncheckedCreateWithoutTest_runsInput> | ai_runsCreateWithoutTest_runsInput[] | ai_runsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: ai_runsCreateOrConnectWithoutTest_runsInput | ai_runsCreateOrConnectWithoutTest_runsInput[]
    upsert?: ai_runsUpsertWithWhereUniqueWithoutTest_runsInput | ai_runsUpsertWithWhereUniqueWithoutTest_runsInput[]
    createMany?: ai_runsCreateManyTest_runsInputEnvelope
    set?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    disconnect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    delete?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    connect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    update?: ai_runsUpdateWithWhereUniqueWithoutTest_runsInput | ai_runsUpdateWithWhereUniqueWithoutTest_runsInput[]
    updateMany?: ai_runsUpdateManyWithWhereWithoutTest_runsInput | ai_runsUpdateManyWithWhereWithoutTest_runsInput[]
    deleteMany?: ai_runsScalarWhereInput | ai_runsScalarWhereInput[]
  }

  export type reportsUpdateManyWithoutTest_runsNestedInput = {
    create?: XOR<reportsCreateWithoutTest_runsInput, reportsUncheckedCreateWithoutTest_runsInput> | reportsCreateWithoutTest_runsInput[] | reportsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: reportsCreateOrConnectWithoutTest_runsInput | reportsCreateOrConnectWithoutTest_runsInput[]
    upsert?: reportsUpsertWithWhereUniqueWithoutTest_runsInput | reportsUpsertWithWhereUniqueWithoutTest_runsInput[]
    createMany?: reportsCreateManyTest_runsInputEnvelope
    set?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    disconnect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    delete?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    connect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    update?: reportsUpdateWithWhereUniqueWithoutTest_runsInput | reportsUpdateWithWhereUniqueWithoutTest_runsInput[]
    updateMany?: reportsUpdateManyWithWhereWithoutTest_runsInput | reportsUpdateManyWithWhereWithoutTest_runsInput[]
    deleteMany?: reportsScalarWhereInput | reportsScalarWhereInput[]
  }

  export type test_run_resultsUpdateManyWithoutTest_runsNestedInput = {
    create?: XOR<test_run_resultsCreateWithoutTest_runsInput, test_run_resultsUncheckedCreateWithoutTest_runsInput> | test_run_resultsCreateWithoutTest_runsInput[] | test_run_resultsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutTest_runsInput | test_run_resultsCreateOrConnectWithoutTest_runsInput[]
    upsert?: test_run_resultsUpsertWithWhereUniqueWithoutTest_runsInput | test_run_resultsUpsertWithWhereUniqueWithoutTest_runsInput[]
    createMany?: test_run_resultsCreateManyTest_runsInputEnvelope
    set?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    disconnect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    delete?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    connect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    update?: test_run_resultsUpdateWithWhereUniqueWithoutTest_runsInput | test_run_resultsUpdateWithWhereUniqueWithoutTest_runsInput[]
    updateMany?: test_run_resultsUpdateManyWithWhereWithoutTest_runsInput | test_run_resultsUpdateManyWithWhereWithoutTest_runsInput[]
    deleteMany?: test_run_resultsScalarWhereInput | test_run_resultsScalarWhereInput[]
  }

  export type test_suitesUpdateOneRequiredWithoutTest_runsNestedInput = {
    create?: XOR<test_suitesCreateWithoutTest_runsInput, test_suitesUncheckedCreateWithoutTest_runsInput>
    connectOrCreate?: test_suitesCreateOrConnectWithoutTest_runsInput
    upsert?: test_suitesUpsertWithoutTest_runsInput
    connect?: test_suitesWhereUniqueInput
    update?: XOR<XOR<test_suitesUpdateToOneWithWhereWithoutTest_runsInput, test_suitesUpdateWithoutTest_runsInput>, test_suitesUncheckedUpdateWithoutTest_runsInput>
  }

  export type usersUpdateOneRequiredWithoutTest_runsNestedInput = {
    create?: XOR<usersCreateWithoutTest_runsInput, usersUncheckedCreateWithoutTest_runsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_runsInput
    upsert?: usersUpsertWithoutTest_runsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTest_runsInput, usersUpdateWithoutTest_runsInput>, usersUncheckedUpdateWithoutTest_runsInput>
  }

  export type ai_runsUncheckedUpdateManyWithoutTest_runsNestedInput = {
    create?: XOR<ai_runsCreateWithoutTest_runsInput, ai_runsUncheckedCreateWithoutTest_runsInput> | ai_runsCreateWithoutTest_runsInput[] | ai_runsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: ai_runsCreateOrConnectWithoutTest_runsInput | ai_runsCreateOrConnectWithoutTest_runsInput[]
    upsert?: ai_runsUpsertWithWhereUniqueWithoutTest_runsInput | ai_runsUpsertWithWhereUniqueWithoutTest_runsInput[]
    createMany?: ai_runsCreateManyTest_runsInputEnvelope
    set?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    disconnect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    delete?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    connect?: ai_runsWhereUniqueInput | ai_runsWhereUniqueInput[]
    update?: ai_runsUpdateWithWhereUniqueWithoutTest_runsInput | ai_runsUpdateWithWhereUniqueWithoutTest_runsInput[]
    updateMany?: ai_runsUpdateManyWithWhereWithoutTest_runsInput | ai_runsUpdateManyWithWhereWithoutTest_runsInput[]
    deleteMany?: ai_runsScalarWhereInput | ai_runsScalarWhereInput[]
  }

  export type reportsUncheckedUpdateManyWithoutTest_runsNestedInput = {
    create?: XOR<reportsCreateWithoutTest_runsInput, reportsUncheckedCreateWithoutTest_runsInput> | reportsCreateWithoutTest_runsInput[] | reportsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: reportsCreateOrConnectWithoutTest_runsInput | reportsCreateOrConnectWithoutTest_runsInput[]
    upsert?: reportsUpsertWithWhereUniqueWithoutTest_runsInput | reportsUpsertWithWhereUniqueWithoutTest_runsInput[]
    createMany?: reportsCreateManyTest_runsInputEnvelope
    set?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    disconnect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    delete?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    connect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    update?: reportsUpdateWithWhereUniqueWithoutTest_runsInput | reportsUpdateWithWhereUniqueWithoutTest_runsInput[]
    updateMany?: reportsUpdateManyWithWhereWithoutTest_runsInput | reportsUpdateManyWithWhereWithoutTest_runsInput[]
    deleteMany?: reportsScalarWhereInput | reportsScalarWhereInput[]
  }

  export type test_run_resultsUncheckedUpdateManyWithoutTest_runsNestedInput = {
    create?: XOR<test_run_resultsCreateWithoutTest_runsInput, test_run_resultsUncheckedCreateWithoutTest_runsInput> | test_run_resultsCreateWithoutTest_runsInput[] | test_run_resultsUncheckedCreateWithoutTest_runsInput[]
    connectOrCreate?: test_run_resultsCreateOrConnectWithoutTest_runsInput | test_run_resultsCreateOrConnectWithoutTest_runsInput[]
    upsert?: test_run_resultsUpsertWithWhereUniqueWithoutTest_runsInput | test_run_resultsUpsertWithWhereUniqueWithoutTest_runsInput[]
    createMany?: test_run_resultsCreateManyTest_runsInputEnvelope
    set?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    disconnect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    delete?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    connect?: test_run_resultsWhereUniqueInput | test_run_resultsWhereUniqueInput[]
    update?: test_run_resultsUpdateWithWhereUniqueWithoutTest_runsInput | test_run_resultsUpdateWithWhereUniqueWithoutTest_runsInput[]
    updateMany?: test_run_resultsUpdateManyWithWhereWithoutTest_runsInput | test_run_resultsUpdateManyWithWhereWithoutTest_runsInput[]
    deleteMany?: test_run_resultsScalarWhereInput | test_run_resultsScalarWhereInput[]
  }

  export type suite_case_mapCreateNestedManyWithoutTest_suitesInput = {
    create?: XOR<suite_case_mapCreateWithoutTest_suitesInput, suite_case_mapUncheckedCreateWithoutTest_suitesInput> | suite_case_mapCreateWithoutTest_suitesInput[] | suite_case_mapUncheckedCreateWithoutTest_suitesInput[]
    connectOrCreate?: suite_case_mapCreateOrConnectWithoutTest_suitesInput | suite_case_mapCreateOrConnectWithoutTest_suitesInput[]
    createMany?: suite_case_mapCreateManyTest_suitesInputEnvelope
    connect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
  }

  export type test_runsCreateNestedManyWithoutTest_suitesInput = {
    create?: XOR<test_runsCreateWithoutTest_suitesInput, test_runsUncheckedCreateWithoutTest_suitesInput> | test_runsCreateWithoutTest_suitesInput[] | test_runsUncheckedCreateWithoutTest_suitesInput[]
    connectOrCreate?: test_runsCreateOrConnectWithoutTest_suitesInput | test_runsCreateOrConnectWithoutTest_suitesInput[]
    createMany?: test_runsCreateManyTest_suitesInputEnvelope
    connect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutTest_suitesInput = {
    create?: XOR<usersCreateWithoutTest_suitesInput, usersUncheckedCreateWithoutTest_suitesInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_suitesInput
    connect?: usersWhereUniqueInput
  }

  export type suite_case_mapUncheckedCreateNestedManyWithoutTest_suitesInput = {
    create?: XOR<suite_case_mapCreateWithoutTest_suitesInput, suite_case_mapUncheckedCreateWithoutTest_suitesInput> | suite_case_mapCreateWithoutTest_suitesInput[] | suite_case_mapUncheckedCreateWithoutTest_suitesInput[]
    connectOrCreate?: suite_case_mapCreateOrConnectWithoutTest_suitesInput | suite_case_mapCreateOrConnectWithoutTest_suitesInput[]
    createMany?: suite_case_mapCreateManyTest_suitesInputEnvelope
    connect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
  }

  export type test_runsUncheckedCreateNestedManyWithoutTest_suitesInput = {
    create?: XOR<test_runsCreateWithoutTest_suitesInput, test_runsUncheckedCreateWithoutTest_suitesInput> | test_runsCreateWithoutTest_suitesInput[] | test_runsUncheckedCreateWithoutTest_suitesInput[]
    connectOrCreate?: test_runsCreateOrConnectWithoutTest_suitesInput | test_runsCreateOrConnectWithoutTest_suitesInput[]
    createMany?: test_runsCreateManyTest_suitesInputEnvelope
    connect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
  }

  export type suite_case_mapUpdateManyWithoutTest_suitesNestedInput = {
    create?: XOR<suite_case_mapCreateWithoutTest_suitesInput, suite_case_mapUncheckedCreateWithoutTest_suitesInput> | suite_case_mapCreateWithoutTest_suitesInput[] | suite_case_mapUncheckedCreateWithoutTest_suitesInput[]
    connectOrCreate?: suite_case_mapCreateOrConnectWithoutTest_suitesInput | suite_case_mapCreateOrConnectWithoutTest_suitesInput[]
    upsert?: suite_case_mapUpsertWithWhereUniqueWithoutTest_suitesInput | suite_case_mapUpsertWithWhereUniqueWithoutTest_suitesInput[]
    createMany?: suite_case_mapCreateManyTest_suitesInputEnvelope
    set?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    disconnect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    delete?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    connect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    update?: suite_case_mapUpdateWithWhereUniqueWithoutTest_suitesInput | suite_case_mapUpdateWithWhereUniqueWithoutTest_suitesInput[]
    updateMany?: suite_case_mapUpdateManyWithWhereWithoutTest_suitesInput | suite_case_mapUpdateManyWithWhereWithoutTest_suitesInput[]
    deleteMany?: suite_case_mapScalarWhereInput | suite_case_mapScalarWhereInput[]
  }

  export type test_runsUpdateManyWithoutTest_suitesNestedInput = {
    create?: XOR<test_runsCreateWithoutTest_suitesInput, test_runsUncheckedCreateWithoutTest_suitesInput> | test_runsCreateWithoutTest_suitesInput[] | test_runsUncheckedCreateWithoutTest_suitesInput[]
    connectOrCreate?: test_runsCreateOrConnectWithoutTest_suitesInput | test_runsCreateOrConnectWithoutTest_suitesInput[]
    upsert?: test_runsUpsertWithWhereUniqueWithoutTest_suitesInput | test_runsUpsertWithWhereUniqueWithoutTest_suitesInput[]
    createMany?: test_runsCreateManyTest_suitesInputEnvelope
    set?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    disconnect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    delete?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    connect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    update?: test_runsUpdateWithWhereUniqueWithoutTest_suitesInput | test_runsUpdateWithWhereUniqueWithoutTest_suitesInput[]
    updateMany?: test_runsUpdateManyWithWhereWithoutTest_suitesInput | test_runsUpdateManyWithWhereWithoutTest_suitesInput[]
    deleteMany?: test_runsScalarWhereInput | test_runsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutTest_suitesNestedInput = {
    create?: XOR<usersCreateWithoutTest_suitesInput, usersUncheckedCreateWithoutTest_suitesInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_suitesInput
    upsert?: usersUpsertWithoutTest_suitesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTest_suitesInput, usersUpdateWithoutTest_suitesInput>, usersUncheckedUpdateWithoutTest_suitesInput>
  }

  export type suite_case_mapUncheckedUpdateManyWithoutTest_suitesNestedInput = {
    create?: XOR<suite_case_mapCreateWithoutTest_suitesInput, suite_case_mapUncheckedCreateWithoutTest_suitesInput> | suite_case_mapCreateWithoutTest_suitesInput[] | suite_case_mapUncheckedCreateWithoutTest_suitesInput[]
    connectOrCreate?: suite_case_mapCreateOrConnectWithoutTest_suitesInput | suite_case_mapCreateOrConnectWithoutTest_suitesInput[]
    upsert?: suite_case_mapUpsertWithWhereUniqueWithoutTest_suitesInput | suite_case_mapUpsertWithWhereUniqueWithoutTest_suitesInput[]
    createMany?: suite_case_mapCreateManyTest_suitesInputEnvelope
    set?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    disconnect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    delete?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    connect?: suite_case_mapWhereUniqueInput | suite_case_mapWhereUniqueInput[]
    update?: suite_case_mapUpdateWithWhereUniqueWithoutTest_suitesInput | suite_case_mapUpdateWithWhereUniqueWithoutTest_suitesInput[]
    updateMany?: suite_case_mapUpdateManyWithWhereWithoutTest_suitesInput | suite_case_mapUpdateManyWithWhereWithoutTest_suitesInput[]
    deleteMany?: suite_case_mapScalarWhereInput | suite_case_mapScalarWhereInput[]
  }

  export type test_runsUncheckedUpdateManyWithoutTest_suitesNestedInput = {
    create?: XOR<test_runsCreateWithoutTest_suitesInput, test_runsUncheckedCreateWithoutTest_suitesInput> | test_runsCreateWithoutTest_suitesInput[] | test_runsUncheckedCreateWithoutTest_suitesInput[]
    connectOrCreate?: test_runsCreateOrConnectWithoutTest_suitesInput | test_runsCreateOrConnectWithoutTest_suitesInput[]
    upsert?: test_runsUpsertWithWhereUniqueWithoutTest_suitesInput | test_runsUpsertWithWhereUniqueWithoutTest_suitesInput[]
    createMany?: test_runsCreateManyTest_suitesInputEnvelope
    set?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    disconnect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    delete?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    connect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    update?: test_runsUpdateWithWhereUniqueWithoutTest_suitesInput | test_runsUpdateWithWhereUniqueWithoutTest_suitesInput[]
    updateMany?: test_runsUpdateManyWithWhereWithoutTest_suitesInput | test_runsUpdateManyWithWhereWithoutTest_suitesInput[]
    deleteMany?: test_runsScalarWhereInput | test_runsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_rolesInput
    connect?: usersWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUser_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_rolesInput
    upsert?: usersUpsertWithoutUser_rolesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_rolesInput, usersUpdateWithoutUser_rolesInput>, usersUncheckedUpdateWithoutUser_rolesInput>
  }

  export type rolesUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUser_rolesInput
    upsert?: rolesUpsertWithoutUser_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUser_rolesInput, rolesUpdateWithoutUser_rolesInput>, rolesUncheckedUpdateWithoutUser_rolesInput>
  }

  export type ai_generation_sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_generation_sessionsCreateWithoutUsersInput, ai_generation_sessionsUncheckedCreateWithoutUsersInput> | ai_generation_sessionsCreateWithoutUsersInput[] | ai_generation_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_generation_sessionsCreateOrConnectWithoutUsersInput | ai_generation_sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: ai_generation_sessionsCreateManyUsersInputEnvelope
    connect?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
  }

  export type api_tokensCreateNestedManyWithoutUsersInput = {
    create?: XOR<api_tokensCreateWithoutUsersInput, api_tokensUncheckedCreateWithoutUsersInput> | api_tokensCreateWithoutUsersInput[] | api_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: api_tokensCreateOrConnectWithoutUsersInput | api_tokensCreateOrConnectWithoutUsersInput[]
    createMany?: api_tokensCreateManyUsersInputEnvelope
    connect?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
  }

  export type audit_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
  }

  export type bulk_edit_sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<bulk_edit_sessionsCreateWithoutUsersInput, bulk_edit_sessionsUncheckedCreateWithoutUsersInput> | bulk_edit_sessionsCreateWithoutUsersInput[] | bulk_edit_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bulk_edit_sessionsCreateOrConnectWithoutUsersInput | bulk_edit_sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: bulk_edit_sessionsCreateManyUsersInputEnvelope
    connect?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
  }

  export type case_versionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<case_versionsCreateWithoutUsersInput, case_versionsUncheckedCreateWithoutUsersInput> | case_versionsCreateWithoutUsersInput[] | case_versionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: case_versionsCreateOrConnectWithoutUsersInput | case_versionsCreateOrConnectWithoutUsersInput[]
    createMany?: case_versionsCreateManyUsersInputEnvelope
    connect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
  }

  export type functional_test_casesCreateNestedManyWithoutUsersInput = {
    create?: XOR<functional_test_casesCreateWithoutUsersInput, functional_test_casesUncheckedCreateWithoutUsersInput> | functional_test_casesCreateWithoutUsersInput[] | functional_test_casesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutUsersInput | functional_test_casesCreateOrConnectWithoutUsersInput[]
    createMany?: functional_test_casesCreateManyUsersInputEnvelope
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
  }

  export type requirement_documentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<requirement_documentsCreateWithoutUsersInput, requirement_documentsUncheckedCreateWithoutUsersInput> | requirement_documentsCreateWithoutUsersInput[] | requirement_documentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutUsersInput | requirement_documentsCreateOrConnectWithoutUsersInput[]
    createMany?: requirement_documentsCreateManyUsersInputEnvelope
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
  }

  export type test_case_executionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_case_executionsCreateWithoutUsersInput, test_case_executionsUncheckedCreateWithoutUsersInput> | test_case_executionsCreateWithoutUsersInput[] | test_case_executionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_case_executionsCreateOrConnectWithoutUsersInput | test_case_executionsCreateOrConnectWithoutUsersInput[]
    createMany?: test_case_executionsCreateManyUsersInputEnvelope
    connect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
  }

  export type test_runsCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_runsCreateWithoutUsersInput, test_runsUncheckedCreateWithoutUsersInput> | test_runsCreateWithoutUsersInput[] | test_runsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_runsCreateOrConnectWithoutUsersInput | test_runsCreateOrConnectWithoutUsersInput[]
    createMany?: test_runsCreateManyUsersInputEnvelope
    connect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
  }

  export type test_suitesCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_suitesCreateWithoutUsersInput, test_suitesUncheckedCreateWithoutUsersInput> | test_suitesCreateWithoutUsersInput[] | test_suitesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_suitesCreateOrConnectWithoutUsersInput | test_suitesCreateOrConnectWithoutUsersInput[]
    createMany?: test_suitesCreateManyUsersInputEnvelope
    connect?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
  }

  export type user_rolesCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type functional_test_executionsCreateNestedManyWithoutExecutorInput = {
    create?: XOR<functional_test_executionsCreateWithoutExecutorInput, functional_test_executionsUncheckedCreateWithoutExecutorInput> | functional_test_executionsCreateWithoutExecutorInput[] | functional_test_executionsUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: functional_test_executionsCreateOrConnectWithoutExecutorInput | functional_test_executionsCreateOrConnectWithoutExecutorInput[]
    createMany?: functional_test_executionsCreateManyExecutorInputEnvelope
    connect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
  }

  export type test_plansCreateNestedManyWithoutOwnerInput = {
    create?: XOR<test_plansCreateWithoutOwnerInput, test_plansUncheckedCreateWithoutOwnerInput> | test_plansCreateWithoutOwnerInput[] | test_plansUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutOwnerInput | test_plansCreateOrConnectWithoutOwnerInput[]
    createMany?: test_plansCreateManyOwnerInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_generation_sessionsCreateWithoutUsersInput, ai_generation_sessionsUncheckedCreateWithoutUsersInput> | ai_generation_sessionsCreateWithoutUsersInput[] | ai_generation_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_generation_sessionsCreateOrConnectWithoutUsersInput | ai_generation_sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: ai_generation_sessionsCreateManyUsersInputEnvelope
    connect?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
  }

  export type api_tokensUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<api_tokensCreateWithoutUsersInput, api_tokensUncheckedCreateWithoutUsersInput> | api_tokensCreateWithoutUsersInput[] | api_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: api_tokensCreateOrConnectWithoutUsersInput | api_tokensCreateOrConnectWithoutUsersInput[]
    createMany?: api_tokensCreateManyUsersInputEnvelope
    connect?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
  }

  export type audit_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
  }

  export type bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<bulk_edit_sessionsCreateWithoutUsersInput, bulk_edit_sessionsUncheckedCreateWithoutUsersInput> | bulk_edit_sessionsCreateWithoutUsersInput[] | bulk_edit_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bulk_edit_sessionsCreateOrConnectWithoutUsersInput | bulk_edit_sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: bulk_edit_sessionsCreateManyUsersInputEnvelope
    connect?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
  }

  export type case_versionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<case_versionsCreateWithoutUsersInput, case_versionsUncheckedCreateWithoutUsersInput> | case_versionsCreateWithoutUsersInput[] | case_versionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: case_versionsCreateOrConnectWithoutUsersInput | case_versionsCreateOrConnectWithoutUsersInput[]
    createMany?: case_versionsCreateManyUsersInputEnvelope
    connect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
  }

  export type functional_test_casesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<functional_test_casesCreateWithoutUsersInput, functional_test_casesUncheckedCreateWithoutUsersInput> | functional_test_casesCreateWithoutUsersInput[] | functional_test_casesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutUsersInput | functional_test_casesCreateOrConnectWithoutUsersInput[]
    createMany?: functional_test_casesCreateManyUsersInputEnvelope
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
  }

  export type requirement_documentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<requirement_documentsCreateWithoutUsersInput, requirement_documentsUncheckedCreateWithoutUsersInput> | requirement_documentsCreateWithoutUsersInput[] | requirement_documentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutUsersInput | requirement_documentsCreateOrConnectWithoutUsersInput[]
    createMany?: requirement_documentsCreateManyUsersInputEnvelope
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
  }

  export type test_case_executionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_case_executionsCreateWithoutUsersInput, test_case_executionsUncheckedCreateWithoutUsersInput> | test_case_executionsCreateWithoutUsersInput[] | test_case_executionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_case_executionsCreateOrConnectWithoutUsersInput | test_case_executionsCreateOrConnectWithoutUsersInput[]
    createMany?: test_case_executionsCreateManyUsersInputEnvelope
    connect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
  }

  export type test_runsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_runsCreateWithoutUsersInput, test_runsUncheckedCreateWithoutUsersInput> | test_runsCreateWithoutUsersInput[] | test_runsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_runsCreateOrConnectWithoutUsersInput | test_runsCreateOrConnectWithoutUsersInput[]
    createMany?: test_runsCreateManyUsersInputEnvelope
    connect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
  }

  export type test_suitesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<test_suitesCreateWithoutUsersInput, test_suitesUncheckedCreateWithoutUsersInput> | test_suitesCreateWithoutUsersInput[] | test_suitesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_suitesCreateOrConnectWithoutUsersInput | test_suitesCreateOrConnectWithoutUsersInput[]
    createMany?: test_suitesCreateManyUsersInputEnvelope
    connect?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput = {
    create?: XOR<functional_test_executionsCreateWithoutExecutorInput, functional_test_executionsUncheckedCreateWithoutExecutorInput> | functional_test_executionsCreateWithoutExecutorInput[] | functional_test_executionsUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: functional_test_executionsCreateOrConnectWithoutExecutorInput | functional_test_executionsCreateOrConnectWithoutExecutorInput[]
    createMany?: functional_test_executionsCreateManyExecutorInputEnvelope
    connect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
  }

  export type test_plansUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<test_plansCreateWithoutOwnerInput, test_plansUncheckedCreateWithoutOwnerInput> | test_plansCreateWithoutOwnerInput[] | test_plansUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutOwnerInput | test_plansCreateOrConnectWithoutOwnerInput[]
    createMany?: test_plansCreateManyOwnerInputEnvelope
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
  }

  export type ai_generation_sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_generation_sessionsCreateWithoutUsersInput, ai_generation_sessionsUncheckedCreateWithoutUsersInput> | ai_generation_sessionsCreateWithoutUsersInput[] | ai_generation_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_generation_sessionsCreateOrConnectWithoutUsersInput | ai_generation_sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: ai_generation_sessionsUpsertWithWhereUniqueWithoutUsersInput | ai_generation_sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_generation_sessionsCreateManyUsersInputEnvelope
    set?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
    disconnect?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
    delete?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
    connect?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
    update?: ai_generation_sessionsUpdateWithWhereUniqueWithoutUsersInput | ai_generation_sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_generation_sessionsUpdateManyWithWhereWithoutUsersInput | ai_generation_sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_generation_sessionsScalarWhereInput | ai_generation_sessionsScalarWhereInput[]
  }

  export type api_tokensUpdateManyWithoutUsersNestedInput = {
    create?: XOR<api_tokensCreateWithoutUsersInput, api_tokensUncheckedCreateWithoutUsersInput> | api_tokensCreateWithoutUsersInput[] | api_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: api_tokensCreateOrConnectWithoutUsersInput | api_tokensCreateOrConnectWithoutUsersInput[]
    upsert?: api_tokensUpsertWithWhereUniqueWithoutUsersInput | api_tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: api_tokensCreateManyUsersInputEnvelope
    set?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
    disconnect?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
    delete?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
    connect?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
    update?: api_tokensUpdateWithWhereUniqueWithoutUsersInput | api_tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: api_tokensUpdateManyWithWhereWithoutUsersInput | api_tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: api_tokensScalarWhereInput | api_tokensScalarWhereInput[]
  }

  export type audit_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: audit_logsUpsertWithWhereUniqueWithoutUsersInput | audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    set?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    disconnect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    delete?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    update?: audit_logsUpdateWithWhereUniqueWithoutUsersInput | audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: audit_logsUpdateManyWithWhereWithoutUsersInput | audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
  }

  export type bulk_edit_sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<bulk_edit_sessionsCreateWithoutUsersInput, bulk_edit_sessionsUncheckedCreateWithoutUsersInput> | bulk_edit_sessionsCreateWithoutUsersInput[] | bulk_edit_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bulk_edit_sessionsCreateOrConnectWithoutUsersInput | bulk_edit_sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: bulk_edit_sessionsUpsertWithWhereUniqueWithoutUsersInput | bulk_edit_sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: bulk_edit_sessionsCreateManyUsersInputEnvelope
    set?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
    disconnect?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
    delete?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
    connect?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
    update?: bulk_edit_sessionsUpdateWithWhereUniqueWithoutUsersInput | bulk_edit_sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: bulk_edit_sessionsUpdateManyWithWhereWithoutUsersInput | bulk_edit_sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: bulk_edit_sessionsScalarWhereInput | bulk_edit_sessionsScalarWhereInput[]
  }

  export type case_versionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<case_versionsCreateWithoutUsersInput, case_versionsUncheckedCreateWithoutUsersInput> | case_versionsCreateWithoutUsersInput[] | case_versionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: case_versionsCreateOrConnectWithoutUsersInput | case_versionsCreateOrConnectWithoutUsersInput[]
    upsert?: case_versionsUpsertWithWhereUniqueWithoutUsersInput | case_versionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: case_versionsCreateManyUsersInputEnvelope
    set?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    disconnect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    delete?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    connect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    update?: case_versionsUpdateWithWhereUniqueWithoutUsersInput | case_versionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: case_versionsUpdateManyWithWhereWithoutUsersInput | case_versionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: case_versionsScalarWhereInput | case_versionsScalarWhereInput[]
  }

  export type functional_test_casesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<functional_test_casesCreateWithoutUsersInput, functional_test_casesUncheckedCreateWithoutUsersInput> | functional_test_casesCreateWithoutUsersInput[] | functional_test_casesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutUsersInput | functional_test_casesCreateOrConnectWithoutUsersInput[]
    upsert?: functional_test_casesUpsertWithWhereUniqueWithoutUsersInput | functional_test_casesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: functional_test_casesCreateManyUsersInputEnvelope
    set?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    disconnect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    delete?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    update?: functional_test_casesUpdateWithWhereUniqueWithoutUsersInput | functional_test_casesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: functional_test_casesUpdateManyWithWhereWithoutUsersInput | functional_test_casesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: functional_test_casesScalarWhereInput | functional_test_casesScalarWhereInput[]
  }

  export type requirement_documentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutUsersInput, requirement_documentsUncheckedCreateWithoutUsersInput> | requirement_documentsCreateWithoutUsersInput[] | requirement_documentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutUsersInput | requirement_documentsCreateOrConnectWithoutUsersInput[]
    upsert?: requirement_documentsUpsertWithWhereUniqueWithoutUsersInput | requirement_documentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: requirement_documentsCreateManyUsersInputEnvelope
    set?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    disconnect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    delete?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    update?: requirement_documentsUpdateWithWhereUniqueWithoutUsersInput | requirement_documentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: requirement_documentsUpdateManyWithWhereWithoutUsersInput | requirement_documentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
  }

  export type test_case_executionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_case_executionsCreateWithoutUsersInput, test_case_executionsUncheckedCreateWithoutUsersInput> | test_case_executionsCreateWithoutUsersInput[] | test_case_executionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_case_executionsCreateOrConnectWithoutUsersInput | test_case_executionsCreateOrConnectWithoutUsersInput[]
    upsert?: test_case_executionsUpsertWithWhereUniqueWithoutUsersInput | test_case_executionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_case_executionsCreateManyUsersInputEnvelope
    set?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    disconnect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    delete?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    connect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    update?: test_case_executionsUpdateWithWhereUniqueWithoutUsersInput | test_case_executionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_case_executionsUpdateManyWithWhereWithoutUsersInput | test_case_executionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_case_executionsScalarWhereInput | test_case_executionsScalarWhereInput[]
  }

  export type test_runsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_runsCreateWithoutUsersInput, test_runsUncheckedCreateWithoutUsersInput> | test_runsCreateWithoutUsersInput[] | test_runsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_runsCreateOrConnectWithoutUsersInput | test_runsCreateOrConnectWithoutUsersInput[]
    upsert?: test_runsUpsertWithWhereUniqueWithoutUsersInput | test_runsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_runsCreateManyUsersInputEnvelope
    set?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    disconnect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    delete?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    connect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    update?: test_runsUpdateWithWhereUniqueWithoutUsersInput | test_runsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_runsUpdateManyWithWhereWithoutUsersInput | test_runsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_runsScalarWhereInput | test_runsScalarWhereInput[]
  }

  export type test_suitesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_suitesCreateWithoutUsersInput, test_suitesUncheckedCreateWithoutUsersInput> | test_suitesCreateWithoutUsersInput[] | test_suitesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_suitesCreateOrConnectWithoutUsersInput | test_suitesCreateOrConnectWithoutUsersInput[]
    upsert?: test_suitesUpsertWithWhereUniqueWithoutUsersInput | test_suitesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_suitesCreateManyUsersInputEnvelope
    set?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
    disconnect?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
    delete?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
    connect?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
    update?: test_suitesUpdateWithWhereUniqueWithoutUsersInput | test_suitesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_suitesUpdateManyWithWhereWithoutUsersInput | test_suitesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_suitesScalarWhereInput | test_suitesScalarWhereInput[]
  }

  export type user_rolesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUsersInput | user_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUsersInput | user_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUsersInput | user_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type functional_test_executionsUpdateManyWithoutExecutorNestedInput = {
    create?: XOR<functional_test_executionsCreateWithoutExecutorInput, functional_test_executionsUncheckedCreateWithoutExecutorInput> | functional_test_executionsCreateWithoutExecutorInput[] | functional_test_executionsUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: functional_test_executionsCreateOrConnectWithoutExecutorInput | functional_test_executionsCreateOrConnectWithoutExecutorInput[]
    upsert?: functional_test_executionsUpsertWithWhereUniqueWithoutExecutorInput | functional_test_executionsUpsertWithWhereUniqueWithoutExecutorInput[]
    createMany?: functional_test_executionsCreateManyExecutorInputEnvelope
    set?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    disconnect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    delete?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    connect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    update?: functional_test_executionsUpdateWithWhereUniqueWithoutExecutorInput | functional_test_executionsUpdateWithWhereUniqueWithoutExecutorInput[]
    updateMany?: functional_test_executionsUpdateManyWithWhereWithoutExecutorInput | functional_test_executionsUpdateManyWithWhereWithoutExecutorInput[]
    deleteMany?: functional_test_executionsScalarWhereInput | functional_test_executionsScalarWhereInput[]
  }

  export type test_plansUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<test_plansCreateWithoutOwnerInput, test_plansUncheckedCreateWithoutOwnerInput> | test_plansCreateWithoutOwnerInput[] | test_plansUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutOwnerInput | test_plansCreateOrConnectWithoutOwnerInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutOwnerInput | test_plansUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: test_plansCreateManyOwnerInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutOwnerInput | test_plansUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutOwnerInput | test_plansUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_generation_sessionsCreateWithoutUsersInput, ai_generation_sessionsUncheckedCreateWithoutUsersInput> | ai_generation_sessionsCreateWithoutUsersInput[] | ai_generation_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_generation_sessionsCreateOrConnectWithoutUsersInput | ai_generation_sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: ai_generation_sessionsUpsertWithWhereUniqueWithoutUsersInput | ai_generation_sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_generation_sessionsCreateManyUsersInputEnvelope
    set?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
    disconnect?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
    delete?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
    connect?: ai_generation_sessionsWhereUniqueInput | ai_generation_sessionsWhereUniqueInput[]
    update?: ai_generation_sessionsUpdateWithWhereUniqueWithoutUsersInput | ai_generation_sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_generation_sessionsUpdateManyWithWhereWithoutUsersInput | ai_generation_sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_generation_sessionsScalarWhereInput | ai_generation_sessionsScalarWhereInput[]
  }

  export type api_tokensUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<api_tokensCreateWithoutUsersInput, api_tokensUncheckedCreateWithoutUsersInput> | api_tokensCreateWithoutUsersInput[] | api_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: api_tokensCreateOrConnectWithoutUsersInput | api_tokensCreateOrConnectWithoutUsersInput[]
    upsert?: api_tokensUpsertWithWhereUniqueWithoutUsersInput | api_tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: api_tokensCreateManyUsersInputEnvelope
    set?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
    disconnect?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
    delete?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
    connect?: api_tokensWhereUniqueInput | api_tokensWhereUniqueInput[]
    update?: api_tokensUpdateWithWhereUniqueWithoutUsersInput | api_tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: api_tokensUpdateManyWithWhereWithoutUsersInput | api_tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: api_tokensScalarWhereInput | api_tokensScalarWhereInput[]
  }

  export type audit_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: audit_logsUpsertWithWhereUniqueWithoutUsersInput | audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    set?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    disconnect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    delete?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    update?: audit_logsUpdateWithWhereUniqueWithoutUsersInput | audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: audit_logsUpdateManyWithWhereWithoutUsersInput | audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
  }

  export type bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<bulk_edit_sessionsCreateWithoutUsersInput, bulk_edit_sessionsUncheckedCreateWithoutUsersInput> | bulk_edit_sessionsCreateWithoutUsersInput[] | bulk_edit_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bulk_edit_sessionsCreateOrConnectWithoutUsersInput | bulk_edit_sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: bulk_edit_sessionsUpsertWithWhereUniqueWithoutUsersInput | bulk_edit_sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: bulk_edit_sessionsCreateManyUsersInputEnvelope
    set?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
    disconnect?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
    delete?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
    connect?: bulk_edit_sessionsWhereUniqueInput | bulk_edit_sessionsWhereUniqueInput[]
    update?: bulk_edit_sessionsUpdateWithWhereUniqueWithoutUsersInput | bulk_edit_sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: bulk_edit_sessionsUpdateManyWithWhereWithoutUsersInput | bulk_edit_sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: bulk_edit_sessionsScalarWhereInput | bulk_edit_sessionsScalarWhereInput[]
  }

  export type case_versionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<case_versionsCreateWithoutUsersInput, case_versionsUncheckedCreateWithoutUsersInput> | case_versionsCreateWithoutUsersInput[] | case_versionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: case_versionsCreateOrConnectWithoutUsersInput | case_versionsCreateOrConnectWithoutUsersInput[]
    upsert?: case_versionsUpsertWithWhereUniqueWithoutUsersInput | case_versionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: case_versionsCreateManyUsersInputEnvelope
    set?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    disconnect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    delete?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    connect?: case_versionsWhereUniqueInput | case_versionsWhereUniqueInput[]
    update?: case_versionsUpdateWithWhereUniqueWithoutUsersInput | case_versionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: case_versionsUpdateManyWithWhereWithoutUsersInput | case_versionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: case_versionsScalarWhereInput | case_versionsScalarWhereInput[]
  }

  export type functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<functional_test_casesCreateWithoutUsersInput, functional_test_casesUncheckedCreateWithoutUsersInput> | functional_test_casesCreateWithoutUsersInput[] | functional_test_casesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutUsersInput | functional_test_casesCreateOrConnectWithoutUsersInput[]
    upsert?: functional_test_casesUpsertWithWhereUniqueWithoutUsersInput | functional_test_casesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: functional_test_casesCreateManyUsersInputEnvelope
    set?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    disconnect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    delete?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    update?: functional_test_casesUpdateWithWhereUniqueWithoutUsersInput | functional_test_casesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: functional_test_casesUpdateManyWithWhereWithoutUsersInput | functional_test_casesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: functional_test_casesScalarWhereInput | functional_test_casesScalarWhereInput[]
  }

  export type requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutUsersInput, requirement_documentsUncheckedCreateWithoutUsersInput> | requirement_documentsCreateWithoutUsersInput[] | requirement_documentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutUsersInput | requirement_documentsCreateOrConnectWithoutUsersInput[]
    upsert?: requirement_documentsUpsertWithWhereUniqueWithoutUsersInput | requirement_documentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: requirement_documentsCreateManyUsersInputEnvelope
    set?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    disconnect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    delete?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    update?: requirement_documentsUpdateWithWhereUniqueWithoutUsersInput | requirement_documentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: requirement_documentsUpdateManyWithWhereWithoutUsersInput | requirement_documentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
  }

  export type test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_case_executionsCreateWithoutUsersInput, test_case_executionsUncheckedCreateWithoutUsersInput> | test_case_executionsCreateWithoutUsersInput[] | test_case_executionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_case_executionsCreateOrConnectWithoutUsersInput | test_case_executionsCreateOrConnectWithoutUsersInput[]
    upsert?: test_case_executionsUpsertWithWhereUniqueWithoutUsersInput | test_case_executionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_case_executionsCreateManyUsersInputEnvelope
    set?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    disconnect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    delete?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    connect?: test_case_executionsWhereUniqueInput | test_case_executionsWhereUniqueInput[]
    update?: test_case_executionsUpdateWithWhereUniqueWithoutUsersInput | test_case_executionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_case_executionsUpdateManyWithWhereWithoutUsersInput | test_case_executionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_case_executionsScalarWhereInput | test_case_executionsScalarWhereInput[]
  }

  export type test_runsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_runsCreateWithoutUsersInput, test_runsUncheckedCreateWithoutUsersInput> | test_runsCreateWithoutUsersInput[] | test_runsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_runsCreateOrConnectWithoutUsersInput | test_runsCreateOrConnectWithoutUsersInput[]
    upsert?: test_runsUpsertWithWhereUniqueWithoutUsersInput | test_runsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_runsCreateManyUsersInputEnvelope
    set?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    disconnect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    delete?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    connect?: test_runsWhereUniqueInput | test_runsWhereUniqueInput[]
    update?: test_runsUpdateWithWhereUniqueWithoutUsersInput | test_runsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_runsUpdateManyWithWhereWithoutUsersInput | test_runsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_runsScalarWhereInput | test_runsScalarWhereInput[]
  }

  export type test_suitesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<test_suitesCreateWithoutUsersInput, test_suitesUncheckedCreateWithoutUsersInput> | test_suitesCreateWithoutUsersInput[] | test_suitesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: test_suitesCreateOrConnectWithoutUsersInput | test_suitesCreateOrConnectWithoutUsersInput[]
    upsert?: test_suitesUpsertWithWhereUniqueWithoutUsersInput | test_suitesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: test_suitesCreateManyUsersInputEnvelope
    set?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
    disconnect?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
    delete?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
    connect?: test_suitesWhereUniqueInput | test_suitesWhereUniqueInput[]
    update?: test_suitesUpdateWithWhereUniqueWithoutUsersInput | test_suitesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: test_suitesUpdateManyWithWhereWithoutUsersInput | test_suitesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: test_suitesScalarWhereInput | test_suitesScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUsersInput | user_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUsersInput | user_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUsersInput | user_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput = {
    create?: XOR<functional_test_executionsCreateWithoutExecutorInput, functional_test_executionsUncheckedCreateWithoutExecutorInput> | functional_test_executionsCreateWithoutExecutorInput[] | functional_test_executionsUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: functional_test_executionsCreateOrConnectWithoutExecutorInput | functional_test_executionsCreateOrConnectWithoutExecutorInput[]
    upsert?: functional_test_executionsUpsertWithWhereUniqueWithoutExecutorInput | functional_test_executionsUpsertWithWhereUniqueWithoutExecutorInput[]
    createMany?: functional_test_executionsCreateManyExecutorInputEnvelope
    set?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    disconnect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    delete?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    connect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    update?: functional_test_executionsUpdateWithWhereUniqueWithoutExecutorInput | functional_test_executionsUpdateWithWhereUniqueWithoutExecutorInput[]
    updateMany?: functional_test_executionsUpdateManyWithWhereWithoutExecutorInput | functional_test_executionsUpdateManyWithWhereWithoutExecutorInput[]
    deleteMany?: functional_test_executionsScalarWhereInput | functional_test_executionsScalarWhereInput[]
  }

  export type test_plansUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<test_plansCreateWithoutOwnerInput, test_plansUncheckedCreateWithoutOwnerInput> | test_plansCreateWithoutOwnerInput[] | test_plansUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: test_plansCreateOrConnectWithoutOwnerInput | test_plansCreateOrConnectWithoutOwnerInput[]
    upsert?: test_plansUpsertWithWhereUniqueWithoutOwnerInput | test_plansUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: test_plansCreateManyOwnerInputEnvelope
    set?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    disconnect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    delete?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    connect?: test_plansWhereUniqueInput | test_plansWhereUniqueInput[]
    update?: test_plansUpdateWithWhereUniqueWithoutOwnerInput | test_plansUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: test_plansUpdateManyWithWhereWithoutOwnerInput | test_plansUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
  }

  export type test_casesCreateNestedOneWithoutCase_versionsInput = {
    create?: XOR<test_casesCreateWithoutCase_versionsInput, test_casesUncheckedCreateWithoutCase_versionsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutCase_versionsInput
    connect?: test_casesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCase_versionsInput = {
    create?: XOR<usersCreateWithoutCase_versionsInput, usersUncheckedCreateWithoutCase_versionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCase_versionsInput
    connect?: usersWhereUniqueInput
  }

  export type test_casesUpdateOneRequiredWithoutCase_versionsNestedInput = {
    create?: XOR<test_casesCreateWithoutCase_versionsInput, test_casesUncheckedCreateWithoutCase_versionsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutCase_versionsInput
    upsert?: test_casesUpsertWithoutCase_versionsInput
    connect?: test_casesWhereUniqueInput
    update?: XOR<XOR<test_casesUpdateToOneWithWhereWithoutCase_versionsInput, test_casesUpdateWithoutCase_versionsInput>, test_casesUncheckedUpdateWithoutCase_versionsInput>
  }

  export type usersUpdateOneWithoutCase_versionsNestedInput = {
    create?: XOR<usersCreateWithoutCase_versionsInput, usersUncheckedCreateWithoutCase_versionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCase_versionsInput
    upsert?: usersUpsertWithoutCase_versionsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCase_versionsInput, usersUpdateWithoutCase_versionsInput>, usersUncheckedUpdateWithoutCase_versionsInput>
  }

  export type usersCreateNestedOneWithoutBulk_edit_sessionsInput = {
    create?: XOR<usersCreateWithoutBulk_edit_sessionsInput, usersUncheckedCreateWithoutBulk_edit_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBulk_edit_sessionsInput
    connect?: usersWhereUniqueInput
  }

  export type case_patch_proposalsCreateNestedManyWithoutSessionInput = {
    create?: XOR<case_patch_proposalsCreateWithoutSessionInput, case_patch_proposalsUncheckedCreateWithoutSessionInput> | case_patch_proposalsCreateWithoutSessionInput[] | case_patch_proposalsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: case_patch_proposalsCreateOrConnectWithoutSessionInput | case_patch_proposalsCreateOrConnectWithoutSessionInput[]
    createMany?: case_patch_proposalsCreateManySessionInputEnvelope
    connect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
  }

  export type case_patch_proposalsUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<case_patch_proposalsCreateWithoutSessionInput, case_patch_proposalsUncheckedCreateWithoutSessionInput> | case_patch_proposalsCreateWithoutSessionInput[] | case_patch_proposalsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: case_patch_proposalsCreateOrConnectWithoutSessionInput | case_patch_proposalsCreateOrConnectWithoutSessionInput[]
    createMany?: case_patch_proposalsCreateManySessionInputEnvelope
    connect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
  }

  export type Enumbulk_edit_sessions_statusFieldUpdateOperationsInput = {
    set?: $Enums.bulk_edit_sessions_status
  }

  export type usersUpdateOneRequiredWithoutBulk_edit_sessionsNestedInput = {
    create?: XOR<usersCreateWithoutBulk_edit_sessionsInput, usersUncheckedCreateWithoutBulk_edit_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBulk_edit_sessionsInput
    upsert?: usersUpsertWithoutBulk_edit_sessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBulk_edit_sessionsInput, usersUpdateWithoutBulk_edit_sessionsInput>, usersUncheckedUpdateWithoutBulk_edit_sessionsInput>
  }

  export type case_patch_proposalsUpdateManyWithoutSessionNestedInput = {
    create?: XOR<case_patch_proposalsCreateWithoutSessionInput, case_patch_proposalsUncheckedCreateWithoutSessionInput> | case_patch_proposalsCreateWithoutSessionInput[] | case_patch_proposalsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: case_patch_proposalsCreateOrConnectWithoutSessionInput | case_patch_proposalsCreateOrConnectWithoutSessionInput[]
    upsert?: case_patch_proposalsUpsertWithWhereUniqueWithoutSessionInput | case_patch_proposalsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: case_patch_proposalsCreateManySessionInputEnvelope
    set?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    disconnect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    delete?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    connect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    update?: case_patch_proposalsUpdateWithWhereUniqueWithoutSessionInput | case_patch_proposalsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: case_patch_proposalsUpdateManyWithWhereWithoutSessionInput | case_patch_proposalsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: case_patch_proposalsScalarWhereInput | case_patch_proposalsScalarWhereInput[]
  }

  export type case_patch_proposalsUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<case_patch_proposalsCreateWithoutSessionInput, case_patch_proposalsUncheckedCreateWithoutSessionInput> | case_patch_proposalsCreateWithoutSessionInput[] | case_patch_proposalsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: case_patch_proposalsCreateOrConnectWithoutSessionInput | case_patch_proposalsCreateOrConnectWithoutSessionInput[]
    upsert?: case_patch_proposalsUpsertWithWhereUniqueWithoutSessionInput | case_patch_proposalsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: case_patch_proposalsCreateManySessionInputEnvelope
    set?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    disconnect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    delete?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    connect?: case_patch_proposalsWhereUniqueInput | case_patch_proposalsWhereUniqueInput[]
    update?: case_patch_proposalsUpdateWithWhereUniqueWithoutSessionInput | case_patch_proposalsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: case_patch_proposalsUpdateManyWithWhereWithoutSessionInput | case_patch_proposalsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: case_patch_proposalsScalarWhereInput | case_patch_proposalsScalarWhereInput[]
  }

  export type test_casesCreateNestedOneWithoutPatch_proposalsInput = {
    create?: XOR<test_casesCreateWithoutPatch_proposalsInput, test_casesUncheckedCreateWithoutPatch_proposalsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutPatch_proposalsInput
    connect?: test_casesWhereUniqueInput
  }

  export type bulk_edit_sessionsCreateNestedOneWithoutProposalsInput = {
    create?: XOR<bulk_edit_sessionsCreateWithoutProposalsInput, bulk_edit_sessionsUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: bulk_edit_sessionsCreateOrConnectWithoutProposalsInput
    connect?: bulk_edit_sessionsWhereUniqueInput
  }

  export type Enumproposal_risk_levelFieldUpdateOperationsInput = {
    set?: $Enums.proposal_risk_level
  }

  export type Enumproposal_apply_statusFieldUpdateOperationsInput = {
    set?: $Enums.proposal_apply_status
  }

  export type test_casesUpdateOneRequiredWithoutPatch_proposalsNestedInput = {
    create?: XOR<test_casesCreateWithoutPatch_proposalsInput, test_casesUncheckedCreateWithoutPatch_proposalsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutPatch_proposalsInput
    upsert?: test_casesUpsertWithoutPatch_proposalsInput
    connect?: test_casesWhereUniqueInput
    update?: XOR<XOR<test_casesUpdateToOneWithWhereWithoutPatch_proposalsInput, test_casesUpdateWithoutPatch_proposalsInput>, test_casesUncheckedUpdateWithoutPatch_proposalsInput>
  }

  export type bulk_edit_sessionsUpdateOneRequiredWithoutProposalsNestedInput = {
    create?: XOR<bulk_edit_sessionsCreateWithoutProposalsInput, bulk_edit_sessionsUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: bulk_edit_sessionsCreateOrConnectWithoutProposalsInput
    upsert?: bulk_edit_sessionsUpsertWithoutProposalsInput
    connect?: bulk_edit_sessionsWhereUniqueInput
    update?: XOR<XOR<bulk_edit_sessionsUpdateToOneWithWhereWithoutProposalsInput, bulk_edit_sessionsUpdateWithoutProposalsInput>, bulk_edit_sessionsUncheckedUpdateWithoutProposalsInput>
  }

  export type usersCreateNestedOneWithoutTest_case_executionsInput = {
    create?: XOR<usersCreateWithoutTest_case_executionsInput, usersUncheckedCreateWithoutTest_case_executionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_case_executionsInput
    connect?: usersWhereUniqueInput
  }

  export type test_casesCreateNestedOneWithoutTest_case_executionsInput = {
    create?: XOR<test_casesCreateWithoutTest_case_executionsInput, test_casesUncheckedCreateWithoutTest_case_executionsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutTest_case_executionsInput
    connect?: test_casesWhereUniqueInput
  }

  export type Enumtest_case_execution_statusFieldUpdateOperationsInput = {
    set?: $Enums.test_case_execution_status
  }

  export type usersUpdateOneWithoutTest_case_executionsNestedInput = {
    create?: XOR<usersCreateWithoutTest_case_executionsInput, usersUncheckedCreateWithoutTest_case_executionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_case_executionsInput
    upsert?: usersUpsertWithoutTest_case_executionsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTest_case_executionsInput, usersUpdateWithoutTest_case_executionsInput>, usersUncheckedUpdateWithoutTest_case_executionsInput>
  }

  export type test_casesUpdateOneRequiredWithoutTest_case_executionsNestedInput = {
    create?: XOR<test_casesCreateWithoutTest_case_executionsInput, test_casesUncheckedCreateWithoutTest_case_executionsInput>
    connectOrCreate?: test_casesCreateOrConnectWithoutTest_case_executionsInput
    upsert?: test_casesUpsertWithoutTest_case_executionsInput
    connect?: test_casesWhereUniqueInput
    update?: XOR<XOR<test_casesUpdateToOneWithWhereWithoutTest_case_executionsInput, test_casesUpdateWithoutTest_case_executionsInput>, test_casesUncheckedUpdateWithoutTest_case_executionsInput>
  }

  export type usersCreateNestedOneWithoutFunctional_test_casesInput = {
    create?: XOR<usersCreateWithoutFunctional_test_casesInput, usersUncheckedCreateWithoutFunctional_test_casesInput>
    connectOrCreate?: usersCreateOrConnectWithoutFunctional_test_casesInput
    connect?: usersWhereUniqueInput
  }

  export type project_versionsCreateNestedOneWithoutFunctional_test_casesInput = {
    create?: XOR<project_versionsCreateWithoutFunctional_test_casesInput, project_versionsUncheckedCreateWithoutFunctional_test_casesInput>
    connectOrCreate?: project_versionsCreateOrConnectWithoutFunctional_test_casesInput
    connect?: project_versionsWhereUniqueInput
  }

  export type requirement_documentsCreateNestedOneWithoutTest_casesInput = {
    create?: XOR<requirement_documentsCreateWithoutTest_casesInput, requirement_documentsUncheckedCreateWithoutTest_casesInput>
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutTest_casesInput
    connect?: requirement_documentsWhereUniqueInput
  }

  export type functional_test_executionsCreateNestedManyWithoutTest_caseInput = {
    create?: XOR<functional_test_executionsCreateWithoutTest_caseInput, functional_test_executionsUncheckedCreateWithoutTest_caseInput> | functional_test_executionsCreateWithoutTest_caseInput[] | functional_test_executionsUncheckedCreateWithoutTest_caseInput[]
    connectOrCreate?: functional_test_executionsCreateOrConnectWithoutTest_caseInput | functional_test_executionsCreateOrConnectWithoutTest_caseInput[]
    createMany?: functional_test_executionsCreateManyTest_caseInputEnvelope
    connect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
  }

  export type functional_test_executionsUncheckedCreateNestedManyWithoutTest_caseInput = {
    create?: XOR<functional_test_executionsCreateWithoutTest_caseInput, functional_test_executionsUncheckedCreateWithoutTest_caseInput> | functional_test_executionsCreateWithoutTest_caseInput[] | functional_test_executionsUncheckedCreateWithoutTest_caseInput[]
    connectOrCreate?: functional_test_executionsCreateOrConnectWithoutTest_caseInput | functional_test_executionsCreateOrConnectWithoutTest_caseInput[]
    createMany?: functional_test_executionsCreateManyTest_caseInputEnvelope
    connect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
  }

  export type Enumfunctional_test_priorityFieldUpdateOperationsInput = {
    set?: $Enums.functional_test_priority
  }

  export type Enumfunctional_test_statusFieldUpdateOperationsInput = {
    set?: $Enums.functional_test_status
  }

  export type Enumfunctional_test_sourceFieldUpdateOperationsInput = {
    set?: $Enums.functional_test_source
  }

  export type Enumfunctional_case_typeFieldUpdateOperationsInput = {
    set?: $Enums.functional_case_type
  }

  export type Enumfunctional_risk_levelFieldUpdateOperationsInput = {
    set?: $Enums.functional_risk_level
  }

  export type usersUpdateOneRequiredWithoutFunctional_test_casesNestedInput = {
    create?: XOR<usersCreateWithoutFunctional_test_casesInput, usersUncheckedCreateWithoutFunctional_test_casesInput>
    connectOrCreate?: usersCreateOrConnectWithoutFunctional_test_casesInput
    upsert?: usersUpsertWithoutFunctional_test_casesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFunctional_test_casesInput, usersUpdateWithoutFunctional_test_casesInput>, usersUncheckedUpdateWithoutFunctional_test_casesInput>
  }

  export type project_versionsUpdateOneWithoutFunctional_test_casesNestedInput = {
    create?: XOR<project_versionsCreateWithoutFunctional_test_casesInput, project_versionsUncheckedCreateWithoutFunctional_test_casesInput>
    connectOrCreate?: project_versionsCreateOrConnectWithoutFunctional_test_casesInput
    upsert?: project_versionsUpsertWithoutFunctional_test_casesInput
    disconnect?: project_versionsWhereInput | boolean
    delete?: project_versionsWhereInput | boolean
    connect?: project_versionsWhereUniqueInput
    update?: XOR<XOR<project_versionsUpdateToOneWithWhereWithoutFunctional_test_casesInput, project_versionsUpdateWithoutFunctional_test_casesInput>, project_versionsUncheckedUpdateWithoutFunctional_test_casesInput>
  }

  export type requirement_documentsUpdateOneWithoutTest_casesNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutTest_casesInput, requirement_documentsUncheckedCreateWithoutTest_casesInput>
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutTest_casesInput
    upsert?: requirement_documentsUpsertWithoutTest_casesInput
    disconnect?: requirement_documentsWhereInput | boolean
    delete?: requirement_documentsWhereInput | boolean
    connect?: requirement_documentsWhereUniqueInput
    update?: XOR<XOR<requirement_documentsUpdateToOneWithWhereWithoutTest_casesInput, requirement_documentsUpdateWithoutTest_casesInput>, requirement_documentsUncheckedUpdateWithoutTest_casesInput>
  }

  export type functional_test_executionsUpdateManyWithoutTest_caseNestedInput = {
    create?: XOR<functional_test_executionsCreateWithoutTest_caseInput, functional_test_executionsUncheckedCreateWithoutTest_caseInput> | functional_test_executionsCreateWithoutTest_caseInput[] | functional_test_executionsUncheckedCreateWithoutTest_caseInput[]
    connectOrCreate?: functional_test_executionsCreateOrConnectWithoutTest_caseInput | functional_test_executionsCreateOrConnectWithoutTest_caseInput[]
    upsert?: functional_test_executionsUpsertWithWhereUniqueWithoutTest_caseInput | functional_test_executionsUpsertWithWhereUniqueWithoutTest_caseInput[]
    createMany?: functional_test_executionsCreateManyTest_caseInputEnvelope
    set?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    disconnect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    delete?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    connect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    update?: functional_test_executionsUpdateWithWhereUniqueWithoutTest_caseInput | functional_test_executionsUpdateWithWhereUniqueWithoutTest_caseInput[]
    updateMany?: functional_test_executionsUpdateManyWithWhereWithoutTest_caseInput | functional_test_executionsUpdateManyWithWhereWithoutTest_caseInput[]
    deleteMany?: functional_test_executionsScalarWhereInput | functional_test_executionsScalarWhereInput[]
  }

  export type functional_test_executionsUncheckedUpdateManyWithoutTest_caseNestedInput = {
    create?: XOR<functional_test_executionsCreateWithoutTest_caseInput, functional_test_executionsUncheckedCreateWithoutTest_caseInput> | functional_test_executionsCreateWithoutTest_caseInput[] | functional_test_executionsUncheckedCreateWithoutTest_caseInput[]
    connectOrCreate?: functional_test_executionsCreateOrConnectWithoutTest_caseInput | functional_test_executionsCreateOrConnectWithoutTest_caseInput[]
    upsert?: functional_test_executionsUpsertWithWhereUniqueWithoutTest_caseInput | functional_test_executionsUpsertWithWhereUniqueWithoutTest_caseInput[]
    createMany?: functional_test_executionsCreateManyTest_caseInputEnvelope
    set?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    disconnect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    delete?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    connect?: functional_test_executionsWhereUniqueInput | functional_test_executionsWhereUniqueInput[]
    update?: functional_test_executionsUpdateWithWhereUniqueWithoutTest_caseInput | functional_test_executionsUpdateWithWhereUniqueWithoutTest_caseInput[]
    updateMany?: functional_test_executionsUpdateManyWithWhereWithoutTest_caseInput | functional_test_executionsUpdateManyWithWhereWithoutTest_caseInput[]
    deleteMany?: functional_test_executionsScalarWhereInput | functional_test_executionsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutAi_generation_sessionsInput = {
    create?: XOR<usersCreateWithoutAi_generation_sessionsInput, usersUncheckedCreateWithoutAi_generation_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_generation_sessionsInput
    connect?: usersWhereUniqueInput
  }

  export type requirement_documentsCreateNestedManyWithoutAi_sessionInput = {
    create?: XOR<requirement_documentsCreateWithoutAi_sessionInput, requirement_documentsUncheckedCreateWithoutAi_sessionInput> | requirement_documentsCreateWithoutAi_sessionInput[] | requirement_documentsUncheckedCreateWithoutAi_sessionInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutAi_sessionInput | requirement_documentsCreateOrConnectWithoutAi_sessionInput[]
    createMany?: requirement_documentsCreateManyAi_sessionInputEnvelope
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
  }

  export type requirement_documentsUncheckedCreateNestedManyWithoutAi_sessionInput = {
    create?: XOR<requirement_documentsCreateWithoutAi_sessionInput, requirement_documentsUncheckedCreateWithoutAi_sessionInput> | requirement_documentsCreateWithoutAi_sessionInput[] | requirement_documentsUncheckedCreateWithoutAi_sessionInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutAi_sessionInput | requirement_documentsCreateOrConnectWithoutAi_sessionInput[]
    createMany?: requirement_documentsCreateManyAi_sessionInputEnvelope
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutAi_generation_sessionsNestedInput = {
    create?: XOR<usersCreateWithoutAi_generation_sessionsInput, usersUncheckedCreateWithoutAi_generation_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_generation_sessionsInput
    upsert?: usersUpsertWithoutAi_generation_sessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_generation_sessionsInput, usersUpdateWithoutAi_generation_sessionsInput>, usersUncheckedUpdateWithoutAi_generation_sessionsInput>
  }

  export type requirement_documentsUpdateManyWithoutAi_sessionNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutAi_sessionInput, requirement_documentsUncheckedCreateWithoutAi_sessionInput> | requirement_documentsCreateWithoutAi_sessionInput[] | requirement_documentsUncheckedCreateWithoutAi_sessionInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutAi_sessionInput | requirement_documentsCreateOrConnectWithoutAi_sessionInput[]
    upsert?: requirement_documentsUpsertWithWhereUniqueWithoutAi_sessionInput | requirement_documentsUpsertWithWhereUniqueWithoutAi_sessionInput[]
    createMany?: requirement_documentsCreateManyAi_sessionInputEnvelope
    set?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    disconnect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    delete?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    update?: requirement_documentsUpdateWithWhereUniqueWithoutAi_sessionInput | requirement_documentsUpdateWithWhereUniqueWithoutAi_sessionInput[]
    updateMany?: requirement_documentsUpdateManyWithWhereWithoutAi_sessionInput | requirement_documentsUpdateManyWithWhereWithoutAi_sessionInput[]
    deleteMany?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
  }

  export type requirement_documentsUncheckedUpdateManyWithoutAi_sessionNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutAi_sessionInput, requirement_documentsUncheckedCreateWithoutAi_sessionInput> | requirement_documentsCreateWithoutAi_sessionInput[] | requirement_documentsUncheckedCreateWithoutAi_sessionInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutAi_sessionInput | requirement_documentsCreateOrConnectWithoutAi_sessionInput[]
    upsert?: requirement_documentsUpsertWithWhereUniqueWithoutAi_sessionInput | requirement_documentsUpsertWithWhereUniqueWithoutAi_sessionInput[]
    createMany?: requirement_documentsCreateManyAi_sessionInputEnvelope
    set?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    disconnect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    delete?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    update?: requirement_documentsUpdateWithWhereUniqueWithoutAi_sessionInput | requirement_documentsUpdateWithWhereUniqueWithoutAi_sessionInput[]
    updateMany?: requirement_documentsUpdateManyWithWhereWithoutAi_sessionInput | requirement_documentsUpdateManyWithWhereWithoutAi_sessionInput[]
    deleteMany?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
  }

  export type functional_test_casesCreateNestedManyWithoutRequirement_docInput = {
    create?: XOR<functional_test_casesCreateWithoutRequirement_docInput, functional_test_casesUncheckedCreateWithoutRequirement_docInput> | functional_test_casesCreateWithoutRequirement_docInput[] | functional_test_casesUncheckedCreateWithoutRequirement_docInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutRequirement_docInput | functional_test_casesCreateOrConnectWithoutRequirement_docInput[]
    createMany?: functional_test_casesCreateManyRequirement_docInputEnvelope
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
  }

  export type ai_generation_sessionsCreateNestedOneWithoutRequirement_documentsInput = {
    create?: XOR<ai_generation_sessionsCreateWithoutRequirement_documentsInput, ai_generation_sessionsUncheckedCreateWithoutRequirement_documentsInput>
    connectOrCreate?: ai_generation_sessionsCreateOrConnectWithoutRequirement_documentsInput
    connect?: ai_generation_sessionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutRequirement_documentsInput = {
    create?: XOR<usersCreateWithoutRequirement_documentsInput, usersUncheckedCreateWithoutRequirement_documentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRequirement_documentsInput
    connect?: usersWhereUniqueInput
  }

  export type systemsCreateNestedOneWithoutRequirement_documentsInput = {
    create?: XOR<systemsCreateWithoutRequirement_documentsInput, systemsUncheckedCreateWithoutRequirement_documentsInput>
    connectOrCreate?: systemsCreateOrConnectWithoutRequirement_documentsInput
    connect?: systemsWhereUniqueInput
  }

  export type project_versionsCreateNestedOneWithoutRequirement_documentsInput = {
    create?: XOR<project_versionsCreateWithoutRequirement_documentsInput, project_versionsUncheckedCreateWithoutRequirement_documentsInput>
    connectOrCreate?: project_versionsCreateOrConnectWithoutRequirement_documentsInput
    connect?: project_versionsWhereUniqueInput
  }

  export type functional_test_casesUncheckedCreateNestedManyWithoutRequirement_docInput = {
    create?: XOR<functional_test_casesCreateWithoutRequirement_docInput, functional_test_casesUncheckedCreateWithoutRequirement_docInput> | functional_test_casesCreateWithoutRequirement_docInput[] | functional_test_casesUncheckedCreateWithoutRequirement_docInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutRequirement_docInput | functional_test_casesCreateOrConnectWithoutRequirement_docInput[]
    createMany?: functional_test_casesCreateManyRequirement_docInputEnvelope
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
  }

  export type Enumrequirement_doc_statusFieldUpdateOperationsInput = {
    set?: $Enums.requirement_doc_status
  }

  export type functional_test_casesUpdateManyWithoutRequirement_docNestedInput = {
    create?: XOR<functional_test_casesCreateWithoutRequirement_docInput, functional_test_casesUncheckedCreateWithoutRequirement_docInput> | functional_test_casesCreateWithoutRequirement_docInput[] | functional_test_casesUncheckedCreateWithoutRequirement_docInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutRequirement_docInput | functional_test_casesCreateOrConnectWithoutRequirement_docInput[]
    upsert?: functional_test_casesUpsertWithWhereUniqueWithoutRequirement_docInput | functional_test_casesUpsertWithWhereUniqueWithoutRequirement_docInput[]
    createMany?: functional_test_casesCreateManyRequirement_docInputEnvelope
    set?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    disconnect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    delete?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    update?: functional_test_casesUpdateWithWhereUniqueWithoutRequirement_docInput | functional_test_casesUpdateWithWhereUniqueWithoutRequirement_docInput[]
    updateMany?: functional_test_casesUpdateManyWithWhereWithoutRequirement_docInput | functional_test_casesUpdateManyWithWhereWithoutRequirement_docInput[]
    deleteMany?: functional_test_casesScalarWhereInput | functional_test_casesScalarWhereInput[]
  }

  export type ai_generation_sessionsUpdateOneWithoutRequirement_documentsNestedInput = {
    create?: XOR<ai_generation_sessionsCreateWithoutRequirement_documentsInput, ai_generation_sessionsUncheckedCreateWithoutRequirement_documentsInput>
    connectOrCreate?: ai_generation_sessionsCreateOrConnectWithoutRequirement_documentsInput
    upsert?: ai_generation_sessionsUpsertWithoutRequirement_documentsInput
    disconnect?: ai_generation_sessionsWhereInput | boolean
    delete?: ai_generation_sessionsWhereInput | boolean
    connect?: ai_generation_sessionsWhereUniqueInput
    update?: XOR<XOR<ai_generation_sessionsUpdateToOneWithWhereWithoutRequirement_documentsInput, ai_generation_sessionsUpdateWithoutRequirement_documentsInput>, ai_generation_sessionsUncheckedUpdateWithoutRequirement_documentsInput>
  }

  export type usersUpdateOneRequiredWithoutRequirement_documentsNestedInput = {
    create?: XOR<usersCreateWithoutRequirement_documentsInput, usersUncheckedCreateWithoutRequirement_documentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRequirement_documentsInput
    upsert?: usersUpsertWithoutRequirement_documentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRequirement_documentsInput, usersUpdateWithoutRequirement_documentsInput>, usersUncheckedUpdateWithoutRequirement_documentsInput>
  }

  export type systemsUpdateOneWithoutRequirement_documentsNestedInput = {
    create?: XOR<systemsCreateWithoutRequirement_documentsInput, systemsUncheckedCreateWithoutRequirement_documentsInput>
    connectOrCreate?: systemsCreateOrConnectWithoutRequirement_documentsInput
    upsert?: systemsUpsertWithoutRequirement_documentsInput
    disconnect?: systemsWhereInput | boolean
    delete?: systemsWhereInput | boolean
    connect?: systemsWhereUniqueInput
    update?: XOR<XOR<systemsUpdateToOneWithWhereWithoutRequirement_documentsInput, systemsUpdateWithoutRequirement_documentsInput>, systemsUncheckedUpdateWithoutRequirement_documentsInput>
  }

  export type project_versionsUpdateOneWithoutRequirement_documentsNestedInput = {
    create?: XOR<project_versionsCreateWithoutRequirement_documentsInput, project_versionsUncheckedCreateWithoutRequirement_documentsInput>
    connectOrCreate?: project_versionsCreateOrConnectWithoutRequirement_documentsInput
    upsert?: project_versionsUpsertWithoutRequirement_documentsInput
    disconnect?: project_versionsWhereInput | boolean
    delete?: project_versionsWhereInput | boolean
    connect?: project_versionsWhereUniqueInput
    update?: XOR<XOR<project_versionsUpdateToOneWithWhereWithoutRequirement_documentsInput, project_versionsUpdateWithoutRequirement_documentsInput>, project_versionsUncheckedUpdateWithoutRequirement_documentsInput>
  }

  export type functional_test_casesUncheckedUpdateManyWithoutRequirement_docNestedInput = {
    create?: XOR<functional_test_casesCreateWithoutRequirement_docInput, functional_test_casesUncheckedCreateWithoutRequirement_docInput> | functional_test_casesCreateWithoutRequirement_docInput[] | functional_test_casesUncheckedCreateWithoutRequirement_docInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutRequirement_docInput | functional_test_casesCreateOrConnectWithoutRequirement_docInput[]
    upsert?: functional_test_casesUpsertWithWhereUniqueWithoutRequirement_docInput | functional_test_casesUpsertWithWhereUniqueWithoutRequirement_docInput[]
    createMany?: functional_test_casesCreateManyRequirement_docInputEnvelope
    set?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    disconnect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    delete?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    update?: functional_test_casesUpdateWithWhereUniqueWithoutRequirement_docInput | functional_test_casesUpdateWithWhereUniqueWithoutRequirement_docInput[]
    updateMany?: functional_test_casesUpdateManyWithWhereWithoutRequirement_docInput | functional_test_casesUpdateManyWithWhereWithoutRequirement_docInput[]
    deleteMany?: functional_test_casesScalarWhereInput | functional_test_casesScalarWhereInput[]
  }

  export type project_versionsCreateNestedManyWithoutProjectInput = {
    create?: XOR<project_versionsCreateWithoutProjectInput, project_versionsUncheckedCreateWithoutProjectInput> | project_versionsCreateWithoutProjectInput[] | project_versionsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: project_versionsCreateOrConnectWithoutProjectInput | project_versionsCreateOrConnectWithoutProjectInput[]
    createMany?: project_versionsCreateManyProjectInputEnvelope
    connect?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
  }

  export type requirement_documentsCreateNestedManyWithoutProjectInput = {
    create?: XOR<requirement_documentsCreateWithoutProjectInput, requirement_documentsUncheckedCreateWithoutProjectInput> | requirement_documentsCreateWithoutProjectInput[] | requirement_documentsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutProjectInput | requirement_documentsCreateOrConnectWithoutProjectInput[]
    createMany?: requirement_documentsCreateManyProjectInputEnvelope
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
  }

  export type project_versionsUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<project_versionsCreateWithoutProjectInput, project_versionsUncheckedCreateWithoutProjectInput> | project_versionsCreateWithoutProjectInput[] | project_versionsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: project_versionsCreateOrConnectWithoutProjectInput | project_versionsCreateOrConnectWithoutProjectInput[]
    createMany?: project_versionsCreateManyProjectInputEnvelope
    connect?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
  }

  export type requirement_documentsUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<requirement_documentsCreateWithoutProjectInput, requirement_documentsUncheckedCreateWithoutProjectInput> | requirement_documentsCreateWithoutProjectInput[] | requirement_documentsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutProjectInput | requirement_documentsCreateOrConnectWithoutProjectInput[]
    createMany?: requirement_documentsCreateManyProjectInputEnvelope
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
  }

  export type Enumsystem_statusFieldUpdateOperationsInput = {
    set?: $Enums.system_status
  }

  export type project_versionsUpdateManyWithoutProjectNestedInput = {
    create?: XOR<project_versionsCreateWithoutProjectInput, project_versionsUncheckedCreateWithoutProjectInput> | project_versionsCreateWithoutProjectInput[] | project_versionsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: project_versionsCreateOrConnectWithoutProjectInput | project_versionsCreateOrConnectWithoutProjectInput[]
    upsert?: project_versionsUpsertWithWhereUniqueWithoutProjectInput | project_versionsUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: project_versionsCreateManyProjectInputEnvelope
    set?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
    disconnect?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
    delete?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
    connect?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
    update?: project_versionsUpdateWithWhereUniqueWithoutProjectInput | project_versionsUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: project_versionsUpdateManyWithWhereWithoutProjectInput | project_versionsUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: project_versionsScalarWhereInput | project_versionsScalarWhereInput[]
  }

  export type requirement_documentsUpdateManyWithoutProjectNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutProjectInput, requirement_documentsUncheckedCreateWithoutProjectInput> | requirement_documentsCreateWithoutProjectInput[] | requirement_documentsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutProjectInput | requirement_documentsCreateOrConnectWithoutProjectInput[]
    upsert?: requirement_documentsUpsertWithWhereUniqueWithoutProjectInput | requirement_documentsUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: requirement_documentsCreateManyProjectInputEnvelope
    set?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    disconnect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    delete?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    update?: requirement_documentsUpdateWithWhereUniqueWithoutProjectInput | requirement_documentsUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: requirement_documentsUpdateManyWithWhereWithoutProjectInput | requirement_documentsUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
  }

  export type project_versionsUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<project_versionsCreateWithoutProjectInput, project_versionsUncheckedCreateWithoutProjectInput> | project_versionsCreateWithoutProjectInput[] | project_versionsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: project_versionsCreateOrConnectWithoutProjectInput | project_versionsCreateOrConnectWithoutProjectInput[]
    upsert?: project_versionsUpsertWithWhereUniqueWithoutProjectInput | project_versionsUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: project_versionsCreateManyProjectInputEnvelope
    set?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
    disconnect?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
    delete?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
    connect?: project_versionsWhereUniqueInput | project_versionsWhereUniqueInput[]
    update?: project_versionsUpdateWithWhereUniqueWithoutProjectInput | project_versionsUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: project_versionsUpdateManyWithWhereWithoutProjectInput | project_versionsUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: project_versionsScalarWhereInput | project_versionsScalarWhereInput[]
  }

  export type requirement_documentsUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutProjectInput, requirement_documentsUncheckedCreateWithoutProjectInput> | requirement_documentsCreateWithoutProjectInput[] | requirement_documentsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutProjectInput | requirement_documentsCreateOrConnectWithoutProjectInput[]
    upsert?: requirement_documentsUpsertWithWhereUniqueWithoutProjectInput | requirement_documentsUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: requirement_documentsCreateManyProjectInputEnvelope
    set?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    disconnect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    delete?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    update?: requirement_documentsUpdateWithWhereUniqueWithoutProjectInput | requirement_documentsUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: requirement_documentsUpdateManyWithWhereWithoutProjectInput | requirement_documentsUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
  }

  export type functional_test_casesCreateNestedManyWithoutProject_versionInput = {
    create?: XOR<functional_test_casesCreateWithoutProject_versionInput, functional_test_casesUncheckedCreateWithoutProject_versionInput> | functional_test_casesCreateWithoutProject_versionInput[] | functional_test_casesUncheckedCreateWithoutProject_versionInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutProject_versionInput | functional_test_casesCreateOrConnectWithoutProject_versionInput[]
    createMany?: functional_test_casesCreateManyProject_versionInputEnvelope
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
  }

  export type systemsCreateNestedOneWithoutVersionsInput = {
    create?: XOR<systemsCreateWithoutVersionsInput, systemsUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: systemsCreateOrConnectWithoutVersionsInput
    connect?: systemsWhereUniqueInput
  }

  export type requirement_documentsCreateNestedManyWithoutProject_versionInput = {
    create?: XOR<requirement_documentsCreateWithoutProject_versionInput, requirement_documentsUncheckedCreateWithoutProject_versionInput> | requirement_documentsCreateWithoutProject_versionInput[] | requirement_documentsUncheckedCreateWithoutProject_versionInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutProject_versionInput | requirement_documentsCreateOrConnectWithoutProject_versionInput[]
    createMany?: requirement_documentsCreateManyProject_versionInputEnvelope
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
  }

  export type functional_test_casesUncheckedCreateNestedManyWithoutProject_versionInput = {
    create?: XOR<functional_test_casesCreateWithoutProject_versionInput, functional_test_casesUncheckedCreateWithoutProject_versionInput> | functional_test_casesCreateWithoutProject_versionInput[] | functional_test_casesUncheckedCreateWithoutProject_versionInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutProject_versionInput | functional_test_casesCreateOrConnectWithoutProject_versionInput[]
    createMany?: functional_test_casesCreateManyProject_versionInputEnvelope
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
  }

  export type requirement_documentsUncheckedCreateNestedManyWithoutProject_versionInput = {
    create?: XOR<requirement_documentsCreateWithoutProject_versionInput, requirement_documentsUncheckedCreateWithoutProject_versionInput> | requirement_documentsCreateWithoutProject_versionInput[] | requirement_documentsUncheckedCreateWithoutProject_versionInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutProject_versionInput | requirement_documentsCreateOrConnectWithoutProject_versionInput[]
    createMany?: requirement_documentsCreateManyProject_versionInputEnvelope
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
  }

  export type functional_test_casesUpdateManyWithoutProject_versionNestedInput = {
    create?: XOR<functional_test_casesCreateWithoutProject_versionInput, functional_test_casesUncheckedCreateWithoutProject_versionInput> | functional_test_casesCreateWithoutProject_versionInput[] | functional_test_casesUncheckedCreateWithoutProject_versionInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutProject_versionInput | functional_test_casesCreateOrConnectWithoutProject_versionInput[]
    upsert?: functional_test_casesUpsertWithWhereUniqueWithoutProject_versionInput | functional_test_casesUpsertWithWhereUniqueWithoutProject_versionInput[]
    createMany?: functional_test_casesCreateManyProject_versionInputEnvelope
    set?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    disconnect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    delete?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    update?: functional_test_casesUpdateWithWhereUniqueWithoutProject_versionInput | functional_test_casesUpdateWithWhereUniqueWithoutProject_versionInput[]
    updateMany?: functional_test_casesUpdateManyWithWhereWithoutProject_versionInput | functional_test_casesUpdateManyWithWhereWithoutProject_versionInput[]
    deleteMany?: functional_test_casesScalarWhereInput | functional_test_casesScalarWhereInput[]
  }

  export type systemsUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<systemsCreateWithoutVersionsInput, systemsUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: systemsCreateOrConnectWithoutVersionsInput
    upsert?: systemsUpsertWithoutVersionsInput
    connect?: systemsWhereUniqueInput
    update?: XOR<XOR<systemsUpdateToOneWithWhereWithoutVersionsInput, systemsUpdateWithoutVersionsInput>, systemsUncheckedUpdateWithoutVersionsInput>
  }

  export type requirement_documentsUpdateManyWithoutProject_versionNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutProject_versionInput, requirement_documentsUncheckedCreateWithoutProject_versionInput> | requirement_documentsCreateWithoutProject_versionInput[] | requirement_documentsUncheckedCreateWithoutProject_versionInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutProject_versionInput | requirement_documentsCreateOrConnectWithoutProject_versionInput[]
    upsert?: requirement_documentsUpsertWithWhereUniqueWithoutProject_versionInput | requirement_documentsUpsertWithWhereUniqueWithoutProject_versionInput[]
    createMany?: requirement_documentsCreateManyProject_versionInputEnvelope
    set?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    disconnect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    delete?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    update?: requirement_documentsUpdateWithWhereUniqueWithoutProject_versionInput | requirement_documentsUpdateWithWhereUniqueWithoutProject_versionInput[]
    updateMany?: requirement_documentsUpdateManyWithWhereWithoutProject_versionInput | requirement_documentsUpdateManyWithWhereWithoutProject_versionInput[]
    deleteMany?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
  }

  export type functional_test_casesUncheckedUpdateManyWithoutProject_versionNestedInput = {
    create?: XOR<functional_test_casesCreateWithoutProject_versionInput, functional_test_casesUncheckedCreateWithoutProject_versionInput> | functional_test_casesCreateWithoutProject_versionInput[] | functional_test_casesUncheckedCreateWithoutProject_versionInput[]
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutProject_versionInput | functional_test_casesCreateOrConnectWithoutProject_versionInput[]
    upsert?: functional_test_casesUpsertWithWhereUniqueWithoutProject_versionInput | functional_test_casesUpsertWithWhereUniqueWithoutProject_versionInput[]
    createMany?: functional_test_casesCreateManyProject_versionInputEnvelope
    set?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    disconnect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    delete?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    connect?: functional_test_casesWhereUniqueInput | functional_test_casesWhereUniqueInput[]
    update?: functional_test_casesUpdateWithWhereUniqueWithoutProject_versionInput | functional_test_casesUpdateWithWhereUniqueWithoutProject_versionInput[]
    updateMany?: functional_test_casesUpdateManyWithWhereWithoutProject_versionInput | functional_test_casesUpdateManyWithWhereWithoutProject_versionInput[]
    deleteMany?: functional_test_casesScalarWhereInput | functional_test_casesScalarWhereInput[]
  }

  export type requirement_documentsUncheckedUpdateManyWithoutProject_versionNestedInput = {
    create?: XOR<requirement_documentsCreateWithoutProject_versionInput, requirement_documentsUncheckedCreateWithoutProject_versionInput> | requirement_documentsCreateWithoutProject_versionInput[] | requirement_documentsUncheckedCreateWithoutProject_versionInput[]
    connectOrCreate?: requirement_documentsCreateOrConnectWithoutProject_versionInput | requirement_documentsCreateOrConnectWithoutProject_versionInput[]
    upsert?: requirement_documentsUpsertWithWhereUniqueWithoutProject_versionInput | requirement_documentsUpsertWithWhereUniqueWithoutProject_versionInput[]
    createMany?: requirement_documentsCreateManyProject_versionInputEnvelope
    set?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    disconnect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    delete?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    connect?: requirement_documentsWhereUniqueInput | requirement_documentsWhereUniqueInput[]
    update?: requirement_documentsUpdateWithWhereUniqueWithoutProject_versionInput | requirement_documentsUpdateWithWhereUniqueWithoutProject_versionInput[]
    updateMany?: requirement_documentsUpdateManyWithWhereWithoutProject_versionInput | requirement_documentsUpdateManyWithWhereWithoutProject_versionInput[]
    deleteMany?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
  }

  export type functional_test_casesCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<functional_test_casesCreateWithoutExecutionsInput, functional_test_casesUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutExecutionsInput
    connect?: functional_test_casesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFunctional_test_executionsInput = {
    create?: XOR<usersCreateWithoutFunctional_test_executionsInput, usersUncheckedCreateWithoutFunctional_test_executionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutFunctional_test_executionsInput
    connect?: usersWhereUniqueInput
  }

  export type Enumfunctional_execution_resultFieldUpdateOperationsInput = {
    set?: $Enums.functional_execution_result
  }

  export type functional_test_casesUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<functional_test_casesCreateWithoutExecutionsInput, functional_test_casesUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: functional_test_casesCreateOrConnectWithoutExecutionsInput
    upsert?: functional_test_casesUpsertWithoutExecutionsInput
    connect?: functional_test_casesWhereUniqueInput
    update?: XOR<XOR<functional_test_casesUpdateToOneWithWhereWithoutExecutionsInput, functional_test_casesUpdateWithoutExecutionsInput>, functional_test_casesUncheckedUpdateWithoutExecutionsInput>
  }

  export type usersUpdateOneRequiredWithoutFunctional_test_executionsNestedInput = {
    create?: XOR<usersCreateWithoutFunctional_test_executionsInput, usersUncheckedCreateWithoutFunctional_test_executionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutFunctional_test_executionsInput
    upsert?: usersUpsertWithoutFunctional_test_executionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFunctional_test_executionsInput, usersUpdateWithoutFunctional_test_executionsInput>, usersUncheckedUpdateWithoutFunctional_test_executionsInput>
  }

  export type usersCreateNestedOneWithoutTest_plansInput = {
    create?: XOR<usersCreateWithoutTest_plansInput, usersUncheckedCreateWithoutTest_plansInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_plansInput
    connect?: usersWhereUniqueInput
  }

  export type test_plan_casesCreateNestedManyWithoutPlanInput = {
    create?: XOR<test_plan_casesCreateWithoutPlanInput, test_plan_casesUncheckedCreateWithoutPlanInput> | test_plan_casesCreateWithoutPlanInput[] | test_plan_casesUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: test_plan_casesCreateOrConnectWithoutPlanInput | test_plan_casesCreateOrConnectWithoutPlanInput[]
    createMany?: test_plan_casesCreateManyPlanInputEnvelope
    connect?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
  }

  export type test_plan_executionsCreateNestedManyWithoutPlanInput = {
    create?: XOR<test_plan_executionsCreateWithoutPlanInput, test_plan_executionsUncheckedCreateWithoutPlanInput> | test_plan_executionsCreateWithoutPlanInput[] | test_plan_executionsUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: test_plan_executionsCreateOrConnectWithoutPlanInput | test_plan_executionsCreateOrConnectWithoutPlanInput[]
    createMany?: test_plan_executionsCreateManyPlanInputEnvelope
    connect?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
  }

  export type test_plan_casesUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<test_plan_casesCreateWithoutPlanInput, test_plan_casesUncheckedCreateWithoutPlanInput> | test_plan_casesCreateWithoutPlanInput[] | test_plan_casesUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: test_plan_casesCreateOrConnectWithoutPlanInput | test_plan_casesCreateOrConnectWithoutPlanInput[]
    createMany?: test_plan_casesCreateManyPlanInputEnvelope
    connect?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
  }

  export type test_plan_executionsUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<test_plan_executionsCreateWithoutPlanInput, test_plan_executionsUncheckedCreateWithoutPlanInput> | test_plan_executionsCreateWithoutPlanInput[] | test_plan_executionsUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: test_plan_executionsCreateOrConnectWithoutPlanInput | test_plan_executionsCreateOrConnectWithoutPlanInput[]
    createMany?: test_plan_executionsCreateManyPlanInputEnvelope
    connect?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
  }

  export type Enumtest_plan_typeFieldUpdateOperationsInput = {
    set?: $Enums.test_plan_type
  }

  export type Enumtest_plan_statusFieldUpdateOperationsInput = {
    set?: $Enums.test_plan_status
  }

  export type usersUpdateOneRequiredWithoutTest_plansNestedInput = {
    create?: XOR<usersCreateWithoutTest_plansInput, usersUncheckedCreateWithoutTest_plansInput>
    connectOrCreate?: usersCreateOrConnectWithoutTest_plansInput
    upsert?: usersUpsertWithoutTest_plansInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTest_plansInput, usersUpdateWithoutTest_plansInput>, usersUncheckedUpdateWithoutTest_plansInput>
  }

  export type test_plan_casesUpdateManyWithoutPlanNestedInput = {
    create?: XOR<test_plan_casesCreateWithoutPlanInput, test_plan_casesUncheckedCreateWithoutPlanInput> | test_plan_casesCreateWithoutPlanInput[] | test_plan_casesUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: test_plan_casesCreateOrConnectWithoutPlanInput | test_plan_casesCreateOrConnectWithoutPlanInput[]
    upsert?: test_plan_casesUpsertWithWhereUniqueWithoutPlanInput | test_plan_casesUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: test_plan_casesCreateManyPlanInputEnvelope
    set?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
    disconnect?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
    delete?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
    connect?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
    update?: test_plan_casesUpdateWithWhereUniqueWithoutPlanInput | test_plan_casesUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: test_plan_casesUpdateManyWithWhereWithoutPlanInput | test_plan_casesUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: test_plan_casesScalarWhereInput | test_plan_casesScalarWhereInput[]
  }

  export type test_plan_executionsUpdateManyWithoutPlanNestedInput = {
    create?: XOR<test_plan_executionsCreateWithoutPlanInput, test_plan_executionsUncheckedCreateWithoutPlanInput> | test_plan_executionsCreateWithoutPlanInput[] | test_plan_executionsUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: test_plan_executionsCreateOrConnectWithoutPlanInput | test_plan_executionsCreateOrConnectWithoutPlanInput[]
    upsert?: test_plan_executionsUpsertWithWhereUniqueWithoutPlanInput | test_plan_executionsUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: test_plan_executionsCreateManyPlanInputEnvelope
    set?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
    disconnect?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
    delete?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
    connect?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
    update?: test_plan_executionsUpdateWithWhereUniqueWithoutPlanInput | test_plan_executionsUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: test_plan_executionsUpdateManyWithWhereWithoutPlanInput | test_plan_executionsUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: test_plan_executionsScalarWhereInput | test_plan_executionsScalarWhereInput[]
  }

  export type test_plan_casesUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<test_plan_casesCreateWithoutPlanInput, test_plan_casesUncheckedCreateWithoutPlanInput> | test_plan_casesCreateWithoutPlanInput[] | test_plan_casesUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: test_plan_casesCreateOrConnectWithoutPlanInput | test_plan_casesCreateOrConnectWithoutPlanInput[]
    upsert?: test_plan_casesUpsertWithWhereUniqueWithoutPlanInput | test_plan_casesUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: test_plan_casesCreateManyPlanInputEnvelope
    set?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
    disconnect?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
    delete?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
    connect?: test_plan_casesWhereUniqueInput | test_plan_casesWhereUniqueInput[]
    update?: test_plan_casesUpdateWithWhereUniqueWithoutPlanInput | test_plan_casesUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: test_plan_casesUpdateManyWithWhereWithoutPlanInput | test_plan_casesUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: test_plan_casesScalarWhereInput | test_plan_casesScalarWhereInput[]
  }

  export type test_plan_executionsUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<test_plan_executionsCreateWithoutPlanInput, test_plan_executionsUncheckedCreateWithoutPlanInput> | test_plan_executionsCreateWithoutPlanInput[] | test_plan_executionsUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: test_plan_executionsCreateOrConnectWithoutPlanInput | test_plan_executionsCreateOrConnectWithoutPlanInput[]
    upsert?: test_plan_executionsUpsertWithWhereUniqueWithoutPlanInput | test_plan_executionsUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: test_plan_executionsCreateManyPlanInputEnvelope
    set?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
    disconnect?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
    delete?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
    connect?: test_plan_executionsWhereUniqueInput | test_plan_executionsWhereUniqueInput[]
    update?: test_plan_executionsUpdateWithWhereUniqueWithoutPlanInput | test_plan_executionsUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: test_plan_executionsUpdateManyWithWhereWithoutPlanInput | test_plan_executionsUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: test_plan_executionsScalarWhereInput | test_plan_executionsScalarWhereInput[]
  }

  export type test_plansCreateNestedOneWithoutPlan_casesInput = {
    create?: XOR<test_plansCreateWithoutPlan_casesInput, test_plansUncheckedCreateWithoutPlan_casesInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutPlan_casesInput
    connect?: test_plansWhereUniqueInput
  }

  export type test_plansUpdateOneRequiredWithoutPlan_casesNestedInput = {
    create?: XOR<test_plansCreateWithoutPlan_casesInput, test_plansUncheckedCreateWithoutPlan_casesInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutPlan_casesInput
    upsert?: test_plansUpsertWithoutPlan_casesInput
    connect?: test_plansWhereUniqueInput
    update?: XOR<XOR<test_plansUpdateToOneWithWhereWithoutPlan_casesInput, test_plansUpdateWithoutPlan_casesInput>, test_plansUncheckedUpdateWithoutPlan_casesInput>
  }

  export type test_plansCreateNestedOneWithoutPlan_executionsInput = {
    create?: XOR<test_plansCreateWithoutPlan_executionsInput, test_plansUncheckedCreateWithoutPlan_executionsInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutPlan_executionsInput
    connect?: test_plansWhereUniqueInput
  }

  export type test_plansUpdateOneRequiredWithoutPlan_executionsNestedInput = {
    create?: XOR<test_plansCreateWithoutPlan_executionsInput, test_plansUncheckedCreateWithoutPlan_executionsInput>
    connectOrCreate?: test_plansCreateOrConnectWithoutPlan_executionsInput
    upsert?: test_plansUpsertWithoutPlan_executionsInput
    connect?: test_plansWhereUniqueInput
    update?: XOR<XOR<test_plansUpdateToOneWithWhereWithoutPlan_executionsInput, test_plansUpdateWithoutPlan_executionsInput>, test_plansUncheckedUpdateWithoutPlan_executionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumjob_logs_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.job_logs_status | Enumjob_logs_statusFieldRefInput<$PrismaModel>
    in?: $Enums.job_logs_status[]
    notIn?: $Enums.job_logs_status[]
    not?: NestedEnumjob_logs_statusFilter<$PrismaModel> | $Enums.job_logs_status
  }

  export type NestedEnumjob_logs_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.job_logs_status | Enumjob_logs_statusFieldRefInput<$PrismaModel>
    in?: $Enums.job_logs_status[]
    notIn?: $Enums.job_logs_status[]
    not?: NestedEnumjob_logs_statusWithAggregatesFilter<$PrismaModel> | $Enums.job_logs_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjob_logs_statusFilter<$PrismaModel>
    _max?: NestedEnumjob_logs_statusFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumstep_screenshots_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.step_screenshots_status | Enumstep_screenshots_statusFieldRefInput<$PrismaModel>
    in?: $Enums.step_screenshots_status[]
    notIn?: $Enums.step_screenshots_status[]
    not?: NestedEnumstep_screenshots_statusFilter<$PrismaModel> | $Enums.step_screenshots_status
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumstep_screenshots_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.step_screenshots_status | Enumstep_screenshots_statusFieldRefInput<$PrismaModel>
    in?: $Enums.step_screenshots_status[]
    notIn?: $Enums.step_screenshots_status[]
    not?: NestedEnumstep_screenshots_statusWithAggregatesFilter<$PrismaModel> | $Enums.step_screenshots_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstep_screenshots_statusFilter<$PrismaModel>
    _max?: NestedEnumstep_screenshots_statusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumtest_run_results_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_run_results_status | Enumtest_run_results_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_run_results_status[]
    notIn?: $Enums.test_run_results_status[]
    not?: NestedEnumtest_run_results_statusFilter<$PrismaModel> | $Enums.test_run_results_status
  }

  export type NestedEnumtest_run_results_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_run_results_status | Enumtest_run_results_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_run_results_status[]
    notIn?: $Enums.test_run_results_status[]
    not?: NestedEnumtest_run_results_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_run_results_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_run_results_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_run_results_statusFilter<$PrismaModel>
  }

  export type NestedEnumtest_runs_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_runs_status | Enumtest_runs_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_runs_status[]
    notIn?: $Enums.test_runs_status[]
    not?: NestedEnumtest_runs_statusFilter<$PrismaModel> | $Enums.test_runs_status
  }

  export type NestedEnumtest_runs_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_runs_status | Enumtest_runs_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_runs_status[]
    notIn?: $Enums.test_runs_status[]
    not?: NestedEnumtest_runs_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_runs_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_runs_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_runs_statusFilter<$PrismaModel>
  }

  export type NestedEnumbulk_edit_sessions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.bulk_edit_sessions_status | Enumbulk_edit_sessions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.bulk_edit_sessions_status[]
    notIn?: $Enums.bulk_edit_sessions_status[]
    not?: NestedEnumbulk_edit_sessions_statusFilter<$PrismaModel> | $Enums.bulk_edit_sessions_status
  }

  export type NestedEnumbulk_edit_sessions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.bulk_edit_sessions_status | Enumbulk_edit_sessions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.bulk_edit_sessions_status[]
    notIn?: $Enums.bulk_edit_sessions_status[]
    not?: NestedEnumbulk_edit_sessions_statusWithAggregatesFilter<$PrismaModel> | $Enums.bulk_edit_sessions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbulk_edit_sessions_statusFilter<$PrismaModel>
    _max?: NestedEnumbulk_edit_sessions_statusFilter<$PrismaModel>
  }

  export type NestedEnumproposal_risk_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.proposal_risk_level | Enumproposal_risk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.proposal_risk_level[]
    notIn?: $Enums.proposal_risk_level[]
    not?: NestedEnumproposal_risk_levelFilter<$PrismaModel> | $Enums.proposal_risk_level
  }

  export type NestedEnumproposal_apply_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.proposal_apply_status | Enumproposal_apply_statusFieldRefInput<$PrismaModel>
    in?: $Enums.proposal_apply_status[]
    notIn?: $Enums.proposal_apply_status[]
    not?: NestedEnumproposal_apply_statusFilter<$PrismaModel> | $Enums.proposal_apply_status
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumproposal_risk_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.proposal_risk_level | Enumproposal_risk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.proposal_risk_level[]
    notIn?: $Enums.proposal_risk_level[]
    not?: NestedEnumproposal_risk_levelWithAggregatesFilter<$PrismaModel> | $Enums.proposal_risk_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumproposal_risk_levelFilter<$PrismaModel>
    _max?: NestedEnumproposal_risk_levelFilter<$PrismaModel>
  }

  export type NestedEnumproposal_apply_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.proposal_apply_status | Enumproposal_apply_statusFieldRefInput<$PrismaModel>
    in?: $Enums.proposal_apply_status[]
    notIn?: $Enums.proposal_apply_status[]
    not?: NestedEnumproposal_apply_statusWithAggregatesFilter<$PrismaModel> | $Enums.proposal_apply_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumproposal_apply_statusFilter<$PrismaModel>
    _max?: NestedEnumproposal_apply_statusFilter<$PrismaModel>
  }

  export type NestedEnumtest_case_execution_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_case_execution_status | Enumtest_case_execution_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_case_execution_status[]
    notIn?: $Enums.test_case_execution_status[]
    not?: NestedEnumtest_case_execution_statusFilter<$PrismaModel> | $Enums.test_case_execution_status
  }

  export type NestedEnumtest_case_execution_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_case_execution_status | Enumtest_case_execution_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_case_execution_status[]
    notIn?: $Enums.test_case_execution_status[]
    not?: NestedEnumtest_case_execution_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_case_execution_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_case_execution_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_case_execution_statusFilter<$PrismaModel>
  }

  export type NestedEnumfunctional_test_priorityFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_priority | Enumfunctional_test_priorityFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_priority[]
    notIn?: $Enums.functional_test_priority[]
    not?: NestedEnumfunctional_test_priorityFilter<$PrismaModel> | $Enums.functional_test_priority
  }

  export type NestedEnumfunctional_test_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_status | Enumfunctional_test_statusFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_status[]
    notIn?: $Enums.functional_test_status[]
    not?: NestedEnumfunctional_test_statusFilter<$PrismaModel> | $Enums.functional_test_status
  }

  export type NestedEnumfunctional_test_sourceFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_source | Enumfunctional_test_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_source[]
    notIn?: $Enums.functional_test_source[]
    not?: NestedEnumfunctional_test_sourceFilter<$PrismaModel> | $Enums.functional_test_source
  }

  export type NestedEnumfunctional_case_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_case_type | Enumfunctional_case_typeFieldRefInput<$PrismaModel>
    in?: $Enums.functional_case_type[]
    notIn?: $Enums.functional_case_type[]
    not?: NestedEnumfunctional_case_typeFilter<$PrismaModel> | $Enums.functional_case_type
  }

  export type NestedEnumfunctional_risk_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_risk_level | Enumfunctional_risk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.functional_risk_level[]
    notIn?: $Enums.functional_risk_level[]
    not?: NestedEnumfunctional_risk_levelFilter<$PrismaModel> | $Enums.functional_risk_level
  }

  export type NestedEnumfunctional_test_priorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_priority | Enumfunctional_test_priorityFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_priority[]
    notIn?: $Enums.functional_test_priority[]
    not?: NestedEnumfunctional_test_priorityWithAggregatesFilter<$PrismaModel> | $Enums.functional_test_priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_test_priorityFilter<$PrismaModel>
    _max?: NestedEnumfunctional_test_priorityFilter<$PrismaModel>
  }

  export type NestedEnumfunctional_test_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_status | Enumfunctional_test_statusFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_status[]
    notIn?: $Enums.functional_test_status[]
    not?: NestedEnumfunctional_test_statusWithAggregatesFilter<$PrismaModel> | $Enums.functional_test_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_test_statusFilter<$PrismaModel>
    _max?: NestedEnumfunctional_test_statusFilter<$PrismaModel>
  }

  export type NestedEnumfunctional_test_sourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_test_source | Enumfunctional_test_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.functional_test_source[]
    notIn?: $Enums.functional_test_source[]
    not?: NestedEnumfunctional_test_sourceWithAggregatesFilter<$PrismaModel> | $Enums.functional_test_source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_test_sourceFilter<$PrismaModel>
    _max?: NestedEnumfunctional_test_sourceFilter<$PrismaModel>
  }

  export type NestedEnumfunctional_case_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_case_type | Enumfunctional_case_typeFieldRefInput<$PrismaModel>
    in?: $Enums.functional_case_type[]
    notIn?: $Enums.functional_case_type[]
    not?: NestedEnumfunctional_case_typeWithAggregatesFilter<$PrismaModel> | $Enums.functional_case_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_case_typeFilter<$PrismaModel>
    _max?: NestedEnumfunctional_case_typeFilter<$PrismaModel>
  }

  export type NestedEnumfunctional_risk_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_risk_level | Enumfunctional_risk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.functional_risk_level[]
    notIn?: $Enums.functional_risk_level[]
    not?: NestedEnumfunctional_risk_levelWithAggregatesFilter<$PrismaModel> | $Enums.functional_risk_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_risk_levelFilter<$PrismaModel>
    _max?: NestedEnumfunctional_risk_levelFilter<$PrismaModel>
  }

  export type NestedEnumrequirement_doc_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.requirement_doc_status | Enumrequirement_doc_statusFieldRefInput<$PrismaModel>
    in?: $Enums.requirement_doc_status[]
    notIn?: $Enums.requirement_doc_status[]
    not?: NestedEnumrequirement_doc_statusFilter<$PrismaModel> | $Enums.requirement_doc_status
  }

  export type NestedEnumrequirement_doc_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.requirement_doc_status | Enumrequirement_doc_statusFieldRefInput<$PrismaModel>
    in?: $Enums.requirement_doc_status[]
    notIn?: $Enums.requirement_doc_status[]
    not?: NestedEnumrequirement_doc_statusWithAggregatesFilter<$PrismaModel> | $Enums.requirement_doc_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrequirement_doc_statusFilter<$PrismaModel>
    _max?: NestedEnumrequirement_doc_statusFilter<$PrismaModel>
  }

  export type NestedEnumsystem_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.system_status | Enumsystem_statusFieldRefInput<$PrismaModel>
    in?: $Enums.system_status[]
    notIn?: $Enums.system_status[]
    not?: NestedEnumsystem_statusFilter<$PrismaModel> | $Enums.system_status
  }

  export type NestedEnumsystem_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.system_status | Enumsystem_statusFieldRefInput<$PrismaModel>
    in?: $Enums.system_status[]
    notIn?: $Enums.system_status[]
    not?: NestedEnumsystem_statusWithAggregatesFilter<$PrismaModel> | $Enums.system_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsystem_statusFilter<$PrismaModel>
    _max?: NestedEnumsystem_statusFilter<$PrismaModel>
  }

  export type NestedEnumfunctional_execution_resultFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_execution_result | Enumfunctional_execution_resultFieldRefInput<$PrismaModel>
    in?: $Enums.functional_execution_result[]
    notIn?: $Enums.functional_execution_result[]
    not?: NestedEnumfunctional_execution_resultFilter<$PrismaModel> | $Enums.functional_execution_result
  }

  export type NestedEnumfunctional_execution_resultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.functional_execution_result | Enumfunctional_execution_resultFieldRefInput<$PrismaModel>
    in?: $Enums.functional_execution_result[]
    notIn?: $Enums.functional_execution_result[]
    not?: NestedEnumfunctional_execution_resultWithAggregatesFilter<$PrismaModel> | $Enums.functional_execution_result
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfunctional_execution_resultFilter<$PrismaModel>
    _max?: NestedEnumfunctional_execution_resultFilter<$PrismaModel>
  }

  export type NestedEnumtest_plan_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plan_type | Enumtest_plan_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plan_type[]
    notIn?: $Enums.test_plan_type[]
    not?: NestedEnumtest_plan_typeFilter<$PrismaModel> | $Enums.test_plan_type
  }

  export type NestedEnumtest_plan_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plan_status | Enumtest_plan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_plan_status[]
    notIn?: $Enums.test_plan_status[]
    not?: NestedEnumtest_plan_statusFilter<$PrismaModel> | $Enums.test_plan_status
  }

  export type NestedEnumtest_plan_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plan_type | Enumtest_plan_typeFieldRefInput<$PrismaModel>
    in?: $Enums.test_plan_type[]
    notIn?: $Enums.test_plan_type[]
    not?: NestedEnumtest_plan_typeWithAggregatesFilter<$PrismaModel> | $Enums.test_plan_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_plan_typeFilter<$PrismaModel>
    _max?: NestedEnumtest_plan_typeFilter<$PrismaModel>
  }

  export type NestedEnumtest_plan_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_plan_status | Enumtest_plan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.test_plan_status[]
    notIn?: $Enums.test_plan_status[]
    not?: NestedEnumtest_plan_statusWithAggregatesFilter<$PrismaModel> | $Enums.test_plan_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtest_plan_statusFilter<$PrismaModel>
    _max?: NestedEnumtest_plan_statusFilter<$PrismaModel>
  }

  export type ai_runsCreateWithoutAi_promptsInput = {
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
    test_runs?: test_runsCreateNestedOneWithoutAi_runsInput
  }

  export type ai_runsUncheckedCreateWithoutAi_promptsInput = {
    id?: number
    run_id?: number | null
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
  }

  export type ai_runsCreateOrConnectWithoutAi_promptsInput = {
    where: ai_runsWhereUniqueInput
    create: XOR<ai_runsCreateWithoutAi_promptsInput, ai_runsUncheckedCreateWithoutAi_promptsInput>
  }

  export type ai_runsCreateManyAi_promptsInputEnvelope = {
    data: ai_runsCreateManyAi_promptsInput | ai_runsCreateManyAi_promptsInput[]
    skipDuplicates?: boolean
  }

  export type ai_runsUpsertWithWhereUniqueWithoutAi_promptsInput = {
    where: ai_runsWhereUniqueInput
    update: XOR<ai_runsUpdateWithoutAi_promptsInput, ai_runsUncheckedUpdateWithoutAi_promptsInput>
    create: XOR<ai_runsCreateWithoutAi_promptsInput, ai_runsUncheckedCreateWithoutAi_promptsInput>
  }

  export type ai_runsUpdateWithWhereUniqueWithoutAi_promptsInput = {
    where: ai_runsWhereUniqueInput
    data: XOR<ai_runsUpdateWithoutAi_promptsInput, ai_runsUncheckedUpdateWithoutAi_promptsInput>
  }

  export type ai_runsUpdateManyWithWhereWithoutAi_promptsInput = {
    where: ai_runsScalarWhereInput
    data: XOR<ai_runsUpdateManyMutationInput, ai_runsUncheckedUpdateManyWithoutAi_promptsInput>
  }

  export type ai_runsScalarWhereInput = {
    AND?: ai_runsScalarWhereInput | ai_runsScalarWhereInput[]
    OR?: ai_runsScalarWhereInput[]
    NOT?: ai_runsScalarWhereInput | ai_runsScalarWhereInput[]
    id?: IntFilter<"ai_runs"> | number
    prompt_id?: IntFilter<"ai_runs"> | number
    run_id?: IntNullableFilter<"ai_runs"> | number | null
    token_used?: IntNullableFilter<"ai_runs"> | number | null
    cost_usd?: DecimalNullableFilter<"ai_runs"> | Decimal | DecimalJsLike | number | string | null
    executed_at?: DateTimeNullableFilter<"ai_runs"> | Date | string | null
  }

  export type ai_promptsCreateWithoutAi_runsInput = {
    name: string
    version: number
    template: string
    created_at?: Date | string | null
  }

  export type ai_promptsUncheckedCreateWithoutAi_runsInput = {
    id?: number
    name: string
    version: number
    template: string
    created_at?: Date | string | null
  }

  export type ai_promptsCreateOrConnectWithoutAi_runsInput = {
    where: ai_promptsWhereUniqueInput
    create: XOR<ai_promptsCreateWithoutAi_runsInput, ai_promptsUncheckedCreateWithoutAi_runsInput>
  }

  export type test_runsCreateWithoutAi_runsInput = {
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    reports?: reportsCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_runsInput
    test_suites: test_suitesCreateNestedOneWithoutTest_runsInput
    users: usersCreateNestedOneWithoutTest_runsInput
  }

  export type test_runsUncheckedCreateWithoutAi_runsInput = {
    id?: number
    suite_id: number
    trigger_user_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    reports?: reportsUncheckedCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_runsInput
  }

  export type test_runsCreateOrConnectWithoutAi_runsInput = {
    where: test_runsWhereUniqueInput
    create: XOR<test_runsCreateWithoutAi_runsInput, test_runsUncheckedCreateWithoutAi_runsInput>
  }

  export type ai_promptsUpsertWithoutAi_runsInput = {
    update: XOR<ai_promptsUpdateWithoutAi_runsInput, ai_promptsUncheckedUpdateWithoutAi_runsInput>
    create: XOR<ai_promptsCreateWithoutAi_runsInput, ai_promptsUncheckedCreateWithoutAi_runsInput>
    where?: ai_promptsWhereInput
  }

  export type ai_promptsUpdateToOneWithWhereWithoutAi_runsInput = {
    where?: ai_promptsWhereInput
    data: XOR<ai_promptsUpdateWithoutAi_runsInput, ai_promptsUncheckedUpdateWithoutAi_runsInput>
  }

  export type ai_promptsUpdateWithoutAi_runsInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    template?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_promptsUncheckedUpdateWithoutAi_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    template?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_runsUpsertWithoutAi_runsInput = {
    update: XOR<test_runsUpdateWithoutAi_runsInput, test_runsUncheckedUpdateWithoutAi_runsInput>
    create: XOR<test_runsCreateWithoutAi_runsInput, test_runsUncheckedCreateWithoutAi_runsInput>
    where?: test_runsWhereInput
  }

  export type test_runsUpdateToOneWithWhereWithoutAi_runsInput = {
    where?: test_runsWhereInput
    data: XOR<test_runsUpdateWithoutAi_runsInput, test_runsUncheckedUpdateWithoutAi_runsInput>
  }

  export type test_runsUpdateWithoutAi_runsInput = {
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: reportsUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_runsNestedInput
    test_suites?: test_suitesUpdateOneRequiredWithoutTest_runsNestedInput
    users?: usersUpdateOneRequiredWithoutTest_runsNestedInput
  }

  export type test_runsUncheckedUpdateWithoutAi_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    suite_id?: IntFieldUpdateOperationsInput | number
    trigger_user_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: reportsUncheckedUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_runsNestedInput
  }

  export type usersCreateWithoutApi_tokensInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutApi_tokensInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutApi_tokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutApi_tokensInput, usersUncheckedCreateWithoutApi_tokensInput>
  }

  export type usersUpsertWithoutApi_tokensInput = {
    update: XOR<usersUpdateWithoutApi_tokensInput, usersUncheckedUpdateWithoutApi_tokensInput>
    create: XOR<usersCreateWithoutApi_tokensInput, usersUncheckedCreateWithoutApi_tokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutApi_tokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutApi_tokensInput, usersUncheckedUpdateWithoutApi_tokensInput>
  }

  export type usersUpdateWithoutApi_tokensInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutApi_tokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type test_run_resultsCreateWithoutAttachmentsInput = {
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
    test_runs: test_runsCreateNestedOneWithoutTest_run_resultsInput
    test_cases: test_casesCreateNestedOneWithoutTest_run_resultsInput
  }

  export type test_run_resultsUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    run_id: number
    case_id: number
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
  }

  export type test_run_resultsCreateOrConnectWithoutAttachmentsInput = {
    where: test_run_resultsWhereUniqueInput
    create: XOR<test_run_resultsCreateWithoutAttachmentsInput, test_run_resultsUncheckedCreateWithoutAttachmentsInput>
  }

  export type test_run_resultsUpsertWithoutAttachmentsInput = {
    update: XOR<test_run_resultsUpdateWithoutAttachmentsInput, test_run_resultsUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<test_run_resultsCreateWithoutAttachmentsInput, test_run_resultsUncheckedCreateWithoutAttachmentsInput>
    where?: test_run_resultsWhereInput
  }

  export type test_run_resultsUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: test_run_resultsWhereInput
    data: XOR<test_run_resultsUpdateWithoutAttachmentsInput, test_run_resultsUncheckedUpdateWithoutAttachmentsInput>
  }

  export type test_run_resultsUpdateWithoutAttachmentsInput = {
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_runs?: test_runsUpdateOneRequiredWithoutTest_run_resultsNestedInput
    test_cases?: test_casesUpdateOneRequiredWithoutTest_run_resultsNestedInput
  }

  export type test_run_resultsUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateWithoutAudit_logsInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutAudit_logsInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutAudit_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
  }

  export type usersUpsertWithoutAudit_logsInput = {
    update: XOR<usersUpdateWithoutAudit_logsInput, usersUncheckedUpdateWithoutAudit_logsInput>
    create: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAudit_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAudit_logsInput, usersUncheckedUpdateWithoutAudit_logsInput>
  }

  export type usersUpdateWithoutAudit_logsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutAudit_logsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type test_runsCreateWithoutReportsInput = {
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_runsInput
    test_suites: test_suitesCreateNestedOneWithoutTest_runsInput
    users: usersCreateNestedOneWithoutTest_runsInput
  }

  export type test_runsUncheckedCreateWithoutReportsInput = {
    id?: number
    suite_id: number
    trigger_user_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsUncheckedCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_runsInput
  }

  export type test_runsCreateOrConnectWithoutReportsInput = {
    where: test_runsWhereUniqueInput
    create: XOR<test_runsCreateWithoutReportsInput, test_runsUncheckedCreateWithoutReportsInput>
  }

  export type test_runsUpsertWithoutReportsInput = {
    update: XOR<test_runsUpdateWithoutReportsInput, test_runsUncheckedUpdateWithoutReportsInput>
    create: XOR<test_runsCreateWithoutReportsInput, test_runsUncheckedCreateWithoutReportsInput>
    where?: test_runsWhereInput
  }

  export type test_runsUpdateToOneWithWhereWithoutReportsInput = {
    where?: test_runsWhereInput
    data: XOR<test_runsUpdateWithoutReportsInput, test_runsUncheckedUpdateWithoutReportsInput>
  }

  export type test_runsUpdateWithoutReportsInput = {
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_runsNestedInput
    test_suites?: test_suitesUpdateOneRequiredWithoutTest_runsNestedInput
    users?: usersUpdateOneRequiredWithoutTest_runsNestedInput
  }

  export type test_runsUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    suite_id?: IntFieldUpdateOperationsInput | number
    trigger_user_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUncheckedUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_runsNestedInput
  }

  export type user_rolesCreateWithoutRolesInput = {
    users: usersCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateWithoutRolesInput = {
    user_id: number
  }

  export type user_rolesCreateOrConnectWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesCreateManyRolesInputEnvelope = {
    data: user_rolesCreateManyRolesInput | user_rolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutRolesInput, user_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutRolesInput, user_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type user_rolesScalarWhereInput = {
    AND?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    OR?: user_rolesScalarWhereInput[]
    NOT?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    user_id?: IntFilter<"user_roles"> | number
    role_id?: IntFilter<"user_roles"> | number
  }

  export type test_casesCreateWithoutStep_screenshotsInput = {
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesUncheckedCreateWithoutStep_screenshotsInput = {
    id?: number
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesCreateOrConnectWithoutStep_screenshotsInput = {
    where: test_casesWhereUniqueInput
    create: XOR<test_casesCreateWithoutStep_screenshotsInput, test_casesUncheckedCreateWithoutStep_screenshotsInput>
  }

  export type test_casesUpsertWithoutStep_screenshotsInput = {
    update: XOR<test_casesUpdateWithoutStep_screenshotsInput, test_casesUncheckedUpdateWithoutStep_screenshotsInput>
    create: XOR<test_casesCreateWithoutStep_screenshotsInput, test_casesUncheckedCreateWithoutStep_screenshotsInput>
    where?: test_casesWhereInput
  }

  export type test_casesUpdateToOneWithWhereWithoutStep_screenshotsInput = {
    where?: test_casesWhereInput
    data: XOR<test_casesUpdateWithoutStep_screenshotsInput, test_casesUncheckedUpdateWithoutStep_screenshotsInput>
  }

  export type test_casesUpdateWithoutStep_screenshotsInput = {
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_casesNestedInput
  }

  export type test_casesUncheckedUpdateWithoutStep_screenshotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_casesNestedInput
  }

  export type test_suitesCreateWithoutSuite_case_mapInput = {
    name: string
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    test_runs?: test_runsCreateNestedManyWithoutTest_suitesInput
    users: usersCreateNestedOneWithoutTest_suitesInput
  }

  export type test_suitesUncheckedCreateWithoutSuite_case_mapInput = {
    id?: number
    name: string
    owner_id: number
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    test_runs?: test_runsUncheckedCreateNestedManyWithoutTest_suitesInput
  }

  export type test_suitesCreateOrConnectWithoutSuite_case_mapInput = {
    where: test_suitesWhereUniqueInput
    create: XOR<test_suitesCreateWithoutSuite_case_mapInput, test_suitesUncheckedCreateWithoutSuite_case_mapInput>
  }

  export type test_casesCreateWithoutSuite_case_mapInput = {
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesUncheckedCreateWithoutSuite_case_mapInput = {
    id?: number
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsUncheckedCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesCreateOrConnectWithoutSuite_case_mapInput = {
    where: test_casesWhereUniqueInput
    create: XOR<test_casesCreateWithoutSuite_case_mapInput, test_casesUncheckedCreateWithoutSuite_case_mapInput>
  }

  export type test_suitesUpsertWithoutSuite_case_mapInput = {
    update: XOR<test_suitesUpdateWithoutSuite_case_mapInput, test_suitesUncheckedUpdateWithoutSuite_case_mapInput>
    create: XOR<test_suitesCreateWithoutSuite_case_mapInput, test_suitesUncheckedCreateWithoutSuite_case_mapInput>
    where?: test_suitesWhereInput
  }

  export type test_suitesUpdateToOneWithWhereWithoutSuite_case_mapInput = {
    where?: test_suitesWhereInput
    data: XOR<test_suitesUpdateWithoutSuite_case_mapInput, test_suitesUncheckedUpdateWithoutSuite_case_mapInput>
  }

  export type test_suitesUpdateWithoutSuite_case_mapInput = {
    name?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_runs?: test_runsUpdateManyWithoutTest_suitesNestedInput
    users?: usersUpdateOneRequiredWithoutTest_suitesNestedInput
  }

  export type test_suitesUncheckedUpdateWithoutSuite_case_mapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    owner_id?: IntFieldUpdateOperationsInput | number
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_runs?: test_runsUncheckedUpdateManyWithoutTest_suitesNestedInput
  }

  export type test_casesUpsertWithoutSuite_case_mapInput = {
    update: XOR<test_casesUpdateWithoutSuite_case_mapInput, test_casesUncheckedUpdateWithoutSuite_case_mapInput>
    create: XOR<test_casesCreateWithoutSuite_case_mapInput, test_casesUncheckedCreateWithoutSuite_case_mapInput>
    where?: test_casesWhereInput
  }

  export type test_casesUpdateToOneWithWhereWithoutSuite_case_mapInput = {
    where?: test_casesWhereInput
    data: XOR<test_casesUpdateWithoutSuite_case_mapInput, test_casesUncheckedUpdateWithoutSuite_case_mapInput>
  }

  export type test_casesUpdateWithoutSuite_case_mapInput = {
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_casesNestedInput
  }

  export type test_casesUncheckedUpdateWithoutSuite_case_mapInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUncheckedUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_casesNestedInput
  }

  export type case_patch_proposalsCreateWithoutTest_casesInput = {
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
    session: bulk_edit_sessionsCreateNestedOneWithoutProposalsInput
  }

  export type case_patch_proposalsUncheckedCreateWithoutTest_casesInput = {
    id?: number
    session_id: number
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type case_patch_proposalsCreateOrConnectWithoutTest_casesInput = {
    where: case_patch_proposalsWhereUniqueInput
    create: XOR<case_patch_proposalsCreateWithoutTest_casesInput, case_patch_proposalsUncheckedCreateWithoutTest_casesInput>
  }

  export type case_patch_proposalsCreateManyTest_casesInputEnvelope = {
    data: case_patch_proposalsCreateManyTest_casesInput | case_patch_proposalsCreateManyTest_casesInput[]
    skipDuplicates?: boolean
  }

  export type case_versionsCreateWithoutTest_casesInput = {
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    users?: usersCreateNestedOneWithoutCase_versionsInput
  }

  export type case_versionsUncheckedCreateWithoutTest_casesInput = {
    id?: number
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_by?: number | null
    created_at?: Date | string | null
  }

  export type case_versionsCreateOrConnectWithoutTest_casesInput = {
    where: case_versionsWhereUniqueInput
    create: XOR<case_versionsCreateWithoutTest_casesInput, case_versionsUncheckedCreateWithoutTest_casesInput>
  }

  export type case_versionsCreateManyTest_casesInputEnvelope = {
    data: case_versionsCreateManyTest_casesInput | case_versionsCreateManyTest_casesInput[]
    skipDuplicates?: boolean
  }

  export type step_screenshotsCreateWithoutTest_casesInput = {
    run_id: string
    step_index: string
    step_description?: string | null
    status: $Enums.step_screenshots_status
    file_path: string
    file_name: string
    file_size?: bigint | number | null
    mime_type?: string | null
    created_at?: Date | string | null
    file_exists?: boolean
  }

  export type step_screenshotsUncheckedCreateWithoutTest_casesInput = {
    id?: number
    run_id: string
    step_index: string
    step_description?: string | null
    status: $Enums.step_screenshots_status
    file_path: string
    file_name: string
    file_size?: bigint | number | null
    mime_type?: string | null
    created_at?: Date | string | null
    file_exists?: boolean
  }

  export type step_screenshotsCreateOrConnectWithoutTest_casesInput = {
    where: step_screenshotsWhereUniqueInput
    create: XOR<step_screenshotsCreateWithoutTest_casesInput, step_screenshotsUncheckedCreateWithoutTest_casesInput>
  }

  export type step_screenshotsCreateManyTest_casesInputEnvelope = {
    data: step_screenshotsCreateManyTest_casesInput | step_screenshotsCreateManyTest_casesInput[]
    skipDuplicates?: boolean
  }

  export type suite_case_mapCreateWithoutTest_casesInput = {
    test_suites: test_suitesCreateNestedOneWithoutSuite_case_mapInput
  }

  export type suite_case_mapUncheckedCreateWithoutTest_casesInput = {
    suite_id: number
  }

  export type suite_case_mapCreateOrConnectWithoutTest_casesInput = {
    where: suite_case_mapWhereUniqueInput
    create: XOR<suite_case_mapCreateWithoutTest_casesInput, suite_case_mapUncheckedCreateWithoutTest_casesInput>
  }

  export type suite_case_mapCreateManyTest_casesInputEnvelope = {
    data: suite_case_mapCreateManyTest_casesInput | suite_case_mapCreateManyTest_casesInput[]
    skipDuplicates?: boolean
  }

  export type test_case_executionsCreateWithoutTest_casesInput = {
    id: string
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    users?: usersCreateNestedOneWithoutTest_case_executionsInput
  }

  export type test_case_executionsUncheckedCreateWithoutTest_casesInput = {
    id: string
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_user_id?: number | null
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_case_executionsCreateOrConnectWithoutTest_casesInput = {
    where: test_case_executionsWhereUniqueInput
    create: XOR<test_case_executionsCreateWithoutTest_casesInput, test_case_executionsUncheckedCreateWithoutTest_casesInput>
  }

  export type test_case_executionsCreateManyTest_casesInputEnvelope = {
    data: test_case_executionsCreateManyTest_casesInput | test_case_executionsCreateManyTest_casesInput[]
    skipDuplicates?: boolean
  }

  export type test_run_resultsCreateWithoutTest_casesInput = {
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
    attachments?: attachmentsCreateNestedManyWithoutTest_run_resultsInput
    test_runs: test_runsCreateNestedOneWithoutTest_run_resultsInput
  }

  export type test_run_resultsUncheckedCreateWithoutTest_casesInput = {
    id?: number
    run_id: number
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
    attachments?: attachmentsUncheckedCreateNestedManyWithoutTest_run_resultsInput
  }

  export type test_run_resultsCreateOrConnectWithoutTest_casesInput = {
    where: test_run_resultsWhereUniqueInput
    create: XOR<test_run_resultsCreateWithoutTest_casesInput, test_run_resultsUncheckedCreateWithoutTest_casesInput>
  }

  export type test_run_resultsCreateManyTest_casesInputEnvelope = {
    data: test_run_resultsCreateManyTest_casesInput | test_run_resultsCreateManyTest_casesInput[]
    skipDuplicates?: boolean
  }

  export type case_patch_proposalsUpsertWithWhereUniqueWithoutTest_casesInput = {
    where: case_patch_proposalsWhereUniqueInput
    update: XOR<case_patch_proposalsUpdateWithoutTest_casesInput, case_patch_proposalsUncheckedUpdateWithoutTest_casesInput>
    create: XOR<case_patch_proposalsCreateWithoutTest_casesInput, case_patch_proposalsUncheckedCreateWithoutTest_casesInput>
  }

  export type case_patch_proposalsUpdateWithWhereUniqueWithoutTest_casesInput = {
    where: case_patch_proposalsWhereUniqueInput
    data: XOR<case_patch_proposalsUpdateWithoutTest_casesInput, case_patch_proposalsUncheckedUpdateWithoutTest_casesInput>
  }

  export type case_patch_proposalsUpdateManyWithWhereWithoutTest_casesInput = {
    where: case_patch_proposalsScalarWhereInput
    data: XOR<case_patch_proposalsUpdateManyMutationInput, case_patch_proposalsUncheckedUpdateManyWithoutTest_casesInput>
  }

  export type case_patch_proposalsScalarWhereInput = {
    AND?: case_patch_proposalsScalarWhereInput | case_patch_proposalsScalarWhereInput[]
    OR?: case_patch_proposalsScalarWhereInput[]
    NOT?: case_patch_proposalsScalarWhereInput | case_patch_proposalsScalarWhereInput[]
    id?: IntFilter<"case_patch_proposals"> | number
    session_id?: IntFilter<"case_patch_proposals"> | number
    case_id?: IntFilter<"case_patch_proposals"> | number
    diff_json?: JsonFilter<"case_patch_proposals">
    ai_rationale?: StringNullableFilter<"case_patch_proposals"> | string | null
    side_effects?: JsonNullableFilter<"case_patch_proposals">
    risk_level?: Enumproposal_risk_levelFilter<"case_patch_proposals"> | $Enums.proposal_risk_level
    recall_reason?: StringNullableFilter<"case_patch_proposals"> | string | null
    old_hash?: StringFilter<"case_patch_proposals"> | string
    new_hash?: StringNullableFilter<"case_patch_proposals"> | string | null
    apply_status?: Enumproposal_apply_statusFilter<"case_patch_proposals"> | $Enums.proposal_apply_status
    created_at?: DateTimeNullableFilter<"case_patch_proposals"> | Date | string | null
    applied_at?: DateTimeNullableFilter<"case_patch_proposals"> | Date | string | null
  }

  export type case_versionsUpsertWithWhereUniqueWithoutTest_casesInput = {
    where: case_versionsWhereUniqueInput
    update: XOR<case_versionsUpdateWithoutTest_casesInput, case_versionsUncheckedUpdateWithoutTest_casesInput>
    create: XOR<case_versionsCreateWithoutTest_casesInput, case_versionsUncheckedCreateWithoutTest_casesInput>
  }

  export type case_versionsUpdateWithWhereUniqueWithoutTest_casesInput = {
    where: case_versionsWhereUniqueInput
    data: XOR<case_versionsUpdateWithoutTest_casesInput, case_versionsUncheckedUpdateWithoutTest_casesInput>
  }

  export type case_versionsUpdateManyWithWhereWithoutTest_casesInput = {
    where: case_versionsScalarWhereInput
    data: XOR<case_versionsUpdateManyMutationInput, case_versionsUncheckedUpdateManyWithoutTest_casesInput>
  }

  export type case_versionsScalarWhereInput = {
    AND?: case_versionsScalarWhereInput | case_versionsScalarWhereInput[]
    OR?: case_versionsScalarWhereInput[]
    NOT?: case_versionsScalarWhereInput | case_versionsScalarWhereInput[]
    id?: IntFilter<"case_versions"> | number
    case_id?: IntFilter<"case_versions"> | number
    version?: IntFilter<"case_versions"> | number
    steps?: JsonNullableFilter<"case_versions">
    tags?: JsonNullableFilter<"case_versions">
    system?: StringNullableFilter<"case_versions"> | string | null
    module?: StringNullableFilter<"case_versions"> | string | null
    meta?: JsonNullableFilter<"case_versions">
    created_by?: IntNullableFilter<"case_versions"> | number | null
    created_at?: DateTimeNullableFilter<"case_versions"> | Date | string | null
  }

  export type step_screenshotsUpsertWithWhereUniqueWithoutTest_casesInput = {
    where: step_screenshotsWhereUniqueInput
    update: XOR<step_screenshotsUpdateWithoutTest_casesInput, step_screenshotsUncheckedUpdateWithoutTest_casesInput>
    create: XOR<step_screenshotsCreateWithoutTest_casesInput, step_screenshotsUncheckedCreateWithoutTest_casesInput>
  }

  export type step_screenshotsUpdateWithWhereUniqueWithoutTest_casesInput = {
    where: step_screenshotsWhereUniqueInput
    data: XOR<step_screenshotsUpdateWithoutTest_casesInput, step_screenshotsUncheckedUpdateWithoutTest_casesInput>
  }

  export type step_screenshotsUpdateManyWithWhereWithoutTest_casesInput = {
    where: step_screenshotsScalarWhereInput
    data: XOR<step_screenshotsUpdateManyMutationInput, step_screenshotsUncheckedUpdateManyWithoutTest_casesInput>
  }

  export type step_screenshotsScalarWhereInput = {
    AND?: step_screenshotsScalarWhereInput | step_screenshotsScalarWhereInput[]
    OR?: step_screenshotsScalarWhereInput[]
    NOT?: step_screenshotsScalarWhereInput | step_screenshotsScalarWhereInput[]
    id?: IntFilter<"step_screenshots"> | number
    run_id?: StringFilter<"step_screenshots"> | string
    test_case_id?: IntNullableFilter<"step_screenshots"> | number | null
    step_index?: StringFilter<"step_screenshots"> | string
    step_description?: StringNullableFilter<"step_screenshots"> | string | null
    status?: Enumstep_screenshots_statusFilter<"step_screenshots"> | $Enums.step_screenshots_status
    file_path?: StringFilter<"step_screenshots"> | string
    file_name?: StringFilter<"step_screenshots"> | string
    file_size?: BigIntNullableFilter<"step_screenshots"> | bigint | number | null
    mime_type?: StringNullableFilter<"step_screenshots"> | string | null
    created_at?: DateTimeNullableFilter<"step_screenshots"> | Date | string | null
    file_exists?: BoolFilter<"step_screenshots"> | boolean
  }

  export type suite_case_mapUpsertWithWhereUniqueWithoutTest_casesInput = {
    where: suite_case_mapWhereUniqueInput
    update: XOR<suite_case_mapUpdateWithoutTest_casesInput, suite_case_mapUncheckedUpdateWithoutTest_casesInput>
    create: XOR<suite_case_mapCreateWithoutTest_casesInput, suite_case_mapUncheckedCreateWithoutTest_casesInput>
  }

  export type suite_case_mapUpdateWithWhereUniqueWithoutTest_casesInput = {
    where: suite_case_mapWhereUniqueInput
    data: XOR<suite_case_mapUpdateWithoutTest_casesInput, suite_case_mapUncheckedUpdateWithoutTest_casesInput>
  }

  export type suite_case_mapUpdateManyWithWhereWithoutTest_casesInput = {
    where: suite_case_mapScalarWhereInput
    data: XOR<suite_case_mapUpdateManyMutationInput, suite_case_mapUncheckedUpdateManyWithoutTest_casesInput>
  }

  export type suite_case_mapScalarWhereInput = {
    AND?: suite_case_mapScalarWhereInput | suite_case_mapScalarWhereInput[]
    OR?: suite_case_mapScalarWhereInput[]
    NOT?: suite_case_mapScalarWhereInput | suite_case_mapScalarWhereInput[]
    suite_id?: IntFilter<"suite_case_map"> | number
    case_id?: IntFilter<"suite_case_map"> | number
  }

  export type test_case_executionsUpsertWithWhereUniqueWithoutTest_casesInput = {
    where: test_case_executionsWhereUniqueInput
    update: XOR<test_case_executionsUpdateWithoutTest_casesInput, test_case_executionsUncheckedUpdateWithoutTest_casesInput>
    create: XOR<test_case_executionsCreateWithoutTest_casesInput, test_case_executionsUncheckedCreateWithoutTest_casesInput>
  }

  export type test_case_executionsUpdateWithWhereUniqueWithoutTest_casesInput = {
    where: test_case_executionsWhereUniqueInput
    data: XOR<test_case_executionsUpdateWithoutTest_casesInput, test_case_executionsUncheckedUpdateWithoutTest_casesInput>
  }

  export type test_case_executionsUpdateManyWithWhereWithoutTest_casesInput = {
    where: test_case_executionsScalarWhereInput
    data: XOR<test_case_executionsUpdateManyMutationInput, test_case_executionsUncheckedUpdateManyWithoutTest_casesInput>
  }

  export type test_case_executionsScalarWhereInput = {
    AND?: test_case_executionsScalarWhereInput | test_case_executionsScalarWhereInput[]
    OR?: test_case_executionsScalarWhereInput[]
    NOT?: test_case_executionsScalarWhereInput | test_case_executionsScalarWhereInput[]
    id?: StringFilter<"test_case_executions"> | string
    test_case_id?: IntFilter<"test_case_executions"> | number
    test_case_title?: StringFilter<"test_case_executions"> | string
    environment?: StringFilter<"test_case_executions"> | string
    execution_mode?: StringFilter<"test_case_executions"> | string
    status?: Enumtest_case_execution_statusFilter<"test_case_executions"> | $Enums.test_case_execution_status
    executor_user_id?: IntNullableFilter<"test_case_executions"> | number | null
    executor_project?: StringNullableFilter<"test_case_executions"> | string | null
    queued_at?: DateTimeFilter<"test_case_executions"> | Date | string
    started_at?: DateTimeNullableFilter<"test_case_executions"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"test_case_executions"> | Date | string | null
    duration_ms?: IntNullableFilter<"test_case_executions"> | number | null
    total_steps?: IntFilter<"test_case_executions"> | number
    completed_steps?: IntFilter<"test_case_executions"> | number
    passed_steps?: IntFilter<"test_case_executions"> | number
    failed_steps?: IntFilter<"test_case_executions"> | number
    progress?: IntFilter<"test_case_executions"> | number
    error_message?: StringNullableFilter<"test_case_executions"> | string | null
    execution_logs?: JsonNullableFilter<"test_case_executions">
    screenshots?: JsonNullableFilter<"test_case_executions">
    artifacts?: JsonNullableFilter<"test_case_executions">
    metadata?: JsonNullableFilter<"test_case_executions">
  }

  export type test_run_resultsUpsertWithWhereUniqueWithoutTest_casesInput = {
    where: test_run_resultsWhereUniqueInput
    update: XOR<test_run_resultsUpdateWithoutTest_casesInput, test_run_resultsUncheckedUpdateWithoutTest_casesInput>
    create: XOR<test_run_resultsCreateWithoutTest_casesInput, test_run_resultsUncheckedCreateWithoutTest_casesInput>
  }

  export type test_run_resultsUpdateWithWhereUniqueWithoutTest_casesInput = {
    where: test_run_resultsWhereUniqueInput
    data: XOR<test_run_resultsUpdateWithoutTest_casesInput, test_run_resultsUncheckedUpdateWithoutTest_casesInput>
  }

  export type test_run_resultsUpdateManyWithWhereWithoutTest_casesInput = {
    where: test_run_resultsScalarWhereInput
    data: XOR<test_run_resultsUpdateManyMutationInput, test_run_resultsUncheckedUpdateManyWithoutTest_casesInput>
  }

  export type test_run_resultsScalarWhereInput = {
    AND?: test_run_resultsScalarWhereInput | test_run_resultsScalarWhereInput[]
    OR?: test_run_resultsScalarWhereInput[]
    NOT?: test_run_resultsScalarWhereInput | test_run_resultsScalarWhereInput[]
    id?: IntFilter<"test_run_results"> | number
    run_id?: IntFilter<"test_run_results"> | number
    case_id?: IntFilter<"test_run_results"> | number
    status?: Enumtest_run_results_statusFilter<"test_run_results"> | $Enums.test_run_results_status
    duration_ms?: IntNullableFilter<"test_run_results"> | number | null
    screenshot_url?: StringNullableFilter<"test_run_results"> | string | null
    executed_at?: DateTimeNullableFilter<"test_run_results"> | Date | string | null
  }

  export type attachmentsCreateWithoutTest_run_resultsInput = {
    file_key: string
    mime_type?: string | null
    size_bytes?: bigint | number | null
    created_at?: Date | string | null
  }

  export type attachmentsUncheckedCreateWithoutTest_run_resultsInput = {
    id?: number
    file_key: string
    mime_type?: string | null
    size_bytes?: bigint | number | null
    created_at?: Date | string | null
  }

  export type attachmentsCreateOrConnectWithoutTest_run_resultsInput = {
    where: attachmentsWhereUniqueInput
    create: XOR<attachmentsCreateWithoutTest_run_resultsInput, attachmentsUncheckedCreateWithoutTest_run_resultsInput>
  }

  export type attachmentsCreateManyTest_run_resultsInputEnvelope = {
    data: attachmentsCreateManyTest_run_resultsInput | attachmentsCreateManyTest_run_resultsInput[]
    skipDuplicates?: boolean
  }

  export type test_runsCreateWithoutTest_run_resultsInput = {
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsCreateNestedManyWithoutTest_runsInput
    reports?: reportsCreateNestedManyWithoutTest_runsInput
    test_suites: test_suitesCreateNestedOneWithoutTest_runsInput
    users: usersCreateNestedOneWithoutTest_runsInput
  }

  export type test_runsUncheckedCreateWithoutTest_run_resultsInput = {
    id?: number
    suite_id: number
    trigger_user_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsUncheckedCreateNestedManyWithoutTest_runsInput
    reports?: reportsUncheckedCreateNestedManyWithoutTest_runsInput
  }

  export type test_runsCreateOrConnectWithoutTest_run_resultsInput = {
    where: test_runsWhereUniqueInput
    create: XOR<test_runsCreateWithoutTest_run_resultsInput, test_runsUncheckedCreateWithoutTest_run_resultsInput>
  }

  export type test_casesCreateWithoutTest_run_resultsInput = {
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesUncheckedCreateWithoutTest_run_resultsInput = {
    id?: number
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsUncheckedCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesCreateOrConnectWithoutTest_run_resultsInput = {
    where: test_casesWhereUniqueInput
    create: XOR<test_casesCreateWithoutTest_run_resultsInput, test_casesUncheckedCreateWithoutTest_run_resultsInput>
  }

  export type attachmentsUpsertWithWhereUniqueWithoutTest_run_resultsInput = {
    where: attachmentsWhereUniqueInput
    update: XOR<attachmentsUpdateWithoutTest_run_resultsInput, attachmentsUncheckedUpdateWithoutTest_run_resultsInput>
    create: XOR<attachmentsCreateWithoutTest_run_resultsInput, attachmentsUncheckedCreateWithoutTest_run_resultsInput>
  }

  export type attachmentsUpdateWithWhereUniqueWithoutTest_run_resultsInput = {
    where: attachmentsWhereUniqueInput
    data: XOR<attachmentsUpdateWithoutTest_run_resultsInput, attachmentsUncheckedUpdateWithoutTest_run_resultsInput>
  }

  export type attachmentsUpdateManyWithWhereWithoutTest_run_resultsInput = {
    where: attachmentsScalarWhereInput
    data: XOR<attachmentsUpdateManyMutationInput, attachmentsUncheckedUpdateManyWithoutTest_run_resultsInput>
  }

  export type attachmentsScalarWhereInput = {
    AND?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
    OR?: attachmentsScalarWhereInput[]
    NOT?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
    id?: IntFilter<"attachments"> | number
    run_result_id?: IntFilter<"attachments"> | number
    file_key?: StringFilter<"attachments"> | string
    mime_type?: StringNullableFilter<"attachments"> | string | null
    size_bytes?: BigIntNullableFilter<"attachments"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"attachments"> | Date | string | null
  }

  export type test_runsUpsertWithoutTest_run_resultsInput = {
    update: XOR<test_runsUpdateWithoutTest_run_resultsInput, test_runsUncheckedUpdateWithoutTest_run_resultsInput>
    create: XOR<test_runsCreateWithoutTest_run_resultsInput, test_runsUncheckedCreateWithoutTest_run_resultsInput>
    where?: test_runsWhereInput
  }

  export type test_runsUpdateToOneWithWhereWithoutTest_run_resultsInput = {
    where?: test_runsWhereInput
    data: XOR<test_runsUpdateWithoutTest_run_resultsInput, test_runsUncheckedUpdateWithoutTest_run_resultsInput>
  }

  export type test_runsUpdateWithoutTest_run_resultsInput = {
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUpdateManyWithoutTest_runsNestedInput
    reports?: reportsUpdateManyWithoutTest_runsNestedInput
    test_suites?: test_suitesUpdateOneRequiredWithoutTest_runsNestedInput
    users?: usersUpdateOneRequiredWithoutTest_runsNestedInput
  }

  export type test_runsUncheckedUpdateWithoutTest_run_resultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    suite_id?: IntFieldUpdateOperationsInput | number
    trigger_user_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUncheckedUpdateManyWithoutTest_runsNestedInput
    reports?: reportsUncheckedUpdateManyWithoutTest_runsNestedInput
  }

  export type test_casesUpsertWithoutTest_run_resultsInput = {
    update: XOR<test_casesUpdateWithoutTest_run_resultsInput, test_casesUncheckedUpdateWithoutTest_run_resultsInput>
    create: XOR<test_casesCreateWithoutTest_run_resultsInput, test_casesUncheckedCreateWithoutTest_run_resultsInput>
    where?: test_casesWhereInput
  }

  export type test_casesUpdateToOneWithWhereWithoutTest_run_resultsInput = {
    where?: test_casesWhereInput
    data: XOR<test_casesUpdateWithoutTest_run_resultsInput, test_casesUncheckedUpdateWithoutTest_run_resultsInput>
  }

  export type test_casesUpdateWithoutTest_run_resultsInput = {
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutTest_casesNestedInput
  }

  export type test_casesUncheckedUpdateWithoutTest_run_resultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUncheckedUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutTest_casesNestedInput
  }

  export type ai_runsCreateWithoutTest_runsInput = {
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
    ai_prompts: ai_promptsCreateNestedOneWithoutAi_runsInput
  }

  export type ai_runsUncheckedCreateWithoutTest_runsInput = {
    id?: number
    prompt_id: number
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
  }

  export type ai_runsCreateOrConnectWithoutTest_runsInput = {
    where: ai_runsWhereUniqueInput
    create: XOR<ai_runsCreateWithoutTest_runsInput, ai_runsUncheckedCreateWithoutTest_runsInput>
  }

  export type ai_runsCreateManyTest_runsInputEnvelope = {
    data: ai_runsCreateManyTest_runsInput | ai_runsCreateManyTest_runsInput[]
    skipDuplicates?: boolean
  }

  export type reportsCreateWithoutTest_runsInput = {
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: Date | string | null
  }

  export type reportsUncheckedCreateWithoutTest_runsInput = {
    id?: number
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: Date | string | null
  }

  export type reportsCreateOrConnectWithoutTest_runsInput = {
    where: reportsWhereUniqueInput
    create: XOR<reportsCreateWithoutTest_runsInput, reportsUncheckedCreateWithoutTest_runsInput>
  }

  export type reportsCreateManyTest_runsInputEnvelope = {
    data: reportsCreateManyTest_runsInput | reportsCreateManyTest_runsInput[]
    skipDuplicates?: boolean
  }

  export type test_run_resultsCreateWithoutTest_runsInput = {
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
    attachments?: attachmentsCreateNestedManyWithoutTest_run_resultsInput
    test_cases: test_casesCreateNestedOneWithoutTest_run_resultsInput
  }

  export type test_run_resultsUncheckedCreateWithoutTest_runsInput = {
    id?: number
    case_id: number
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
    attachments?: attachmentsUncheckedCreateNestedManyWithoutTest_run_resultsInput
  }

  export type test_run_resultsCreateOrConnectWithoutTest_runsInput = {
    where: test_run_resultsWhereUniqueInput
    create: XOR<test_run_resultsCreateWithoutTest_runsInput, test_run_resultsUncheckedCreateWithoutTest_runsInput>
  }

  export type test_run_resultsCreateManyTest_runsInputEnvelope = {
    data: test_run_resultsCreateManyTest_runsInput | test_run_resultsCreateManyTest_runsInput[]
    skipDuplicates?: boolean
  }

  export type test_suitesCreateWithoutTest_runsInput = {
    name: string
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_suitesInput
    users: usersCreateNestedOneWithoutTest_suitesInput
  }

  export type test_suitesUncheckedCreateWithoutTest_runsInput = {
    id?: number
    name: string
    owner_id: number
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_suitesInput
  }

  export type test_suitesCreateOrConnectWithoutTest_runsInput = {
    where: test_suitesWhereUniqueInput
    create: XOR<test_suitesCreateWithoutTest_runsInput, test_suitesUncheckedCreateWithoutTest_runsInput>
  }

  export type usersCreateWithoutTest_runsInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutTest_runsInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutTest_runsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTest_runsInput, usersUncheckedCreateWithoutTest_runsInput>
  }

  export type ai_runsUpsertWithWhereUniqueWithoutTest_runsInput = {
    where: ai_runsWhereUniqueInput
    update: XOR<ai_runsUpdateWithoutTest_runsInput, ai_runsUncheckedUpdateWithoutTest_runsInput>
    create: XOR<ai_runsCreateWithoutTest_runsInput, ai_runsUncheckedCreateWithoutTest_runsInput>
  }

  export type ai_runsUpdateWithWhereUniqueWithoutTest_runsInput = {
    where: ai_runsWhereUniqueInput
    data: XOR<ai_runsUpdateWithoutTest_runsInput, ai_runsUncheckedUpdateWithoutTest_runsInput>
  }

  export type ai_runsUpdateManyWithWhereWithoutTest_runsInput = {
    where: ai_runsScalarWhereInput
    data: XOR<ai_runsUpdateManyMutationInput, ai_runsUncheckedUpdateManyWithoutTest_runsInput>
  }

  export type reportsUpsertWithWhereUniqueWithoutTest_runsInput = {
    where: reportsWhereUniqueInput
    update: XOR<reportsUpdateWithoutTest_runsInput, reportsUncheckedUpdateWithoutTest_runsInput>
    create: XOR<reportsCreateWithoutTest_runsInput, reportsUncheckedCreateWithoutTest_runsInput>
  }

  export type reportsUpdateWithWhereUniqueWithoutTest_runsInput = {
    where: reportsWhereUniqueInput
    data: XOR<reportsUpdateWithoutTest_runsInput, reportsUncheckedUpdateWithoutTest_runsInput>
  }

  export type reportsUpdateManyWithWhereWithoutTest_runsInput = {
    where: reportsScalarWhereInput
    data: XOR<reportsUpdateManyMutationInput, reportsUncheckedUpdateManyWithoutTest_runsInput>
  }

  export type reportsScalarWhereInput = {
    AND?: reportsScalarWhereInput | reportsScalarWhereInput[]
    OR?: reportsScalarWhereInput[]
    NOT?: reportsScalarWhereInput | reportsScalarWhereInput[]
    id?: IntFilter<"reports"> | number
    run_id?: IntFilter<"reports"> | number
    summary?: JsonNullableFilter<"reports">
    generated_at?: DateTimeNullableFilter<"reports"> | Date | string | null
  }

  export type test_run_resultsUpsertWithWhereUniqueWithoutTest_runsInput = {
    where: test_run_resultsWhereUniqueInput
    update: XOR<test_run_resultsUpdateWithoutTest_runsInput, test_run_resultsUncheckedUpdateWithoutTest_runsInput>
    create: XOR<test_run_resultsCreateWithoutTest_runsInput, test_run_resultsUncheckedCreateWithoutTest_runsInput>
  }

  export type test_run_resultsUpdateWithWhereUniqueWithoutTest_runsInput = {
    where: test_run_resultsWhereUniqueInput
    data: XOR<test_run_resultsUpdateWithoutTest_runsInput, test_run_resultsUncheckedUpdateWithoutTest_runsInput>
  }

  export type test_run_resultsUpdateManyWithWhereWithoutTest_runsInput = {
    where: test_run_resultsScalarWhereInput
    data: XOR<test_run_resultsUpdateManyMutationInput, test_run_resultsUncheckedUpdateManyWithoutTest_runsInput>
  }

  export type test_suitesUpsertWithoutTest_runsInput = {
    update: XOR<test_suitesUpdateWithoutTest_runsInput, test_suitesUncheckedUpdateWithoutTest_runsInput>
    create: XOR<test_suitesCreateWithoutTest_runsInput, test_suitesUncheckedCreateWithoutTest_runsInput>
    where?: test_suitesWhereInput
  }

  export type test_suitesUpdateToOneWithWhereWithoutTest_runsInput = {
    where?: test_suitesWhereInput
    data: XOR<test_suitesUpdateWithoutTest_runsInput, test_suitesUncheckedUpdateWithoutTest_runsInput>
  }

  export type test_suitesUpdateWithoutTest_runsInput = {
    name?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_suitesNestedInput
    users?: usersUpdateOneRequiredWithoutTest_suitesNestedInput
  }

  export type test_suitesUncheckedUpdateWithoutTest_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    owner_id?: IntFieldUpdateOperationsInput | number
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_suitesNestedInput
  }

  export type usersUpsertWithoutTest_runsInput = {
    update: XOR<usersUpdateWithoutTest_runsInput, usersUncheckedUpdateWithoutTest_runsInput>
    create: XOR<usersCreateWithoutTest_runsInput, usersUncheckedCreateWithoutTest_runsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTest_runsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTest_runsInput, usersUncheckedUpdateWithoutTest_runsInput>
  }

  export type usersUpdateWithoutTest_runsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutTest_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type suite_case_mapCreateWithoutTest_suitesInput = {
    test_cases: test_casesCreateNestedOneWithoutSuite_case_mapInput
  }

  export type suite_case_mapUncheckedCreateWithoutTest_suitesInput = {
    case_id: number
  }

  export type suite_case_mapCreateOrConnectWithoutTest_suitesInput = {
    where: suite_case_mapWhereUniqueInput
    create: XOR<suite_case_mapCreateWithoutTest_suitesInput, suite_case_mapUncheckedCreateWithoutTest_suitesInput>
  }

  export type suite_case_mapCreateManyTest_suitesInputEnvelope = {
    data: suite_case_mapCreateManyTest_suitesInput | suite_case_mapCreateManyTest_suitesInput[]
    skipDuplicates?: boolean
  }

  export type test_runsCreateWithoutTest_suitesInput = {
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsCreateNestedManyWithoutTest_runsInput
    reports?: reportsCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_runsInput
    users: usersCreateNestedOneWithoutTest_runsInput
  }

  export type test_runsUncheckedCreateWithoutTest_suitesInput = {
    id?: number
    trigger_user_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsUncheckedCreateNestedManyWithoutTest_runsInput
    reports?: reportsUncheckedCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_runsInput
  }

  export type test_runsCreateOrConnectWithoutTest_suitesInput = {
    where: test_runsWhereUniqueInput
    create: XOR<test_runsCreateWithoutTest_suitesInput, test_runsUncheckedCreateWithoutTest_suitesInput>
  }

  export type test_runsCreateManyTest_suitesInputEnvelope = {
    data: test_runsCreateManyTest_suitesInput | test_runsCreateManyTest_suitesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutTest_suitesInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutTest_suitesInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutTest_suitesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTest_suitesInput, usersUncheckedCreateWithoutTest_suitesInput>
  }

  export type suite_case_mapUpsertWithWhereUniqueWithoutTest_suitesInput = {
    where: suite_case_mapWhereUniqueInput
    update: XOR<suite_case_mapUpdateWithoutTest_suitesInput, suite_case_mapUncheckedUpdateWithoutTest_suitesInput>
    create: XOR<suite_case_mapCreateWithoutTest_suitesInput, suite_case_mapUncheckedCreateWithoutTest_suitesInput>
  }

  export type suite_case_mapUpdateWithWhereUniqueWithoutTest_suitesInput = {
    where: suite_case_mapWhereUniqueInput
    data: XOR<suite_case_mapUpdateWithoutTest_suitesInput, suite_case_mapUncheckedUpdateWithoutTest_suitesInput>
  }

  export type suite_case_mapUpdateManyWithWhereWithoutTest_suitesInput = {
    where: suite_case_mapScalarWhereInput
    data: XOR<suite_case_mapUpdateManyMutationInput, suite_case_mapUncheckedUpdateManyWithoutTest_suitesInput>
  }

  export type test_runsUpsertWithWhereUniqueWithoutTest_suitesInput = {
    where: test_runsWhereUniqueInput
    update: XOR<test_runsUpdateWithoutTest_suitesInput, test_runsUncheckedUpdateWithoutTest_suitesInput>
    create: XOR<test_runsCreateWithoutTest_suitesInput, test_runsUncheckedCreateWithoutTest_suitesInput>
  }

  export type test_runsUpdateWithWhereUniqueWithoutTest_suitesInput = {
    where: test_runsWhereUniqueInput
    data: XOR<test_runsUpdateWithoutTest_suitesInput, test_runsUncheckedUpdateWithoutTest_suitesInput>
  }

  export type test_runsUpdateManyWithWhereWithoutTest_suitesInput = {
    where: test_runsScalarWhereInput
    data: XOR<test_runsUpdateManyMutationInput, test_runsUncheckedUpdateManyWithoutTest_suitesInput>
  }

  export type test_runsScalarWhereInput = {
    AND?: test_runsScalarWhereInput | test_runsScalarWhereInput[]
    OR?: test_runsScalarWhereInput[]
    NOT?: test_runsScalarWhereInput | test_runsScalarWhereInput[]
    id?: IntFilter<"test_runs"> | number
    suite_id?: IntFilter<"test_runs"> | number
    trigger_user_id?: IntFilter<"test_runs"> | number
    status?: Enumtest_runs_statusFilter<"test_runs"> | $Enums.test_runs_status
    started_at?: DateTimeNullableFilter<"test_runs"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"test_runs"> | Date | string | null
  }

  export type usersUpsertWithoutTest_suitesInput = {
    update: XOR<usersUpdateWithoutTest_suitesInput, usersUncheckedUpdateWithoutTest_suitesInput>
    create: XOR<usersCreateWithoutTest_suitesInput, usersUncheckedCreateWithoutTest_suitesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTest_suitesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTest_suitesInput, usersUncheckedUpdateWithoutTest_suitesInput>
  }

  export type usersUpdateWithoutTest_suitesInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutTest_suitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type usersCreateWithoutUser_rolesInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutUser_rolesInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutUser_rolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
  }

  export type rolesCreateWithoutUser_rolesInput = {
    name: string
  }

  export type rolesUncheckedCreateWithoutUser_rolesInput = {
    id?: number
    name: string
  }

  export type rolesCreateOrConnectWithoutUser_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
  }

  export type usersUpsertWithoutUser_rolesInput = {
    update: XOR<usersUpdateWithoutUser_rolesInput, usersUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_rolesInput, usersUncheckedUpdateWithoutUser_rolesInput>
  }

  export type usersUpdateWithoutUser_rolesInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type rolesUpsertWithoutUser_rolesInput = {
    update: XOR<rolesUpdateWithoutUser_rolesInput, rolesUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUser_rolesInput, rolesUncheckedUpdateWithoutUser_rolesInput>
  }

  export type rolesUpdateWithoutUser_rolesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateWithoutUser_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ai_generation_sessionsCreateWithoutUsersInput = {
    id: string
    axure_filename: string
    axure_file_size: number
    project_name?: string | null
    system_type?: string | null
    business_domain?: string | null
    requirement_doc?: string | null
    page_count?: number
    element_count?: number
    interaction_count?: number
    total_generated?: number
    total_saved?: number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    requirement_documents?: requirement_documentsCreateNestedManyWithoutAi_sessionInput
  }

  export type ai_generation_sessionsUncheckedCreateWithoutUsersInput = {
    id: string
    axure_filename: string
    axure_file_size: number
    project_name?: string | null
    system_type?: string | null
    business_domain?: string | null
    requirement_doc?: string | null
    page_count?: number
    element_count?: number
    interaction_count?: number
    total_generated?: number
    total_saved?: number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutAi_sessionInput
  }

  export type ai_generation_sessionsCreateOrConnectWithoutUsersInput = {
    where: ai_generation_sessionsWhereUniqueInput
    create: XOR<ai_generation_sessionsCreateWithoutUsersInput, ai_generation_sessionsUncheckedCreateWithoutUsersInput>
  }

  export type ai_generation_sessionsCreateManyUsersInputEnvelope = {
    data: ai_generation_sessionsCreateManyUsersInput | ai_generation_sessionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type api_tokensCreateWithoutUsersInput = {
    token_hash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type api_tokensUncheckedCreateWithoutUsersInput = {
    id?: number
    token_hash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type api_tokensCreateOrConnectWithoutUsersInput = {
    where: api_tokensWhereUniqueInput
    create: XOR<api_tokensCreateWithoutUsersInput, api_tokensUncheckedCreateWithoutUsersInput>
  }

  export type api_tokensCreateManyUsersInputEnvelope = {
    data: api_tokensCreateManyUsersInput | api_tokensCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type audit_logsCreateWithoutUsersInput = {
    id?: bigint | number
    action: string
    target_type?: string | null
    target_id?: bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type audit_logsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    action: string
    target_type?: string | null
    target_id?: bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type audit_logsCreateOrConnectWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    create: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsCreateManyUsersInputEnvelope = {
    data: audit_logsCreateManyUsersInput | audit_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type bulk_edit_sessionsCreateWithoutUsersInput = {
    system: string
    module: string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: string | null
    change_brief: string
    status?: $Enums.bulk_edit_sessions_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
    proposals?: case_patch_proposalsCreateNestedManyWithoutSessionInput
  }

  export type bulk_edit_sessionsUncheckedCreateWithoutUsersInput = {
    id?: number
    system: string
    module: string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: string | null
    change_brief: string
    status?: $Enums.bulk_edit_sessions_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
    proposals?: case_patch_proposalsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type bulk_edit_sessionsCreateOrConnectWithoutUsersInput = {
    where: bulk_edit_sessionsWhereUniqueInput
    create: XOR<bulk_edit_sessionsCreateWithoutUsersInput, bulk_edit_sessionsUncheckedCreateWithoutUsersInput>
  }

  export type bulk_edit_sessionsCreateManyUsersInputEnvelope = {
    data: bulk_edit_sessionsCreateManyUsersInput | bulk_edit_sessionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type case_versionsCreateWithoutUsersInput = {
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    test_cases: test_casesCreateNestedOneWithoutCase_versionsInput
  }

  export type case_versionsUncheckedCreateWithoutUsersInput = {
    id?: number
    case_id: number
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type case_versionsCreateOrConnectWithoutUsersInput = {
    where: case_versionsWhereUniqueInput
    create: XOR<case_versionsCreateWithoutUsersInput, case_versionsUncheckedCreateWithoutUsersInput>
  }

  export type case_versionsCreateManyUsersInputEnvelope = {
    data: case_versionsCreateManyUsersInput | case_versionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type functional_test_casesCreateWithoutUsersInput = {
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    deleted_at?: Date | string | null
    project_version?: project_versionsCreateNestedOneWithoutFunctional_test_casesInput
    requirement_doc?: requirement_documentsCreateNestedOneWithoutTest_casesInput
    executions?: functional_test_executionsCreateNestedManyWithoutTest_caseInput
  }

  export type functional_test_casesUncheckedCreateWithoutUsersInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    project_version_id?: number | null
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    requirement_doc_id?: number | null
    deleted_at?: Date | string | null
    executions?: functional_test_executionsUncheckedCreateNestedManyWithoutTest_caseInput
  }

  export type functional_test_casesCreateOrConnectWithoutUsersInput = {
    where: functional_test_casesWhereUniqueInput
    create: XOR<functional_test_casesCreateWithoutUsersInput, functional_test_casesUncheckedCreateWithoutUsersInput>
  }

  export type functional_test_casesCreateManyUsersInputEnvelope = {
    data: functional_test_casesCreateManyUsersInput | functional_test_casesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type requirement_documentsCreateWithoutUsersInput = {
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesCreateNestedManyWithoutRequirement_docInput
    ai_session?: ai_generation_sessionsCreateNestedOneWithoutRequirement_documentsInput
    project?: systemsCreateNestedOneWithoutRequirement_documentsInput
    project_version?: project_versionsCreateNestedOneWithoutRequirement_documentsInput
  }

  export type requirement_documentsUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_id?: number | null
    project_version_id?: number | null
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutRequirement_docInput
  }

  export type requirement_documentsCreateOrConnectWithoutUsersInput = {
    where: requirement_documentsWhereUniqueInput
    create: XOR<requirement_documentsCreateWithoutUsersInput, requirement_documentsUncheckedCreateWithoutUsersInput>
  }

  export type requirement_documentsCreateManyUsersInputEnvelope = {
    data: requirement_documentsCreateManyUsersInput | requirement_documentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type test_case_executionsCreateWithoutUsersInput = {
    id: string
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    test_cases: test_casesCreateNestedOneWithoutTest_case_executionsInput
  }

  export type test_case_executionsUncheckedCreateWithoutUsersInput = {
    id: string
    test_case_id: number
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_case_executionsCreateOrConnectWithoutUsersInput = {
    where: test_case_executionsWhereUniqueInput
    create: XOR<test_case_executionsCreateWithoutUsersInput, test_case_executionsUncheckedCreateWithoutUsersInput>
  }

  export type test_case_executionsCreateManyUsersInputEnvelope = {
    data: test_case_executionsCreateManyUsersInput | test_case_executionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type test_runsCreateWithoutUsersInput = {
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsCreateNestedManyWithoutTest_runsInput
    reports?: reportsCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_runsInput
    test_suites: test_suitesCreateNestedOneWithoutTest_runsInput
  }

  export type test_runsUncheckedCreateWithoutUsersInput = {
    id?: number
    suite_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
    ai_runs?: ai_runsUncheckedCreateNestedManyWithoutTest_runsInput
    reports?: reportsUncheckedCreateNestedManyWithoutTest_runsInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_runsInput
  }

  export type test_runsCreateOrConnectWithoutUsersInput = {
    where: test_runsWhereUniqueInput
    create: XOR<test_runsCreateWithoutUsersInput, test_runsUncheckedCreateWithoutUsersInput>
  }

  export type test_runsCreateManyUsersInputEnvelope = {
    data: test_runsCreateManyUsersInput | test_runsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type test_suitesCreateWithoutUsersInput = {
    name: string
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_suitesInput
    test_runs?: test_runsCreateNestedManyWithoutTest_suitesInput
  }

  export type test_suitesUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_suitesInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutTest_suitesInput
  }

  export type test_suitesCreateOrConnectWithoutUsersInput = {
    where: test_suitesWhereUniqueInput
    create: XOR<test_suitesCreateWithoutUsersInput, test_suitesUncheckedCreateWithoutUsersInput>
  }

  export type test_suitesCreateManyUsersInputEnvelope = {
    data: test_suitesCreateManyUsersInput | test_suitesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesCreateWithoutUsersInput = {
    roles: rolesCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateWithoutUsersInput = {
    role_id: number
  }

  export type user_rolesCreateOrConnectWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesCreateManyUsersInputEnvelope = {
    data: user_rolesCreateManyUsersInput | user_rolesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type functional_test_executionsCreateWithoutExecutorInput = {
    id?: string
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    test_case: functional_test_casesCreateNestedOneWithoutExecutionsInput
  }

  export type functional_test_executionsUncheckedCreateWithoutExecutorInput = {
    id?: string
    test_case_id: number
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsCreateOrConnectWithoutExecutorInput = {
    where: functional_test_executionsWhereUniqueInput
    create: XOR<functional_test_executionsCreateWithoutExecutorInput, functional_test_executionsUncheckedCreateWithoutExecutorInput>
  }

  export type functional_test_executionsCreateManyExecutorInputEnvelope = {
    data: functional_test_executionsCreateManyExecutorInput | functional_test_executionsCreateManyExecutorInput[]
    skipDuplicates?: boolean
  }

  export type test_plansCreateWithoutOwnerInput = {
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    plan_cases?: test_plan_casesCreateNestedManyWithoutPlanInput
    plan_executions?: test_plan_executionsCreateNestedManyWithoutPlanInput
  }

  export type test_plansUncheckedCreateWithoutOwnerInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    plan_cases?: test_plan_casesUncheckedCreateNestedManyWithoutPlanInput
    plan_executions?: test_plan_executionsUncheckedCreateNestedManyWithoutPlanInput
  }

  export type test_plansCreateOrConnectWithoutOwnerInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutOwnerInput, test_plansUncheckedCreateWithoutOwnerInput>
  }

  export type test_plansCreateManyOwnerInputEnvelope = {
    data: test_plansCreateManyOwnerInput | test_plansCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ai_generation_sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ai_generation_sessionsWhereUniqueInput
    update: XOR<ai_generation_sessionsUpdateWithoutUsersInput, ai_generation_sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<ai_generation_sessionsCreateWithoutUsersInput, ai_generation_sessionsUncheckedCreateWithoutUsersInput>
  }

  export type ai_generation_sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ai_generation_sessionsWhereUniqueInput
    data: XOR<ai_generation_sessionsUpdateWithoutUsersInput, ai_generation_sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type ai_generation_sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: ai_generation_sessionsScalarWhereInput
    data: XOR<ai_generation_sessionsUpdateManyMutationInput, ai_generation_sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ai_generation_sessionsScalarWhereInput = {
    AND?: ai_generation_sessionsScalarWhereInput | ai_generation_sessionsScalarWhereInput[]
    OR?: ai_generation_sessionsScalarWhereInput[]
    NOT?: ai_generation_sessionsScalarWhereInput | ai_generation_sessionsScalarWhereInput[]
    id?: StringFilter<"ai_generation_sessions"> | string
    user_id?: IntFilter<"ai_generation_sessions"> | number
    axure_filename?: StringFilter<"ai_generation_sessions"> | string
    axure_file_size?: IntFilter<"ai_generation_sessions"> | number
    project_name?: StringNullableFilter<"ai_generation_sessions"> | string | null
    system_type?: StringNullableFilter<"ai_generation_sessions"> | string | null
    business_domain?: StringNullableFilter<"ai_generation_sessions"> | string | null
    requirement_doc?: StringNullableFilter<"ai_generation_sessions"> | string | null
    page_count?: IntFilter<"ai_generation_sessions"> | number
    element_count?: IntFilter<"ai_generation_sessions"> | number
    interaction_count?: IntFilter<"ai_generation_sessions"> | number
    total_generated?: IntFilter<"ai_generation_sessions"> | number
    total_saved?: IntFilter<"ai_generation_sessions"> | number
    batches?: JsonNullableFilter<"ai_generation_sessions">
    pre_analysis_result?: JsonNullableFilter<"ai_generation_sessions">
    enhanced_data?: JsonNullableFilter<"ai_generation_sessions">
    created_at?: DateTimeFilter<"ai_generation_sessions"> | Date | string
  }

  export type api_tokensUpsertWithWhereUniqueWithoutUsersInput = {
    where: api_tokensWhereUniqueInput
    update: XOR<api_tokensUpdateWithoutUsersInput, api_tokensUncheckedUpdateWithoutUsersInput>
    create: XOR<api_tokensCreateWithoutUsersInput, api_tokensUncheckedCreateWithoutUsersInput>
  }

  export type api_tokensUpdateWithWhereUniqueWithoutUsersInput = {
    where: api_tokensWhereUniqueInput
    data: XOR<api_tokensUpdateWithoutUsersInput, api_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type api_tokensUpdateManyWithWhereWithoutUsersInput = {
    where: api_tokensScalarWhereInput
    data: XOR<api_tokensUpdateManyMutationInput, api_tokensUncheckedUpdateManyWithoutUsersInput>
  }

  export type api_tokensScalarWhereInput = {
    AND?: api_tokensScalarWhereInput | api_tokensScalarWhereInput[]
    OR?: api_tokensScalarWhereInput[]
    NOT?: api_tokensScalarWhereInput | api_tokensScalarWhereInput[]
    id?: IntFilter<"api_tokens"> | number
    user_id?: IntFilter<"api_tokens"> | number
    token_hash?: StringFilter<"api_tokens"> | string
    scopes?: JsonNullableFilter<"api_tokens">
    expires_at?: DateTimeNullableFilter<"api_tokens"> | Date | string | null
    created_at?: DateTimeNullableFilter<"api_tokens"> | Date | string | null
  }

  export type audit_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    update: XOR<audit_logsUpdateWithoutUsersInput, audit_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    data: XOR<audit_logsUpdateWithoutUsersInput, audit_logsUncheckedUpdateWithoutUsersInput>
  }

  export type audit_logsUpdateManyWithWhereWithoutUsersInput = {
    where: audit_logsScalarWhereInput
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type audit_logsScalarWhereInput = {
    AND?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
    OR?: audit_logsScalarWhereInput[]
    NOT?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
    id?: BigIntFilter<"audit_logs"> | bigint | number
    user_id?: IntNullableFilter<"audit_logs"> | number | null
    action?: StringFilter<"audit_logs"> | string
    target_type?: StringNullableFilter<"audit_logs"> | string | null
    target_id?: BigIntNullableFilter<"audit_logs"> | bigint | number | null
    meta?: JsonNullableFilter<"audit_logs">
    created_at?: DateTimeNullableFilter<"audit_logs"> | Date | string | null
  }

  export type bulk_edit_sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: bulk_edit_sessionsWhereUniqueInput
    update: XOR<bulk_edit_sessionsUpdateWithoutUsersInput, bulk_edit_sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<bulk_edit_sessionsCreateWithoutUsersInput, bulk_edit_sessionsUncheckedCreateWithoutUsersInput>
  }

  export type bulk_edit_sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: bulk_edit_sessionsWhereUniqueInput
    data: XOR<bulk_edit_sessionsUpdateWithoutUsersInput, bulk_edit_sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type bulk_edit_sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: bulk_edit_sessionsScalarWhereInput
    data: XOR<bulk_edit_sessionsUpdateManyMutationInput, bulk_edit_sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type bulk_edit_sessionsScalarWhereInput = {
    AND?: bulk_edit_sessionsScalarWhereInput | bulk_edit_sessionsScalarWhereInput[]
    OR?: bulk_edit_sessionsScalarWhereInput[]
    NOT?: bulk_edit_sessionsScalarWhereInput | bulk_edit_sessionsScalarWhereInput[]
    id?: IntFilter<"bulk_edit_sessions"> | number
    system?: StringFilter<"bulk_edit_sessions"> | string
    module?: StringFilter<"bulk_edit_sessions"> | string
    tag_filter?: JsonNullableFilter<"bulk_edit_sessions">
    priority_filter?: StringNullableFilter<"bulk_edit_sessions"> | string | null
    change_brief?: StringFilter<"bulk_edit_sessions"> | string
    status?: Enumbulk_edit_sessions_statusFilter<"bulk_edit_sessions"> | $Enums.bulk_edit_sessions_status
    created_by?: IntFilter<"bulk_edit_sessions"> | number
    created_at?: DateTimeNullableFilter<"bulk_edit_sessions"> | Date | string | null
    applied_at?: DateTimeNullableFilter<"bulk_edit_sessions"> | Date | string | null
  }

  export type case_versionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: case_versionsWhereUniqueInput
    update: XOR<case_versionsUpdateWithoutUsersInput, case_versionsUncheckedUpdateWithoutUsersInput>
    create: XOR<case_versionsCreateWithoutUsersInput, case_versionsUncheckedCreateWithoutUsersInput>
  }

  export type case_versionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: case_versionsWhereUniqueInput
    data: XOR<case_versionsUpdateWithoutUsersInput, case_versionsUncheckedUpdateWithoutUsersInput>
  }

  export type case_versionsUpdateManyWithWhereWithoutUsersInput = {
    where: case_versionsScalarWhereInput
    data: XOR<case_versionsUpdateManyMutationInput, case_versionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type functional_test_casesUpsertWithWhereUniqueWithoutUsersInput = {
    where: functional_test_casesWhereUniqueInput
    update: XOR<functional_test_casesUpdateWithoutUsersInput, functional_test_casesUncheckedUpdateWithoutUsersInput>
    create: XOR<functional_test_casesCreateWithoutUsersInput, functional_test_casesUncheckedCreateWithoutUsersInput>
  }

  export type functional_test_casesUpdateWithWhereUniqueWithoutUsersInput = {
    where: functional_test_casesWhereUniqueInput
    data: XOR<functional_test_casesUpdateWithoutUsersInput, functional_test_casesUncheckedUpdateWithoutUsersInput>
  }

  export type functional_test_casesUpdateManyWithWhereWithoutUsersInput = {
    where: functional_test_casesScalarWhereInput
    data: XOR<functional_test_casesUpdateManyMutationInput, functional_test_casesUncheckedUpdateManyWithoutUsersInput>
  }

  export type functional_test_casesScalarWhereInput = {
    AND?: functional_test_casesScalarWhereInput | functional_test_casesScalarWhereInput[]
    OR?: functional_test_casesScalarWhereInput[]
    NOT?: functional_test_casesScalarWhereInput | functional_test_casesScalarWhereInput[]
    id?: IntFilter<"functional_test_cases"> | number
    case_id?: StringNullableFilter<"functional_test_cases"> | string | null
    name?: StringFilter<"functional_test_cases"> | string
    description?: StringNullableFilter<"functional_test_cases"> | string | null
    system?: StringNullableFilter<"functional_test_cases"> | string | null
    module?: StringNullableFilter<"functional_test_cases"> | string | null
    priority?: Enumfunctional_test_priorityFilter<"functional_test_cases"> | $Enums.functional_test_priority
    tags?: StringNullableFilter<"functional_test_cases"> | string | null
    status?: Enumfunctional_test_statusFilter<"functional_test_cases"> | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFilter<"functional_test_cases"> | $Enums.functional_test_source
    ai_session_id?: StringNullableFilter<"functional_test_cases"> | string | null
    creator_id?: IntFilter<"functional_test_cases"> | number
    test_type?: StringNullableFilter<"functional_test_cases"> | string | null
    preconditions?: StringNullableFilter<"functional_test_cases"> | string | null
    test_data?: StringNullableFilter<"functional_test_cases"> | string | null
    section_id?: StringNullableFilter<"functional_test_cases"> | string | null
    section_name?: StringNullableFilter<"functional_test_cases"> | string | null
    scenario_name?: StringNullableFilter<"functional_test_cases"> | string | null
    scenario_description?: StringNullableFilter<"functional_test_cases"> | string | null
    batch_number?: IntNullableFilter<"functional_test_cases"> | number | null
    coverage_areas?: StringNullableFilter<"functional_test_cases"> | string | null
    created_at?: DateTimeFilter<"functional_test_cases"> | Date | string
    updated_at?: DateTimeFilter<"functional_test_cases"> | Date | string
    case_type?: Enumfunctional_case_typeFilter<"functional_test_cases"> | $Enums.functional_case_type
    project_version_id?: IntNullableFilter<"functional_test_cases"> | number | null
    requirement_source?: StringNullableFilter<"functional_test_cases"> | string | null
    section_description?: StringNullableFilter<"functional_test_cases"> | string | null
    expected_result?: StringNullableFilter<"functional_test_cases"> | string | null
    risk_level?: Enumfunctional_risk_levelFilter<"functional_test_cases"> | $Enums.functional_risk_level
    steps?: StringNullableFilter<"functional_test_cases"> | string | null
    test_point_name?: StringNullableFilter<"functional_test_cases"> | string | null
    test_purpose?: StringNullableFilter<"functional_test_cases"> | string | null
    requirement_doc_id?: IntNullableFilter<"functional_test_cases"> | number | null
    deleted_at?: DateTimeNullableFilter<"functional_test_cases"> | Date | string | null
  }

  export type requirement_documentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: requirement_documentsWhereUniqueInput
    update: XOR<requirement_documentsUpdateWithoutUsersInput, requirement_documentsUncheckedUpdateWithoutUsersInput>
    create: XOR<requirement_documentsCreateWithoutUsersInput, requirement_documentsUncheckedCreateWithoutUsersInput>
  }

  export type requirement_documentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: requirement_documentsWhereUniqueInput
    data: XOR<requirement_documentsUpdateWithoutUsersInput, requirement_documentsUncheckedUpdateWithoutUsersInput>
  }

  export type requirement_documentsUpdateManyWithWhereWithoutUsersInput = {
    where: requirement_documentsScalarWhereInput
    data: XOR<requirement_documentsUpdateManyMutationInput, requirement_documentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type requirement_documentsScalarWhereInput = {
    AND?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
    OR?: requirement_documentsScalarWhereInput[]
    NOT?: requirement_documentsScalarWhereInput | requirement_documentsScalarWhereInput[]
    id?: IntFilter<"requirement_documents"> | number
    title?: StringFilter<"requirement_documents"> | string
    content?: StringFilter<"requirement_documents"> | string
    summary?: StringNullableFilter<"requirement_documents"> | string | null
    source_filename?: StringNullableFilter<"requirement_documents"> | string | null
    ai_session_id?: StringNullableFilter<"requirement_documents"> | string | null
    project_id?: IntNullableFilter<"requirement_documents"> | number | null
    project_version_id?: IntNullableFilter<"requirement_documents"> | number | null
    creator_id?: IntFilter<"requirement_documents"> | number
    scenario_count?: IntFilter<"requirement_documents"> | number
    test_case_count?: IntFilter<"requirement_documents"> | number
    status?: Enumrequirement_doc_statusFilter<"requirement_documents"> | $Enums.requirement_doc_status
    created_at?: DateTimeFilter<"requirement_documents"> | Date | string
    updated_at?: DateTimeFilter<"requirement_documents"> | Date | string
    module?: StringNullableFilter<"requirement_documents"> | string | null
    system?: StringNullableFilter<"requirement_documents"> | string | null
  }

  export type test_case_executionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: test_case_executionsWhereUniqueInput
    update: XOR<test_case_executionsUpdateWithoutUsersInput, test_case_executionsUncheckedUpdateWithoutUsersInput>
    create: XOR<test_case_executionsCreateWithoutUsersInput, test_case_executionsUncheckedCreateWithoutUsersInput>
  }

  export type test_case_executionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: test_case_executionsWhereUniqueInput
    data: XOR<test_case_executionsUpdateWithoutUsersInput, test_case_executionsUncheckedUpdateWithoutUsersInput>
  }

  export type test_case_executionsUpdateManyWithWhereWithoutUsersInput = {
    where: test_case_executionsScalarWhereInput
    data: XOR<test_case_executionsUpdateManyMutationInput, test_case_executionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type test_runsUpsertWithWhereUniqueWithoutUsersInput = {
    where: test_runsWhereUniqueInput
    update: XOR<test_runsUpdateWithoutUsersInput, test_runsUncheckedUpdateWithoutUsersInput>
    create: XOR<test_runsCreateWithoutUsersInput, test_runsUncheckedCreateWithoutUsersInput>
  }

  export type test_runsUpdateWithWhereUniqueWithoutUsersInput = {
    where: test_runsWhereUniqueInput
    data: XOR<test_runsUpdateWithoutUsersInput, test_runsUncheckedUpdateWithoutUsersInput>
  }

  export type test_runsUpdateManyWithWhereWithoutUsersInput = {
    where: test_runsScalarWhereInput
    data: XOR<test_runsUpdateManyMutationInput, test_runsUncheckedUpdateManyWithoutUsersInput>
  }

  export type test_suitesUpsertWithWhereUniqueWithoutUsersInput = {
    where: test_suitesWhereUniqueInput
    update: XOR<test_suitesUpdateWithoutUsersInput, test_suitesUncheckedUpdateWithoutUsersInput>
    create: XOR<test_suitesCreateWithoutUsersInput, test_suitesUncheckedCreateWithoutUsersInput>
  }

  export type test_suitesUpdateWithWhereUniqueWithoutUsersInput = {
    where: test_suitesWhereUniqueInput
    data: XOR<test_suitesUpdateWithoutUsersInput, test_suitesUncheckedUpdateWithoutUsersInput>
  }

  export type test_suitesUpdateManyWithWhereWithoutUsersInput = {
    where: test_suitesScalarWhereInput
    data: XOR<test_suitesUpdateManyMutationInput, test_suitesUncheckedUpdateManyWithoutUsersInput>
  }

  export type test_suitesScalarWhereInput = {
    AND?: test_suitesScalarWhereInput | test_suitesScalarWhereInput[]
    OR?: test_suitesScalarWhereInput[]
    NOT?: test_suitesScalarWhereInput | test_suitesScalarWhereInput[]
    id?: IntFilter<"test_suites"> | number
    name?: StringFilter<"test_suites"> | string
    owner_id?: IntFilter<"test_suites"> | number
    project?: StringNullableFilter<"test_suites"> | string | null
    metadata?: JsonNullableFilter<"test_suites">
    created_at?: DateTimeNullableFilter<"test_suites"> | Date | string | null
  }

  export type user_rolesUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutUsersInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutUsersInput>
  }

  export type functional_test_executionsUpsertWithWhereUniqueWithoutExecutorInput = {
    where: functional_test_executionsWhereUniqueInput
    update: XOR<functional_test_executionsUpdateWithoutExecutorInput, functional_test_executionsUncheckedUpdateWithoutExecutorInput>
    create: XOR<functional_test_executionsCreateWithoutExecutorInput, functional_test_executionsUncheckedCreateWithoutExecutorInput>
  }

  export type functional_test_executionsUpdateWithWhereUniqueWithoutExecutorInput = {
    where: functional_test_executionsWhereUniqueInput
    data: XOR<functional_test_executionsUpdateWithoutExecutorInput, functional_test_executionsUncheckedUpdateWithoutExecutorInput>
  }

  export type functional_test_executionsUpdateManyWithWhereWithoutExecutorInput = {
    where: functional_test_executionsScalarWhereInput
    data: XOR<functional_test_executionsUpdateManyMutationInput, functional_test_executionsUncheckedUpdateManyWithoutExecutorInput>
  }

  export type functional_test_executionsScalarWhereInput = {
    AND?: functional_test_executionsScalarWhereInput | functional_test_executionsScalarWhereInput[]
    OR?: functional_test_executionsScalarWhereInput[]
    NOT?: functional_test_executionsScalarWhereInput | functional_test_executionsScalarWhereInput[]
    id?: StringFilter<"functional_test_executions"> | string
    test_case_id?: IntFilter<"functional_test_executions"> | number
    test_case_name?: StringFilter<"functional_test_executions"> | string
    final_result?: Enumfunctional_execution_resultFilter<"functional_test_executions"> | $Enums.functional_execution_result
    actual_result?: StringFilter<"functional_test_executions"> | string
    comments?: StringNullableFilter<"functional_test_executions"> | string | null
    duration_ms?: IntNullableFilter<"functional_test_executions"> | number | null
    executed_at?: DateTimeFilter<"functional_test_executions"> | Date | string
    executor_id?: IntFilter<"functional_test_executions"> | number
    executor_project?: StringNullableFilter<"functional_test_executions"> | string | null
    step_results?: JsonNullableFilter<"functional_test_executions">
    total_steps?: IntFilter<"functional_test_executions"> | number
    completed_steps?: IntFilter<"functional_test_executions"> | number
    passed_steps?: IntFilter<"functional_test_executions"> | number
    failed_steps?: IntFilter<"functional_test_executions"> | number
    blocked_steps?: IntFilter<"functional_test_executions"> | number
    screenshots?: JsonNullableFilter<"functional_test_executions">
    attachments?: JsonNullableFilter<"functional_test_executions">
    metadata?: JsonNullableFilter<"functional_test_executions">
  }

  export type test_plansUpsertWithWhereUniqueWithoutOwnerInput = {
    where: test_plansWhereUniqueInput
    update: XOR<test_plansUpdateWithoutOwnerInput, test_plansUncheckedUpdateWithoutOwnerInput>
    create: XOR<test_plansCreateWithoutOwnerInput, test_plansUncheckedCreateWithoutOwnerInput>
  }

  export type test_plansUpdateWithWhereUniqueWithoutOwnerInput = {
    where: test_plansWhereUniqueInput
    data: XOR<test_plansUpdateWithoutOwnerInput, test_plansUncheckedUpdateWithoutOwnerInput>
  }

  export type test_plansUpdateManyWithWhereWithoutOwnerInput = {
    where: test_plansScalarWhereInput
    data: XOR<test_plansUpdateManyMutationInput, test_plansUncheckedUpdateManyWithoutOwnerInput>
  }

  export type test_plansScalarWhereInput = {
    AND?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
    OR?: test_plansScalarWhereInput[]
    NOT?: test_plansScalarWhereInput | test_plansScalarWhereInput[]
    id?: IntFilter<"test_plans"> | number
    name?: StringFilter<"test_plans"> | string
    short_name?: StringNullableFilter<"test_plans"> | string | null
    description?: StringNullableFilter<"test_plans"> | string | null
    project?: StringNullableFilter<"test_plans"> | string | null
    plan_type?: Enumtest_plan_typeFilter<"test_plans"> | $Enums.test_plan_type
    status?: Enumtest_plan_statusFilter<"test_plans"> | $Enums.test_plan_status
    members?: JsonNullableFilter<"test_plans">
    owner_id?: IntFilter<"test_plans"> | number
    start_date?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    end_date?: DateTimeNullableFilter<"test_plans"> | Date | string | null
    created_at?: DateTimeFilter<"test_plans"> | Date | string
    updated_at?: DateTimeFilter<"test_plans"> | Date | string
    deleted_at?: DateTimeNullableFilter<"test_plans"> | Date | string | null
  }

  export type test_casesCreateWithoutCase_versionsInput = {
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesUncheckedCreateWithoutCase_versionsInput = {
    id?: number
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsUncheckedCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesCreateOrConnectWithoutCase_versionsInput = {
    where: test_casesWhereUniqueInput
    create: XOR<test_casesCreateWithoutCase_versionsInput, test_casesUncheckedCreateWithoutCase_versionsInput>
  }

  export type usersCreateWithoutCase_versionsInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutCase_versionsInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutCase_versionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCase_versionsInput, usersUncheckedCreateWithoutCase_versionsInput>
  }

  export type test_casesUpsertWithoutCase_versionsInput = {
    update: XOR<test_casesUpdateWithoutCase_versionsInput, test_casesUncheckedUpdateWithoutCase_versionsInput>
    create: XOR<test_casesCreateWithoutCase_versionsInput, test_casesUncheckedCreateWithoutCase_versionsInput>
    where?: test_casesWhereInput
  }

  export type test_casesUpdateToOneWithWhereWithoutCase_versionsInput = {
    where?: test_casesWhereInput
    data: XOR<test_casesUpdateWithoutCase_versionsInput, test_casesUncheckedUpdateWithoutCase_versionsInput>
  }

  export type test_casesUpdateWithoutCase_versionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_casesNestedInput
  }

  export type test_casesUncheckedUpdateWithoutCase_versionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUncheckedUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_casesNestedInput
  }

  export type usersUpsertWithoutCase_versionsInput = {
    update: XOR<usersUpdateWithoutCase_versionsInput, usersUncheckedUpdateWithoutCase_versionsInput>
    create: XOR<usersCreateWithoutCase_versionsInput, usersUncheckedCreateWithoutCase_versionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCase_versionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCase_versionsInput, usersUncheckedUpdateWithoutCase_versionsInput>
  }

  export type usersUpdateWithoutCase_versionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutCase_versionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type usersCreateWithoutBulk_edit_sessionsInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutBulk_edit_sessionsInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutBulk_edit_sessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBulk_edit_sessionsInput, usersUncheckedCreateWithoutBulk_edit_sessionsInput>
  }

  export type case_patch_proposalsCreateWithoutSessionInput = {
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
    test_cases: test_casesCreateNestedOneWithoutPatch_proposalsInput
  }

  export type case_patch_proposalsUncheckedCreateWithoutSessionInput = {
    id?: number
    case_id: number
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type case_patch_proposalsCreateOrConnectWithoutSessionInput = {
    where: case_patch_proposalsWhereUniqueInput
    create: XOR<case_patch_proposalsCreateWithoutSessionInput, case_patch_proposalsUncheckedCreateWithoutSessionInput>
  }

  export type case_patch_proposalsCreateManySessionInputEnvelope = {
    data: case_patch_proposalsCreateManySessionInput | case_patch_proposalsCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutBulk_edit_sessionsInput = {
    update: XOR<usersUpdateWithoutBulk_edit_sessionsInput, usersUncheckedUpdateWithoutBulk_edit_sessionsInput>
    create: XOR<usersCreateWithoutBulk_edit_sessionsInput, usersUncheckedCreateWithoutBulk_edit_sessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBulk_edit_sessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBulk_edit_sessionsInput, usersUncheckedUpdateWithoutBulk_edit_sessionsInput>
  }

  export type usersUpdateWithoutBulk_edit_sessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutBulk_edit_sessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type case_patch_proposalsUpsertWithWhereUniqueWithoutSessionInput = {
    where: case_patch_proposalsWhereUniqueInput
    update: XOR<case_patch_proposalsUpdateWithoutSessionInput, case_patch_proposalsUncheckedUpdateWithoutSessionInput>
    create: XOR<case_patch_proposalsCreateWithoutSessionInput, case_patch_proposalsUncheckedCreateWithoutSessionInput>
  }

  export type case_patch_proposalsUpdateWithWhereUniqueWithoutSessionInput = {
    where: case_patch_proposalsWhereUniqueInput
    data: XOR<case_patch_proposalsUpdateWithoutSessionInput, case_patch_proposalsUncheckedUpdateWithoutSessionInput>
  }

  export type case_patch_proposalsUpdateManyWithWhereWithoutSessionInput = {
    where: case_patch_proposalsScalarWhereInput
    data: XOR<case_patch_proposalsUpdateManyMutationInput, case_patch_proposalsUncheckedUpdateManyWithoutSessionInput>
  }

  export type test_casesCreateWithoutPatch_proposalsInput = {
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    case_versions?: case_versionsCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesUncheckedCreateWithoutPatch_proposalsInput = {
    id?: number
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsUncheckedCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_casesInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesCreateOrConnectWithoutPatch_proposalsInput = {
    where: test_casesWhereUniqueInput
    create: XOR<test_casesCreateWithoutPatch_proposalsInput, test_casesUncheckedCreateWithoutPatch_proposalsInput>
  }

  export type bulk_edit_sessionsCreateWithoutProposalsInput = {
    system: string
    module: string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: string | null
    change_brief: string
    status?: $Enums.bulk_edit_sessions_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
    users: usersCreateNestedOneWithoutBulk_edit_sessionsInput
  }

  export type bulk_edit_sessionsUncheckedCreateWithoutProposalsInput = {
    id?: number
    system: string
    module: string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: string | null
    change_brief: string
    status?: $Enums.bulk_edit_sessions_status
    created_by: number
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type bulk_edit_sessionsCreateOrConnectWithoutProposalsInput = {
    where: bulk_edit_sessionsWhereUniqueInput
    create: XOR<bulk_edit_sessionsCreateWithoutProposalsInput, bulk_edit_sessionsUncheckedCreateWithoutProposalsInput>
  }

  export type test_casesUpsertWithoutPatch_proposalsInput = {
    update: XOR<test_casesUpdateWithoutPatch_proposalsInput, test_casesUncheckedUpdateWithoutPatch_proposalsInput>
    create: XOR<test_casesCreateWithoutPatch_proposalsInput, test_casesUncheckedCreateWithoutPatch_proposalsInput>
    where?: test_casesWhereInput
  }

  export type test_casesUpdateToOneWithWhereWithoutPatch_proposalsInput = {
    where?: test_casesWhereInput
    data: XOR<test_casesUpdateWithoutPatch_proposalsInput, test_casesUncheckedUpdateWithoutPatch_proposalsInput>
  }

  export type test_casesUpdateWithoutPatch_proposalsInput = {
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_versions?: case_versionsUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_casesNestedInput
  }

  export type test_casesUncheckedUpdateWithoutPatch_proposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_versions?: case_versionsUncheckedUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUncheckedUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_casesNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_casesNestedInput
  }

  export type bulk_edit_sessionsUpsertWithoutProposalsInput = {
    update: XOR<bulk_edit_sessionsUpdateWithoutProposalsInput, bulk_edit_sessionsUncheckedUpdateWithoutProposalsInput>
    create: XOR<bulk_edit_sessionsCreateWithoutProposalsInput, bulk_edit_sessionsUncheckedCreateWithoutProposalsInput>
    where?: bulk_edit_sessionsWhereInput
  }

  export type bulk_edit_sessionsUpdateToOneWithWhereWithoutProposalsInput = {
    where?: bulk_edit_sessionsWhereInput
    data: XOR<bulk_edit_sessionsUpdateWithoutProposalsInput, bulk_edit_sessionsUncheckedUpdateWithoutProposalsInput>
  }

  export type bulk_edit_sessionsUpdateWithoutProposalsInput = {
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutBulk_edit_sessionsNestedInput
  }

  export type bulk_edit_sessionsUncheckedUpdateWithoutProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_by?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateWithoutTest_case_executionsInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutTest_case_executionsInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutTest_case_executionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTest_case_executionsInput, usersUncheckedCreateWithoutTest_case_executionsInput>
  }

  export type test_casesCreateWithoutTest_case_executionsInput = {
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesUncheckedCreateWithoutTest_case_executionsInput = {
    id?: number
    title: string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    project?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedCreateNestedManyWithoutTest_casesInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutTest_casesInput
    step_screenshots?: step_screenshotsUncheckedCreateNestedManyWithoutTest_casesInput
    suite_case_map?: suite_case_mapUncheckedCreateNestedManyWithoutTest_casesInput
    test_run_results?: test_run_resultsUncheckedCreateNestedManyWithoutTest_casesInput
  }

  export type test_casesCreateOrConnectWithoutTest_case_executionsInput = {
    where: test_casesWhereUniqueInput
    create: XOR<test_casesCreateWithoutTest_case_executionsInput, test_casesUncheckedCreateWithoutTest_case_executionsInput>
  }

  export type usersUpsertWithoutTest_case_executionsInput = {
    update: XOR<usersUpdateWithoutTest_case_executionsInput, usersUncheckedUpdateWithoutTest_case_executionsInput>
    create: XOR<usersCreateWithoutTest_case_executionsInput, usersUncheckedCreateWithoutTest_case_executionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTest_case_executionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTest_case_executionsInput, usersUncheckedUpdateWithoutTest_case_executionsInput>
  }

  export type usersUpdateWithoutTest_case_executionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutTest_case_executionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type test_casesUpsertWithoutTest_case_executionsInput = {
    update: XOR<test_casesUpdateWithoutTest_case_executionsInput, test_casesUncheckedUpdateWithoutTest_case_executionsInput>
    create: XOR<test_casesCreateWithoutTest_case_executionsInput, test_casesUncheckedCreateWithoutTest_case_executionsInput>
    where?: test_casesWhereInput
  }

  export type test_casesUpdateToOneWithWhereWithoutTest_case_executionsInput = {
    where?: test_casesWhereInput
    data: XOR<test_casesUpdateWithoutTest_case_executionsInput, test_casesUncheckedUpdateWithoutTest_case_executionsInput>
  }

  export type test_casesUpdateWithoutTest_case_executionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_casesNestedInput
  }

  export type test_casesUncheckedUpdateWithoutTest_case_executionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patch_proposals?: case_patch_proposalsUncheckedUpdateManyWithoutTest_casesNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutTest_casesNestedInput
    step_screenshots?: step_screenshotsUncheckedUpdateManyWithoutTest_casesNestedInput
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_casesNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_casesNestedInput
  }

  export type usersCreateWithoutFunctional_test_casesInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutFunctional_test_casesInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutFunctional_test_casesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFunctional_test_casesInput, usersUncheckedCreateWithoutFunctional_test_casesInput>
  }

  export type project_versionsCreateWithoutFunctional_test_casesInput = {
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: systemsCreateNestedOneWithoutVersionsInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutProject_versionInput
  }

  export type project_versionsUncheckedCreateWithoutFunctional_test_casesInput = {
    id?: number
    project_id: number
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutProject_versionInput
  }

  export type project_versionsCreateOrConnectWithoutFunctional_test_casesInput = {
    where: project_versionsWhereUniqueInput
    create: XOR<project_versionsCreateWithoutFunctional_test_casesInput, project_versionsUncheckedCreateWithoutFunctional_test_casesInput>
  }

  export type requirement_documentsCreateWithoutTest_casesInput = {
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    ai_session?: ai_generation_sessionsCreateNestedOneWithoutRequirement_documentsInput
    users: usersCreateNestedOneWithoutRequirement_documentsInput
    project?: systemsCreateNestedOneWithoutRequirement_documentsInput
    project_version?: project_versionsCreateNestedOneWithoutRequirement_documentsInput
  }

  export type requirement_documentsUncheckedCreateWithoutTest_casesInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_id?: number | null
    project_version_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
  }

  export type requirement_documentsCreateOrConnectWithoutTest_casesInput = {
    where: requirement_documentsWhereUniqueInput
    create: XOR<requirement_documentsCreateWithoutTest_casesInput, requirement_documentsUncheckedCreateWithoutTest_casesInput>
  }

  export type functional_test_executionsCreateWithoutTest_caseInput = {
    id?: string
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executor: usersCreateNestedOneWithoutFunctional_test_executionsInput
  }

  export type functional_test_executionsUncheckedCreateWithoutTest_caseInput = {
    id?: string
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_id: number
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsCreateOrConnectWithoutTest_caseInput = {
    where: functional_test_executionsWhereUniqueInput
    create: XOR<functional_test_executionsCreateWithoutTest_caseInput, functional_test_executionsUncheckedCreateWithoutTest_caseInput>
  }

  export type functional_test_executionsCreateManyTest_caseInputEnvelope = {
    data: functional_test_executionsCreateManyTest_caseInput | functional_test_executionsCreateManyTest_caseInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutFunctional_test_casesInput = {
    update: XOR<usersUpdateWithoutFunctional_test_casesInput, usersUncheckedUpdateWithoutFunctional_test_casesInput>
    create: XOR<usersCreateWithoutFunctional_test_casesInput, usersUncheckedCreateWithoutFunctional_test_casesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFunctional_test_casesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFunctional_test_casesInput, usersUncheckedUpdateWithoutFunctional_test_casesInput>
  }

  export type usersUpdateWithoutFunctional_test_casesInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutFunctional_test_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type project_versionsUpsertWithoutFunctional_test_casesInput = {
    update: XOR<project_versionsUpdateWithoutFunctional_test_casesInput, project_versionsUncheckedUpdateWithoutFunctional_test_casesInput>
    create: XOR<project_versionsCreateWithoutFunctional_test_casesInput, project_versionsUncheckedCreateWithoutFunctional_test_casesInput>
    where?: project_versionsWhereInput
  }

  export type project_versionsUpdateToOneWithWhereWithoutFunctional_test_casesInput = {
    where?: project_versionsWhereInput
    data: XOR<project_versionsUpdateWithoutFunctional_test_casesInput, project_versionsUncheckedUpdateWithoutFunctional_test_casesInput>
  }

  export type project_versionsUpdateWithoutFunctional_test_casesInput = {
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: systemsUpdateOneRequiredWithoutVersionsNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutProject_versionNestedInput
  }

  export type project_versionsUncheckedUpdateWithoutFunctional_test_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutProject_versionNestedInput
  }

  export type requirement_documentsUpsertWithoutTest_casesInput = {
    update: XOR<requirement_documentsUpdateWithoutTest_casesInput, requirement_documentsUncheckedUpdateWithoutTest_casesInput>
    create: XOR<requirement_documentsCreateWithoutTest_casesInput, requirement_documentsUncheckedCreateWithoutTest_casesInput>
    where?: requirement_documentsWhereInput
  }

  export type requirement_documentsUpdateToOneWithWhereWithoutTest_casesInput = {
    where?: requirement_documentsWhereInput
    data: XOR<requirement_documentsUpdateWithoutTest_casesInput, requirement_documentsUncheckedUpdateWithoutTest_casesInput>
  }

  export type requirement_documentsUpdateWithoutTest_casesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session?: ai_generation_sessionsUpdateOneWithoutRequirement_documentsNestedInput
    users?: usersUpdateOneRequiredWithoutRequirement_documentsNestedInput
    project?: systemsUpdateOneWithoutRequirement_documentsNestedInput
    project_version?: project_versionsUpdateOneWithoutRequirement_documentsNestedInput
  }

  export type requirement_documentsUncheckedUpdateWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type functional_test_executionsUpsertWithWhereUniqueWithoutTest_caseInput = {
    where: functional_test_executionsWhereUniqueInput
    update: XOR<functional_test_executionsUpdateWithoutTest_caseInput, functional_test_executionsUncheckedUpdateWithoutTest_caseInput>
    create: XOR<functional_test_executionsCreateWithoutTest_caseInput, functional_test_executionsUncheckedCreateWithoutTest_caseInput>
  }

  export type functional_test_executionsUpdateWithWhereUniqueWithoutTest_caseInput = {
    where: functional_test_executionsWhereUniqueInput
    data: XOR<functional_test_executionsUpdateWithoutTest_caseInput, functional_test_executionsUncheckedUpdateWithoutTest_caseInput>
  }

  export type functional_test_executionsUpdateManyWithWhereWithoutTest_caseInput = {
    where: functional_test_executionsScalarWhereInput
    data: XOR<functional_test_executionsUpdateManyMutationInput, functional_test_executionsUncheckedUpdateManyWithoutTest_caseInput>
  }

  export type usersCreateWithoutAi_generation_sessionsInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutAi_generation_sessionsInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutAi_generation_sessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_generation_sessionsInput, usersUncheckedCreateWithoutAi_generation_sessionsInput>
  }

  export type requirement_documentsCreateWithoutAi_sessionInput = {
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesCreateNestedManyWithoutRequirement_docInput
    users: usersCreateNestedOneWithoutRequirement_documentsInput
    project?: systemsCreateNestedOneWithoutRequirement_documentsInput
    project_version?: project_versionsCreateNestedOneWithoutRequirement_documentsInput
  }

  export type requirement_documentsUncheckedCreateWithoutAi_sessionInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    project_id?: number | null
    project_version_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutRequirement_docInput
  }

  export type requirement_documentsCreateOrConnectWithoutAi_sessionInput = {
    where: requirement_documentsWhereUniqueInput
    create: XOR<requirement_documentsCreateWithoutAi_sessionInput, requirement_documentsUncheckedCreateWithoutAi_sessionInput>
  }

  export type requirement_documentsCreateManyAi_sessionInputEnvelope = {
    data: requirement_documentsCreateManyAi_sessionInput | requirement_documentsCreateManyAi_sessionInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutAi_generation_sessionsInput = {
    update: XOR<usersUpdateWithoutAi_generation_sessionsInput, usersUncheckedUpdateWithoutAi_generation_sessionsInput>
    create: XOR<usersCreateWithoutAi_generation_sessionsInput, usersUncheckedCreateWithoutAi_generation_sessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_generation_sessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_generation_sessionsInput, usersUncheckedUpdateWithoutAi_generation_sessionsInput>
  }

  export type usersUpdateWithoutAi_generation_sessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_generation_sessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type requirement_documentsUpsertWithWhereUniqueWithoutAi_sessionInput = {
    where: requirement_documentsWhereUniqueInput
    update: XOR<requirement_documentsUpdateWithoutAi_sessionInput, requirement_documentsUncheckedUpdateWithoutAi_sessionInput>
    create: XOR<requirement_documentsCreateWithoutAi_sessionInput, requirement_documentsUncheckedCreateWithoutAi_sessionInput>
  }

  export type requirement_documentsUpdateWithWhereUniqueWithoutAi_sessionInput = {
    where: requirement_documentsWhereUniqueInput
    data: XOR<requirement_documentsUpdateWithoutAi_sessionInput, requirement_documentsUncheckedUpdateWithoutAi_sessionInput>
  }

  export type requirement_documentsUpdateManyWithWhereWithoutAi_sessionInput = {
    where: requirement_documentsScalarWhereInput
    data: XOR<requirement_documentsUpdateManyMutationInput, requirement_documentsUncheckedUpdateManyWithoutAi_sessionInput>
  }

  export type functional_test_casesCreateWithoutRequirement_docInput = {
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    deleted_at?: Date | string | null
    users: usersCreateNestedOneWithoutFunctional_test_casesInput
    project_version?: project_versionsCreateNestedOneWithoutFunctional_test_casesInput
    executions?: functional_test_executionsCreateNestedManyWithoutTest_caseInput
  }

  export type functional_test_casesUncheckedCreateWithoutRequirement_docInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    creator_id: number
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    project_version_id?: number | null
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    deleted_at?: Date | string | null
    executions?: functional_test_executionsUncheckedCreateNestedManyWithoutTest_caseInput
  }

  export type functional_test_casesCreateOrConnectWithoutRequirement_docInput = {
    where: functional_test_casesWhereUniqueInput
    create: XOR<functional_test_casesCreateWithoutRequirement_docInput, functional_test_casesUncheckedCreateWithoutRequirement_docInput>
  }

  export type functional_test_casesCreateManyRequirement_docInputEnvelope = {
    data: functional_test_casesCreateManyRequirement_docInput | functional_test_casesCreateManyRequirement_docInput[]
    skipDuplicates?: boolean
  }

  export type ai_generation_sessionsCreateWithoutRequirement_documentsInput = {
    id: string
    axure_filename: string
    axure_file_size: number
    project_name?: string | null
    system_type?: string | null
    business_domain?: string | null
    requirement_doc?: string | null
    page_count?: number
    element_count?: number
    interaction_count?: number
    total_generated?: number
    total_saved?: number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    users: usersCreateNestedOneWithoutAi_generation_sessionsInput
  }

  export type ai_generation_sessionsUncheckedCreateWithoutRequirement_documentsInput = {
    id: string
    user_id: number
    axure_filename: string
    axure_file_size: number
    project_name?: string | null
    system_type?: string | null
    business_domain?: string | null
    requirement_doc?: string | null
    page_count?: number
    element_count?: number
    interaction_count?: number
    total_generated?: number
    total_saved?: number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ai_generation_sessionsCreateOrConnectWithoutRequirement_documentsInput = {
    where: ai_generation_sessionsWhereUniqueInput
    create: XOR<ai_generation_sessionsCreateWithoutRequirement_documentsInput, ai_generation_sessionsUncheckedCreateWithoutRequirement_documentsInput>
  }

  export type usersCreateWithoutRequirement_documentsInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutRequirement_documentsInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutRequirement_documentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRequirement_documentsInput, usersUncheckedCreateWithoutRequirement_documentsInput>
  }

  export type systemsCreateWithoutRequirement_documentsInput = {
    name: string
    short_name?: string | null
    description?: string | null
    status?: $Enums.system_status
    sort_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    versions?: project_versionsCreateNestedManyWithoutProjectInput
  }

  export type systemsUncheckedCreateWithoutRequirement_documentsInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    status?: $Enums.system_status
    sort_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    versions?: project_versionsUncheckedCreateNestedManyWithoutProjectInput
  }

  export type systemsCreateOrConnectWithoutRequirement_documentsInput = {
    where: systemsWhereUniqueInput
    create: XOR<systemsCreateWithoutRequirement_documentsInput, systemsUncheckedCreateWithoutRequirement_documentsInput>
  }

  export type project_versionsCreateWithoutRequirement_documentsInput = {
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutProject_versionInput
    project: systemsCreateNestedOneWithoutVersionsInput
  }

  export type project_versionsUncheckedCreateWithoutRequirement_documentsInput = {
    id?: number
    project_id: number
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutProject_versionInput
  }

  export type project_versionsCreateOrConnectWithoutRequirement_documentsInput = {
    where: project_versionsWhereUniqueInput
    create: XOR<project_versionsCreateWithoutRequirement_documentsInput, project_versionsUncheckedCreateWithoutRequirement_documentsInput>
  }

  export type functional_test_casesUpsertWithWhereUniqueWithoutRequirement_docInput = {
    where: functional_test_casesWhereUniqueInput
    update: XOR<functional_test_casesUpdateWithoutRequirement_docInput, functional_test_casesUncheckedUpdateWithoutRequirement_docInput>
    create: XOR<functional_test_casesCreateWithoutRequirement_docInput, functional_test_casesUncheckedCreateWithoutRequirement_docInput>
  }

  export type functional_test_casesUpdateWithWhereUniqueWithoutRequirement_docInput = {
    where: functional_test_casesWhereUniqueInput
    data: XOR<functional_test_casesUpdateWithoutRequirement_docInput, functional_test_casesUncheckedUpdateWithoutRequirement_docInput>
  }

  export type functional_test_casesUpdateManyWithWhereWithoutRequirement_docInput = {
    where: functional_test_casesScalarWhereInput
    data: XOR<functional_test_casesUpdateManyMutationInput, functional_test_casesUncheckedUpdateManyWithoutRequirement_docInput>
  }

  export type ai_generation_sessionsUpsertWithoutRequirement_documentsInput = {
    update: XOR<ai_generation_sessionsUpdateWithoutRequirement_documentsInput, ai_generation_sessionsUncheckedUpdateWithoutRequirement_documentsInput>
    create: XOR<ai_generation_sessionsCreateWithoutRequirement_documentsInput, ai_generation_sessionsUncheckedCreateWithoutRequirement_documentsInput>
    where?: ai_generation_sessionsWhereInput
  }

  export type ai_generation_sessionsUpdateToOneWithWhereWithoutRequirement_documentsInput = {
    where?: ai_generation_sessionsWhereInput
    data: XOR<ai_generation_sessionsUpdateWithoutRequirement_documentsInput, ai_generation_sessionsUncheckedUpdateWithoutRequirement_documentsInput>
  }

  export type ai_generation_sessionsUpdateWithoutRequirement_documentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutAi_generation_sessionsNestedInput
  }

  export type ai_generation_sessionsUncheckedUpdateWithoutRequirement_documentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutRequirement_documentsInput = {
    update: XOR<usersUpdateWithoutRequirement_documentsInput, usersUncheckedUpdateWithoutRequirement_documentsInput>
    create: XOR<usersCreateWithoutRequirement_documentsInput, usersUncheckedCreateWithoutRequirement_documentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRequirement_documentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRequirement_documentsInput, usersUncheckedUpdateWithoutRequirement_documentsInput>
  }

  export type usersUpdateWithoutRequirement_documentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutRequirement_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type systemsUpsertWithoutRequirement_documentsInput = {
    update: XOR<systemsUpdateWithoutRequirement_documentsInput, systemsUncheckedUpdateWithoutRequirement_documentsInput>
    create: XOR<systemsCreateWithoutRequirement_documentsInput, systemsUncheckedCreateWithoutRequirement_documentsInput>
    where?: systemsWhereInput
  }

  export type systemsUpdateToOneWithWhereWithoutRequirement_documentsInput = {
    where?: systemsWhereInput
    data: XOR<systemsUpdateWithoutRequirement_documentsInput, systemsUncheckedUpdateWithoutRequirement_documentsInput>
  }

  export type systemsUpdateWithoutRequirement_documentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    sort_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: project_versionsUpdateManyWithoutProjectNestedInput
  }

  export type systemsUncheckedUpdateWithoutRequirement_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    sort_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: project_versionsUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type project_versionsUpsertWithoutRequirement_documentsInput = {
    update: XOR<project_versionsUpdateWithoutRequirement_documentsInput, project_versionsUncheckedUpdateWithoutRequirement_documentsInput>
    create: XOR<project_versionsCreateWithoutRequirement_documentsInput, project_versionsUncheckedCreateWithoutRequirement_documentsInput>
    where?: project_versionsWhereInput
  }

  export type project_versionsUpdateToOneWithWhereWithoutRequirement_documentsInput = {
    where?: project_versionsWhereInput
    data: XOR<project_versionsUpdateWithoutRequirement_documentsInput, project_versionsUncheckedUpdateWithoutRequirement_documentsInput>
  }

  export type project_versionsUpdateWithoutRequirement_documentsInput = {
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    functional_test_cases?: functional_test_casesUpdateManyWithoutProject_versionNestedInput
    project?: systemsUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type project_versionsUncheckedUpdateWithoutRequirement_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutProject_versionNestedInput
  }

  export type project_versionsCreateWithoutProjectInput = {
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutProject_versionInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutProject_versionInput
  }

  export type project_versionsUncheckedCreateWithoutProjectInput = {
    id?: number
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutProject_versionInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutProject_versionInput
  }

  export type project_versionsCreateOrConnectWithoutProjectInput = {
    where: project_versionsWhereUniqueInput
    create: XOR<project_versionsCreateWithoutProjectInput, project_versionsUncheckedCreateWithoutProjectInput>
  }

  export type project_versionsCreateManyProjectInputEnvelope = {
    data: project_versionsCreateManyProjectInput | project_versionsCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type requirement_documentsCreateWithoutProjectInput = {
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesCreateNestedManyWithoutRequirement_docInput
    ai_session?: ai_generation_sessionsCreateNestedOneWithoutRequirement_documentsInput
    users: usersCreateNestedOneWithoutRequirement_documentsInput
    project_version?: project_versionsCreateNestedOneWithoutRequirement_documentsInput
  }

  export type requirement_documentsUncheckedCreateWithoutProjectInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_version_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutRequirement_docInput
  }

  export type requirement_documentsCreateOrConnectWithoutProjectInput = {
    where: requirement_documentsWhereUniqueInput
    create: XOR<requirement_documentsCreateWithoutProjectInput, requirement_documentsUncheckedCreateWithoutProjectInput>
  }

  export type requirement_documentsCreateManyProjectInputEnvelope = {
    data: requirement_documentsCreateManyProjectInput | requirement_documentsCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type project_versionsUpsertWithWhereUniqueWithoutProjectInput = {
    where: project_versionsWhereUniqueInput
    update: XOR<project_versionsUpdateWithoutProjectInput, project_versionsUncheckedUpdateWithoutProjectInput>
    create: XOR<project_versionsCreateWithoutProjectInput, project_versionsUncheckedCreateWithoutProjectInput>
  }

  export type project_versionsUpdateWithWhereUniqueWithoutProjectInput = {
    where: project_versionsWhereUniqueInput
    data: XOR<project_versionsUpdateWithoutProjectInput, project_versionsUncheckedUpdateWithoutProjectInput>
  }

  export type project_versionsUpdateManyWithWhereWithoutProjectInput = {
    where: project_versionsScalarWhereInput
    data: XOR<project_versionsUpdateManyMutationInput, project_versionsUncheckedUpdateManyWithoutProjectInput>
  }

  export type project_versionsScalarWhereInput = {
    AND?: project_versionsScalarWhereInput | project_versionsScalarWhereInput[]
    OR?: project_versionsScalarWhereInput[]
    NOT?: project_versionsScalarWhereInput | project_versionsScalarWhereInput[]
    id?: IntFilter<"project_versions"> | number
    project_id?: IntFilter<"project_versions"> | number
    version_name?: StringFilter<"project_versions"> | string
    version_code?: StringFilter<"project_versions"> | string
    description?: StringNullableFilter<"project_versions"> | string | null
    is_main?: BoolFilter<"project_versions"> | boolean
    status?: Enumsystem_statusFilter<"project_versions"> | $Enums.system_status
    release_date?: DateTimeNullableFilter<"project_versions"> | Date | string | null
    created_at?: DateTimeFilter<"project_versions"> | Date | string
    updated_at?: DateTimeFilter<"project_versions"> | Date | string
  }

  export type requirement_documentsUpsertWithWhereUniqueWithoutProjectInput = {
    where: requirement_documentsWhereUniqueInput
    update: XOR<requirement_documentsUpdateWithoutProjectInput, requirement_documentsUncheckedUpdateWithoutProjectInput>
    create: XOR<requirement_documentsCreateWithoutProjectInput, requirement_documentsUncheckedCreateWithoutProjectInput>
  }

  export type requirement_documentsUpdateWithWhereUniqueWithoutProjectInput = {
    where: requirement_documentsWhereUniqueInput
    data: XOR<requirement_documentsUpdateWithoutProjectInput, requirement_documentsUncheckedUpdateWithoutProjectInput>
  }

  export type requirement_documentsUpdateManyWithWhereWithoutProjectInput = {
    where: requirement_documentsScalarWhereInput
    data: XOR<requirement_documentsUpdateManyMutationInput, requirement_documentsUncheckedUpdateManyWithoutProjectInput>
  }

  export type functional_test_casesCreateWithoutProject_versionInput = {
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    deleted_at?: Date | string | null
    users: usersCreateNestedOneWithoutFunctional_test_casesInput
    requirement_doc?: requirement_documentsCreateNestedOneWithoutTest_casesInput
    executions?: functional_test_executionsCreateNestedManyWithoutTest_caseInput
  }

  export type functional_test_casesUncheckedCreateWithoutProject_versionInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    creator_id: number
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    requirement_doc_id?: number | null
    deleted_at?: Date | string | null
    executions?: functional_test_executionsUncheckedCreateNestedManyWithoutTest_caseInput
  }

  export type functional_test_casesCreateOrConnectWithoutProject_versionInput = {
    where: functional_test_casesWhereUniqueInput
    create: XOR<functional_test_casesCreateWithoutProject_versionInput, functional_test_casesUncheckedCreateWithoutProject_versionInput>
  }

  export type functional_test_casesCreateManyProject_versionInputEnvelope = {
    data: functional_test_casesCreateManyProject_versionInput | functional_test_casesCreateManyProject_versionInput[]
    skipDuplicates?: boolean
  }

  export type systemsCreateWithoutVersionsInput = {
    name: string
    short_name?: string | null
    description?: string | null
    status?: $Enums.system_status
    sort_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    requirement_documents?: requirement_documentsCreateNestedManyWithoutProjectInput
  }

  export type systemsUncheckedCreateWithoutVersionsInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    status?: $Enums.system_status
    sort_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutProjectInput
  }

  export type systemsCreateOrConnectWithoutVersionsInput = {
    where: systemsWhereUniqueInput
    create: XOR<systemsCreateWithoutVersionsInput, systemsUncheckedCreateWithoutVersionsInput>
  }

  export type requirement_documentsCreateWithoutProject_versionInput = {
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesCreateNestedManyWithoutRequirement_docInput
    ai_session?: ai_generation_sessionsCreateNestedOneWithoutRequirement_documentsInput
    users: usersCreateNestedOneWithoutRequirement_documentsInput
    project?: systemsCreateNestedOneWithoutRequirement_documentsInput
  }

  export type requirement_documentsUncheckedCreateWithoutProject_versionInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
    test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutRequirement_docInput
  }

  export type requirement_documentsCreateOrConnectWithoutProject_versionInput = {
    where: requirement_documentsWhereUniqueInput
    create: XOR<requirement_documentsCreateWithoutProject_versionInput, requirement_documentsUncheckedCreateWithoutProject_versionInput>
  }

  export type requirement_documentsCreateManyProject_versionInputEnvelope = {
    data: requirement_documentsCreateManyProject_versionInput | requirement_documentsCreateManyProject_versionInput[]
    skipDuplicates?: boolean
  }

  export type functional_test_casesUpsertWithWhereUniqueWithoutProject_versionInput = {
    where: functional_test_casesWhereUniqueInput
    update: XOR<functional_test_casesUpdateWithoutProject_versionInput, functional_test_casesUncheckedUpdateWithoutProject_versionInput>
    create: XOR<functional_test_casesCreateWithoutProject_versionInput, functional_test_casesUncheckedCreateWithoutProject_versionInput>
  }

  export type functional_test_casesUpdateWithWhereUniqueWithoutProject_versionInput = {
    where: functional_test_casesWhereUniqueInput
    data: XOR<functional_test_casesUpdateWithoutProject_versionInput, functional_test_casesUncheckedUpdateWithoutProject_versionInput>
  }

  export type functional_test_casesUpdateManyWithWhereWithoutProject_versionInput = {
    where: functional_test_casesScalarWhereInput
    data: XOR<functional_test_casesUpdateManyMutationInput, functional_test_casesUncheckedUpdateManyWithoutProject_versionInput>
  }

  export type systemsUpsertWithoutVersionsInput = {
    update: XOR<systemsUpdateWithoutVersionsInput, systemsUncheckedUpdateWithoutVersionsInput>
    create: XOR<systemsCreateWithoutVersionsInput, systemsUncheckedCreateWithoutVersionsInput>
    where?: systemsWhereInput
  }

  export type systemsUpdateToOneWithWhereWithoutVersionsInput = {
    where?: systemsWhereInput
    data: XOR<systemsUpdateWithoutVersionsInput, systemsUncheckedUpdateWithoutVersionsInput>
  }

  export type systemsUpdateWithoutVersionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    sort_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement_documents?: requirement_documentsUpdateManyWithoutProjectNestedInput
  }

  export type systemsUncheckedUpdateWithoutVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    sort_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type requirement_documentsUpsertWithWhereUniqueWithoutProject_versionInput = {
    where: requirement_documentsWhereUniqueInput
    update: XOR<requirement_documentsUpdateWithoutProject_versionInput, requirement_documentsUncheckedUpdateWithoutProject_versionInput>
    create: XOR<requirement_documentsCreateWithoutProject_versionInput, requirement_documentsUncheckedCreateWithoutProject_versionInput>
  }

  export type requirement_documentsUpdateWithWhereUniqueWithoutProject_versionInput = {
    where: requirement_documentsWhereUniqueInput
    data: XOR<requirement_documentsUpdateWithoutProject_versionInput, requirement_documentsUncheckedUpdateWithoutProject_versionInput>
  }

  export type requirement_documentsUpdateManyWithWhereWithoutProject_versionInput = {
    where: requirement_documentsScalarWhereInput
    data: XOR<requirement_documentsUpdateManyMutationInput, requirement_documentsUncheckedUpdateManyWithoutProject_versionInput>
  }

  export type functional_test_casesCreateWithoutExecutionsInput = {
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    deleted_at?: Date | string | null
    users: usersCreateNestedOneWithoutFunctional_test_casesInput
    project_version?: project_versionsCreateNestedOneWithoutFunctional_test_casesInput
    requirement_doc?: requirement_documentsCreateNestedOneWithoutTest_casesInput
  }

  export type functional_test_casesUncheckedCreateWithoutExecutionsInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    creator_id: number
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    project_version_id?: number | null
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    requirement_doc_id?: number | null
    deleted_at?: Date | string | null
  }

  export type functional_test_casesCreateOrConnectWithoutExecutionsInput = {
    where: functional_test_casesWhereUniqueInput
    create: XOR<functional_test_casesCreateWithoutExecutionsInput, functional_test_casesUncheckedCreateWithoutExecutionsInput>
  }

  export type usersCreateWithoutFunctional_test_executionsInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    test_plans?: test_plansCreateNestedManyWithoutOwnerInput
  }

  export type usersUncheckedCreateWithoutFunctional_test_executionsInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    test_plans?: test_plansUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type usersCreateOrConnectWithoutFunctional_test_executionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFunctional_test_executionsInput, usersUncheckedCreateWithoutFunctional_test_executionsInput>
  }

  export type functional_test_casesUpsertWithoutExecutionsInput = {
    update: XOR<functional_test_casesUpdateWithoutExecutionsInput, functional_test_casesUncheckedUpdateWithoutExecutionsInput>
    create: XOR<functional_test_casesCreateWithoutExecutionsInput, functional_test_casesUncheckedCreateWithoutExecutionsInput>
    where?: functional_test_casesWhereInput
  }

  export type functional_test_casesUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: functional_test_casesWhereInput
    data: XOR<functional_test_casesUpdateWithoutExecutionsInput, functional_test_casesUncheckedUpdateWithoutExecutionsInput>
  }

  export type functional_test_casesUpdateWithoutExecutionsInput = {
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutFunctional_test_casesNestedInput
    project_version?: project_versionsUpdateOneWithoutFunctional_test_casesNestedInput
    requirement_doc?: requirement_documentsUpdateOneWithoutTest_casesNestedInput
  }

  export type functional_test_casesUncheckedUpdateWithoutExecutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutFunctional_test_executionsInput = {
    update: XOR<usersUpdateWithoutFunctional_test_executionsInput, usersUncheckedUpdateWithoutFunctional_test_executionsInput>
    create: XOR<usersCreateWithoutFunctional_test_executionsInput, usersUncheckedCreateWithoutFunctional_test_executionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFunctional_test_executionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFunctional_test_executionsInput, usersUncheckedUpdateWithoutFunctional_test_executionsInput>
  }

  export type usersUpdateWithoutFunctional_test_executionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    test_plans?: test_plansUpdateManyWithoutOwnerNestedInput
  }

  export type usersUncheckedUpdateWithoutFunctional_test_executionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    test_plans?: test_plansUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type usersCreateWithoutTest_plansInput = {
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsCreateNestedManyWithoutUsersInput
    test_runs?: test_runsCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsCreateNestedManyWithoutExecutorInput
  }

  export type usersUncheckedCreateWithoutTest_plansInput = {
    id?: number
    email: string
    username: string
    account_name?: string | null
    password_hash: string
    project?: string | null
    is_super_admin?: boolean
    created_at?: Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedCreateNestedManyWithoutUsersInput
    api_tokens?: api_tokensUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedCreateNestedManyWithoutUsersInput
    case_versions?: case_versionsUncheckedCreateNestedManyWithoutUsersInput
    functional_test_cases?: functional_test_casesUncheckedCreateNestedManyWithoutUsersInput
    requirement_documents?: requirement_documentsUncheckedCreateNestedManyWithoutUsersInput
    test_case_executions?: test_case_executionsUncheckedCreateNestedManyWithoutUsersInput
    test_runs?: test_runsUncheckedCreateNestedManyWithoutUsersInput
    test_suites?: test_suitesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
    functional_test_executions?: functional_test_executionsUncheckedCreateNestedManyWithoutExecutorInput
  }

  export type usersCreateOrConnectWithoutTest_plansInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTest_plansInput, usersUncheckedCreateWithoutTest_plansInput>
  }

  export type test_plan_casesCreateWithoutPlanInput = {
    case_id: number
    case_type: string
    case_name: string
    sort_order?: number
    is_executed?: boolean
    execution_result?: string | null
    created_at?: Date | string
  }

  export type test_plan_casesUncheckedCreateWithoutPlanInput = {
    id?: number
    case_id: number
    case_type: string
    case_name: string
    sort_order?: number
    is_executed?: boolean
    execution_result?: string | null
    created_at?: Date | string
  }

  export type test_plan_casesCreateOrConnectWithoutPlanInput = {
    where: test_plan_casesWhereUniqueInput
    create: XOR<test_plan_casesCreateWithoutPlanInput, test_plan_casesUncheckedCreateWithoutPlanInput>
  }

  export type test_plan_casesCreateManyPlanInputEnvelope = {
    data: test_plan_casesCreateManyPlanInput | test_plan_casesCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type test_plan_executionsCreateWithoutPlanInput = {
    id?: string
    plan_name: string
    executor_id: number
    executor_name: string
    execution_type: string
    status: string
    progress?: number
    total_cases?: number
    completed_cases?: number
    passed_cases?: number
    failed_cases?: number
    blocked_cases?: number
    skipped_cases?: number
    started_at?: Date | string
    finished_at?: Date | string | null
    duration_ms?: number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_executionsUncheckedCreateWithoutPlanInput = {
    id?: string
    plan_name: string
    executor_id: number
    executor_name: string
    execution_type: string
    status: string
    progress?: number
    total_cases?: number
    completed_cases?: number
    passed_cases?: number
    failed_cases?: number
    blocked_cases?: number
    skipped_cases?: number
    started_at?: Date | string
    finished_at?: Date | string | null
    duration_ms?: number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_executionsCreateOrConnectWithoutPlanInput = {
    where: test_plan_executionsWhereUniqueInput
    create: XOR<test_plan_executionsCreateWithoutPlanInput, test_plan_executionsUncheckedCreateWithoutPlanInput>
  }

  export type test_plan_executionsCreateManyPlanInputEnvelope = {
    data: test_plan_executionsCreateManyPlanInput | test_plan_executionsCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutTest_plansInput = {
    update: XOR<usersUpdateWithoutTest_plansInput, usersUncheckedUpdateWithoutTest_plansInput>
    create: XOR<usersCreateWithoutTest_plansInput, usersUncheckedCreateWithoutTest_plansInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTest_plansInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTest_plansInput, usersUncheckedUpdateWithoutTest_plansInput>
  }

  export type usersUpdateWithoutTest_plansInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUpdateManyWithoutExecutorNestedInput
  }

  export type usersUncheckedUpdateWithoutTest_plansInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_sessions?: ai_generation_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    api_tokens?: api_tokensUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    bulk_edit_sessions?: bulk_edit_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    case_versions?: case_versionsUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutUsersNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutUsersNestedInput
    test_case_executions?: test_case_executionsUncheckedUpdateManyWithoutUsersNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutUsersNestedInput
    test_suites?: test_suitesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
    functional_test_executions?: functional_test_executionsUncheckedUpdateManyWithoutExecutorNestedInput
  }

  export type test_plan_casesUpsertWithWhereUniqueWithoutPlanInput = {
    where: test_plan_casesWhereUniqueInput
    update: XOR<test_plan_casesUpdateWithoutPlanInput, test_plan_casesUncheckedUpdateWithoutPlanInput>
    create: XOR<test_plan_casesCreateWithoutPlanInput, test_plan_casesUncheckedCreateWithoutPlanInput>
  }

  export type test_plan_casesUpdateWithWhereUniqueWithoutPlanInput = {
    where: test_plan_casesWhereUniqueInput
    data: XOR<test_plan_casesUpdateWithoutPlanInput, test_plan_casesUncheckedUpdateWithoutPlanInput>
  }

  export type test_plan_casesUpdateManyWithWhereWithoutPlanInput = {
    where: test_plan_casesScalarWhereInput
    data: XOR<test_plan_casesUpdateManyMutationInput, test_plan_casesUncheckedUpdateManyWithoutPlanInput>
  }

  export type test_plan_casesScalarWhereInput = {
    AND?: test_plan_casesScalarWhereInput | test_plan_casesScalarWhereInput[]
    OR?: test_plan_casesScalarWhereInput[]
    NOT?: test_plan_casesScalarWhereInput | test_plan_casesScalarWhereInput[]
    id?: IntFilter<"test_plan_cases"> | number
    plan_id?: IntFilter<"test_plan_cases"> | number
    case_id?: IntFilter<"test_plan_cases"> | number
    case_type?: StringFilter<"test_plan_cases"> | string
    case_name?: StringFilter<"test_plan_cases"> | string
    sort_order?: IntFilter<"test_plan_cases"> | number
    is_executed?: BoolFilter<"test_plan_cases"> | boolean
    execution_result?: StringNullableFilter<"test_plan_cases"> | string | null
    created_at?: DateTimeFilter<"test_plan_cases"> | Date | string
  }

  export type test_plan_executionsUpsertWithWhereUniqueWithoutPlanInput = {
    where: test_plan_executionsWhereUniqueInput
    update: XOR<test_plan_executionsUpdateWithoutPlanInput, test_plan_executionsUncheckedUpdateWithoutPlanInput>
    create: XOR<test_plan_executionsCreateWithoutPlanInput, test_plan_executionsUncheckedCreateWithoutPlanInput>
  }

  export type test_plan_executionsUpdateWithWhereUniqueWithoutPlanInput = {
    where: test_plan_executionsWhereUniqueInput
    data: XOR<test_plan_executionsUpdateWithoutPlanInput, test_plan_executionsUncheckedUpdateWithoutPlanInput>
  }

  export type test_plan_executionsUpdateManyWithWhereWithoutPlanInput = {
    where: test_plan_executionsScalarWhereInput
    data: XOR<test_plan_executionsUpdateManyMutationInput, test_plan_executionsUncheckedUpdateManyWithoutPlanInput>
  }

  export type test_plan_executionsScalarWhereInput = {
    AND?: test_plan_executionsScalarWhereInput | test_plan_executionsScalarWhereInput[]
    OR?: test_plan_executionsScalarWhereInput[]
    NOT?: test_plan_executionsScalarWhereInput | test_plan_executionsScalarWhereInput[]
    id?: StringFilter<"test_plan_executions"> | string
    plan_id?: IntFilter<"test_plan_executions"> | number
    plan_name?: StringFilter<"test_plan_executions"> | string
    executor_id?: IntFilter<"test_plan_executions"> | number
    executor_name?: StringFilter<"test_plan_executions"> | string
    execution_type?: StringFilter<"test_plan_executions"> | string
    status?: StringFilter<"test_plan_executions"> | string
    progress?: IntFilter<"test_plan_executions"> | number
    total_cases?: IntFilter<"test_plan_executions"> | number
    completed_cases?: IntFilter<"test_plan_executions"> | number
    passed_cases?: IntFilter<"test_plan_executions"> | number
    failed_cases?: IntFilter<"test_plan_executions"> | number
    blocked_cases?: IntFilter<"test_plan_executions"> | number
    skipped_cases?: IntFilter<"test_plan_executions"> | number
    started_at?: DateTimeFilter<"test_plan_executions"> | Date | string
    finished_at?: DateTimeNullableFilter<"test_plan_executions"> | Date | string | null
    duration_ms?: IntNullableFilter<"test_plan_executions"> | number | null
    execution_results?: JsonNullableFilter<"test_plan_executions">
    error_message?: StringNullableFilter<"test_plan_executions"> | string | null
    metadata?: JsonNullableFilter<"test_plan_executions">
  }

  export type test_plansCreateWithoutPlan_casesInput = {
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    owner: usersCreateNestedOneWithoutTest_plansInput
    plan_executions?: test_plan_executionsCreateNestedManyWithoutPlanInput
  }

  export type test_plansUncheckedCreateWithoutPlan_casesInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    owner_id: number
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    plan_executions?: test_plan_executionsUncheckedCreateNestedManyWithoutPlanInput
  }

  export type test_plansCreateOrConnectWithoutPlan_casesInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutPlan_casesInput, test_plansUncheckedCreateWithoutPlan_casesInput>
  }

  export type test_plansUpsertWithoutPlan_casesInput = {
    update: XOR<test_plansUpdateWithoutPlan_casesInput, test_plansUncheckedUpdateWithoutPlan_casesInput>
    create: XOR<test_plansCreateWithoutPlan_casesInput, test_plansUncheckedCreateWithoutPlan_casesInput>
    where?: test_plansWhereInput
  }

  export type test_plansUpdateToOneWithWhereWithoutPlan_casesInput = {
    where?: test_plansWhereInput
    data: XOR<test_plansUpdateWithoutPlan_casesInput, test_plansUncheckedUpdateWithoutPlan_casesInput>
  }

  export type test_plansUpdateWithoutPlan_casesInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: usersUpdateOneRequiredWithoutTest_plansNestedInput
    plan_executions?: test_plan_executionsUpdateManyWithoutPlanNestedInput
  }

  export type test_plansUncheckedUpdateWithoutPlan_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    owner_id?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan_executions?: test_plan_executionsUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type test_plansCreateWithoutPlan_executionsInput = {
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    owner: usersCreateNestedOneWithoutTest_plansInput
    plan_cases?: test_plan_casesCreateNestedManyWithoutPlanInput
  }

  export type test_plansUncheckedCreateWithoutPlan_executionsInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    owner_id: number
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    plan_cases?: test_plan_casesUncheckedCreateNestedManyWithoutPlanInput
  }

  export type test_plansCreateOrConnectWithoutPlan_executionsInput = {
    where: test_plansWhereUniqueInput
    create: XOR<test_plansCreateWithoutPlan_executionsInput, test_plansUncheckedCreateWithoutPlan_executionsInput>
  }

  export type test_plansUpsertWithoutPlan_executionsInput = {
    update: XOR<test_plansUpdateWithoutPlan_executionsInput, test_plansUncheckedUpdateWithoutPlan_executionsInput>
    create: XOR<test_plansCreateWithoutPlan_executionsInput, test_plansUncheckedCreateWithoutPlan_executionsInput>
    where?: test_plansWhereInput
  }

  export type test_plansUpdateToOneWithWhereWithoutPlan_executionsInput = {
    where?: test_plansWhereInput
    data: XOR<test_plansUpdateWithoutPlan_executionsInput, test_plansUncheckedUpdateWithoutPlan_executionsInput>
  }

  export type test_plansUpdateWithoutPlan_executionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: usersUpdateOneRequiredWithoutTest_plansNestedInput
    plan_cases?: test_plan_casesUpdateManyWithoutPlanNestedInput
  }

  export type test_plansUncheckedUpdateWithoutPlan_executionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    owner_id?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan_cases?: test_plan_casesUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ai_runsCreateManyAi_promptsInput = {
    id?: number
    run_id?: number | null
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
  }

  export type ai_runsUpdateWithoutAi_promptsInput = {
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_runs?: test_runsUpdateOneWithoutAi_runsNestedInput
  }

  export type ai_runsUncheckedUpdateWithoutAi_promptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: NullableIntFieldUpdateOperationsInput | number | null
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_runsUncheckedUpdateManyWithoutAi_promptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: NullableIntFieldUpdateOperationsInput | number | null
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_rolesCreateManyRolesInput = {
    user_id: number
  }

  export type user_rolesUpdateWithoutRolesInput = {
    users?: usersUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutRolesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesUncheckedUpdateManyWithoutRolesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type case_patch_proposalsCreateManyTest_casesInput = {
    id?: number
    session_id: number
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type case_versionsCreateManyTest_casesInput = {
    id?: number
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_by?: number | null
    created_at?: Date | string | null
  }

  export type step_screenshotsCreateManyTest_casesInput = {
    id?: number
    run_id: string
    step_index: string
    step_description?: string | null
    status: $Enums.step_screenshots_status
    file_path: string
    file_name: string
    file_size?: bigint | number | null
    mime_type?: string | null
    created_at?: Date | string | null
    file_exists?: boolean
  }

  export type suite_case_mapCreateManyTest_casesInput = {
    suite_id: number
  }

  export type test_case_executionsCreateManyTest_casesInput = {
    id: string
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_user_id?: number | null
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_run_resultsCreateManyTest_casesInput = {
    id?: number
    run_id: number
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
  }

  export type case_patch_proposalsUpdateWithoutTest_casesInput = {
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session?: bulk_edit_sessionsUpdateOneRequiredWithoutProposalsNestedInput
  }

  export type case_patch_proposalsUncheckedUpdateWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_patch_proposalsUncheckedUpdateManyWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_versionsUpdateWithoutTest_casesInput = {
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutCase_versionsNestedInput
  }

  export type case_versionsUncheckedUpdateWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_versionsUncheckedUpdateManyWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type step_screenshotsUpdateWithoutTest_casesInput = {
    run_id?: StringFieldUpdateOperationsInput | string
    step_index?: StringFieldUpdateOperationsInput | string
    step_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumstep_screenshots_statusFieldUpdateOperationsInput | $Enums.step_screenshots_status
    file_path?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_exists?: BoolFieldUpdateOperationsInput | boolean
  }

  export type step_screenshotsUncheckedUpdateWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: StringFieldUpdateOperationsInput | string
    step_index?: StringFieldUpdateOperationsInput | string
    step_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumstep_screenshots_statusFieldUpdateOperationsInput | $Enums.step_screenshots_status
    file_path?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_exists?: BoolFieldUpdateOperationsInput | boolean
  }

  export type step_screenshotsUncheckedUpdateManyWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: StringFieldUpdateOperationsInput | string
    step_index?: StringFieldUpdateOperationsInput | string
    step_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumstep_screenshots_statusFieldUpdateOperationsInput | $Enums.step_screenshots_status
    file_path?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_exists?: BoolFieldUpdateOperationsInput | boolean
  }

  export type suite_case_mapUpdateWithoutTest_casesInput = {
    test_suites?: test_suitesUpdateOneRequiredWithoutSuite_case_mapNestedInput
  }

  export type suite_case_mapUncheckedUpdateWithoutTest_casesInput = {
    suite_id?: IntFieldUpdateOperationsInput | number
  }

  export type suite_case_mapUncheckedUpdateManyWithoutTest_casesInput = {
    suite_id?: IntFieldUpdateOperationsInput | number
  }

  export type test_case_executionsUpdateWithoutTest_casesInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUpdateOneWithoutTest_case_executionsNestedInput
  }

  export type test_case_executionsUncheckedUpdateWithoutTest_casesInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_case_executionsUncheckedUpdateManyWithoutTest_casesInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_run_resultsUpdateWithoutTest_casesInput = {
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: attachmentsUpdateManyWithoutTest_run_resultsNestedInput
    test_runs?: test_runsUpdateOneRequiredWithoutTest_run_resultsNestedInput
  }

  export type test_run_resultsUncheckedUpdateWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: attachmentsUncheckedUpdateManyWithoutTest_run_resultsNestedInput
  }

  export type test_run_resultsUncheckedUpdateManyWithoutTest_casesInput = {
    id?: IntFieldUpdateOperationsInput | number
    run_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attachmentsCreateManyTest_run_resultsInput = {
    id?: number
    file_key: string
    mime_type?: string | null
    size_bytes?: bigint | number | null
    created_at?: Date | string | null
  }

  export type attachmentsUpdateWithoutTest_run_resultsInput = {
    file_key?: StringFieldUpdateOperationsInput | string
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attachmentsUncheckedUpdateWithoutTest_run_resultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_key?: StringFieldUpdateOperationsInput | string
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attachmentsUncheckedUpdateManyWithoutTest_run_resultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_key?: StringFieldUpdateOperationsInput | string
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_runsCreateManyTest_runsInput = {
    id?: number
    prompt_id: number
    token_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    executed_at?: Date | string | null
  }

  export type reportsCreateManyTest_runsInput = {
    id?: number
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: Date | string | null
  }

  export type test_run_resultsCreateManyTest_runsInput = {
    id?: number
    case_id: number
    status: $Enums.test_run_results_status
    duration_ms?: number | null
    screenshot_url?: string | null
    executed_at?: Date | string | null
  }

  export type ai_runsUpdateWithoutTest_runsInput = {
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_prompts?: ai_promptsUpdateOneRequiredWithoutAi_runsNestedInput
  }

  export type ai_runsUncheckedUpdateWithoutTest_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt_id?: IntFieldUpdateOperationsInput | number
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_runsUncheckedUpdateManyWithoutTest_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt_id?: IntFieldUpdateOperationsInput | number
    token_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportsUpdateWithoutTest_runsInput = {
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportsUncheckedUpdateWithoutTest_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportsUncheckedUpdateManyWithoutTest_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_run_resultsUpdateWithoutTest_runsInput = {
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: attachmentsUpdateManyWithoutTest_run_resultsNestedInput
    test_cases?: test_casesUpdateOneRequiredWithoutTest_run_resultsNestedInput
  }

  export type test_run_resultsUncheckedUpdateWithoutTest_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: attachmentsUncheckedUpdateManyWithoutTest_run_resultsNestedInput
  }

  export type test_run_resultsUncheckedUpdateManyWithoutTest_runsInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_run_results_statusFieldUpdateOperationsInput | $Enums.test_run_results_status
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot_url?: NullableStringFieldUpdateOperationsInput | string | null
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type suite_case_mapCreateManyTest_suitesInput = {
    case_id: number
  }

  export type test_runsCreateManyTest_suitesInput = {
    id?: number
    trigger_user_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
  }

  export type suite_case_mapUpdateWithoutTest_suitesInput = {
    test_cases?: test_casesUpdateOneRequiredWithoutSuite_case_mapNestedInput
  }

  export type suite_case_mapUncheckedUpdateWithoutTest_suitesInput = {
    case_id?: IntFieldUpdateOperationsInput | number
  }

  export type suite_case_mapUncheckedUpdateManyWithoutTest_suitesInput = {
    case_id?: IntFieldUpdateOperationsInput | number
  }

  export type test_runsUpdateWithoutTest_suitesInput = {
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUpdateManyWithoutTest_runsNestedInput
    reports?: reportsUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_runsNestedInput
    users?: usersUpdateOneRequiredWithoutTest_runsNestedInput
  }

  export type test_runsUncheckedUpdateWithoutTest_suitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    trigger_user_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUncheckedUpdateManyWithoutTest_runsNestedInput
    reports?: reportsUncheckedUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_runsNestedInput
  }

  export type test_runsUncheckedUpdateManyWithoutTest_suitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    trigger_user_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_generation_sessionsCreateManyUsersInput = {
    id: string
    axure_filename: string
    axure_file_size: number
    project_name?: string | null
    system_type?: string | null
    business_domain?: string | null
    requirement_doc?: string | null
    page_count?: number
    element_count?: number
    interaction_count?: number
    total_generated?: number
    total_saved?: number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type api_tokensCreateManyUsersInput = {
    id?: number
    token_hash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type audit_logsCreateManyUsersInput = {
    id?: bigint | number
    action: string
    target_type?: string | null
    target_id?: bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type bulk_edit_sessionsCreateManyUsersInput = {
    id?: number
    system: string
    module: string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: string | null
    change_brief: string
    status?: $Enums.bulk_edit_sessions_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type case_versionsCreateManyUsersInput = {
    id?: number
    case_id: number
    version: number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: string | null
    module?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type functional_test_casesCreateManyUsersInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    project_version_id?: number | null
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    requirement_doc_id?: number | null
    deleted_at?: Date | string | null
  }

  export type requirement_documentsCreateManyUsersInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_id?: number | null
    project_version_id?: number | null
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
  }

  export type test_case_executionsCreateManyUsersInput = {
    id: string
    test_case_id: number
    test_case_title: string
    environment?: string
    execution_mode?: string
    status?: $Enums.test_case_execution_status
    executor_project?: string | null
    queued_at?: Date | string
    started_at?: Date | string | null
    finished_at?: Date | string | null
    duration_ms?: number | null
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    progress?: number
    error_message?: string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_runsCreateManyUsersInput = {
    id?: number
    suite_id: number
    status: $Enums.test_runs_status
    started_at?: Date | string | null
    finished_at?: Date | string | null
  }

  export type test_suitesCreateManyUsersInput = {
    id?: number
    name: string
    project?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type user_rolesCreateManyUsersInput = {
    role_id: number
  }

  export type functional_test_executionsCreateManyExecutorInput = {
    id?: string
    test_case_id: number
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plansCreateManyOwnerInput = {
    id?: number
    name: string
    short_name?: string | null
    description?: string | null
    project?: string | null
    plan_type?: $Enums.test_plan_type
    status?: $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ai_generation_sessionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement_documents?: requirement_documentsUpdateManyWithoutAi_sessionNestedInput
  }

  export type ai_generation_sessionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutAi_sessionNestedInput
  }

  export type ai_generation_sessionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    axure_filename?: StringFieldUpdateOperationsInput | string
    axure_file_size?: IntFieldUpdateOperationsInput | number
    project_name?: NullableStringFieldUpdateOperationsInput | string | null
    system_type?: NullableStringFieldUpdateOperationsInput | string | null
    business_domain?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc?: NullableStringFieldUpdateOperationsInput | string | null
    page_count?: IntFieldUpdateOperationsInput | number
    element_count?: IntFieldUpdateOperationsInput | number
    interaction_count?: IntFieldUpdateOperationsInput | number
    total_generated?: IntFieldUpdateOperationsInput | number
    total_saved?: IntFieldUpdateOperationsInput | number
    batches?: NullableJsonNullValueInput | InputJsonValue
    pre_analysis_result?: NullableJsonNullValueInput | InputJsonValue
    enhanced_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_tokensUpdateWithoutUsersInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type api_tokensUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type api_tokensUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_logsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bulk_edit_sessionsUpdateWithoutUsersInput = {
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposals?: case_patch_proposalsUpdateManyWithoutSessionNestedInput
  }

  export type bulk_edit_sessionsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposals?: case_patch_proposalsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type bulk_edit_sessionsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    system?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    tag_filter?: NullableJsonNullValueInput | InputJsonValue
    priority_filter?: NullableStringFieldUpdateOperationsInput | string | null
    change_brief?: StringFieldUpdateOperationsInput | string
    status?: Enumbulk_edit_sessions_statusFieldUpdateOperationsInput | $Enums.bulk_edit_sessions_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_versionsUpdateWithoutUsersInput = {
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_cases?: test_casesUpdateOneRequiredWithoutCase_versionsNestedInput
  }

  export type case_versionsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_versionsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    steps?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type functional_test_casesUpdateWithoutUsersInput = {
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_version?: project_versionsUpdateOneWithoutFunctional_test_casesNestedInput
    requirement_doc?: requirement_documentsUpdateOneWithoutTest_casesNestedInput
    executions?: functional_test_executionsUpdateManyWithoutTest_caseNestedInput
  }

  export type functional_test_casesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: functional_test_executionsUncheckedUpdateManyWithoutTest_caseNestedInput
  }

  export type functional_test_casesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type requirement_documentsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUpdateManyWithoutRequirement_docNestedInput
    ai_session?: ai_generation_sessionsUpdateOneWithoutRequirement_documentsNestedInput
    project?: systemsUpdateOneWithoutRequirement_documentsNestedInput
    project_version?: project_versionsUpdateOneWithoutRequirement_documentsNestedInput
  }

  export type requirement_documentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUncheckedUpdateManyWithoutRequirement_docNestedInput
  }

  export type requirement_documentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_case_executionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    test_cases?: test_casesUpdateOneRequiredWithoutTest_case_executionsNestedInput
  }

  export type test_case_executionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_id?: IntFieldUpdateOperationsInput | number
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_case_executionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_id?: IntFieldUpdateOperationsInput | number
    test_case_title?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    execution_mode?: StringFieldUpdateOperationsInput | string
    status?: Enumtest_case_execution_statusFieldUpdateOperationsInput | $Enums.test_case_execution_status
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    queued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    execution_logs?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_runsUpdateWithoutUsersInput = {
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUpdateManyWithoutTest_runsNestedInput
    reports?: reportsUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUpdateManyWithoutTest_runsNestedInput
    test_suites?: test_suitesUpdateOneRequiredWithoutTest_runsNestedInput
  }

  export type test_runsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    suite_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_runs?: ai_runsUncheckedUpdateManyWithoutTest_runsNestedInput
    reports?: reportsUncheckedUpdateManyWithoutTest_runsNestedInput
    test_run_results?: test_run_resultsUncheckedUpdateManyWithoutTest_runsNestedInput
  }

  export type test_runsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    suite_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtest_runs_statusFieldUpdateOperationsInput | $Enums.test_runs_status
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type test_suitesUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suite_case_map?: suite_case_mapUpdateManyWithoutTest_suitesNestedInput
    test_runs?: test_runsUpdateManyWithoutTest_suitesNestedInput
  }

  export type test_suitesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suite_case_map?: suite_case_mapUncheckedUpdateManyWithoutTest_suitesNestedInput
    test_runs?: test_runsUncheckedUpdateManyWithoutTest_suitesNestedInput
  }

  export type test_suitesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    project?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_rolesUpdateWithoutUsersInput = {
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesUncheckedUpdateManyWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type functional_test_executionsUpdateWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    test_case?: functional_test_casesUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type functional_test_executionsUncheckedUpdateWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_id?: IntFieldUpdateOperationsInput | number
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsUncheckedUpdateManyWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_id?: IntFieldUpdateOperationsInput | number
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plansUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan_cases?: test_plan_casesUpdateManyWithoutPlanNestedInput
    plan_executions?: test_plan_executionsUpdateManyWithoutPlanNestedInput
  }

  export type test_plansUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan_cases?: test_plan_casesUncheckedUpdateManyWithoutPlanNestedInput
    plan_executions?: test_plan_executionsUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type test_plansUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: Enumtest_plan_typeFieldUpdateOperationsInput | $Enums.test_plan_type
    status?: Enumtest_plan_statusFieldUpdateOperationsInput | $Enums.test_plan_status
    members?: NullableJsonNullValueInput | InputJsonValue
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_patch_proposalsCreateManySessionInput = {
    id?: number
    case_id: number
    diff_json: JsonNullValueInput | InputJsonValue
    ai_rationale?: string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: $Enums.proposal_risk_level
    recall_reason?: string | null
    old_hash: string
    new_hash?: string | null
    apply_status?: $Enums.proposal_apply_status
    created_at?: Date | string | null
    applied_at?: Date | string | null
  }

  export type case_patch_proposalsUpdateWithoutSessionInput = {
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_cases?: test_casesUpdateOneRequiredWithoutPatch_proposalsNestedInput
  }

  export type case_patch_proposalsUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_patch_proposalsUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    diff_json?: JsonNullValueInput | InputJsonValue
    ai_rationale?: NullableStringFieldUpdateOperationsInput | string | null
    side_effects?: NullableJsonNullValueInput | InputJsonValue
    risk_level?: Enumproposal_risk_levelFieldUpdateOperationsInput | $Enums.proposal_risk_level
    recall_reason?: NullableStringFieldUpdateOperationsInput | string | null
    old_hash?: StringFieldUpdateOperationsInput | string
    new_hash?: NullableStringFieldUpdateOperationsInput | string | null
    apply_status?: Enumproposal_apply_statusFieldUpdateOperationsInput | $Enums.proposal_apply_status
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type functional_test_executionsCreateManyTest_caseInput = {
    id?: string
    test_case_name: string
    final_result: $Enums.functional_execution_result
    actual_result: string
    comments?: string | null
    duration_ms?: number | null
    executed_at?: Date | string
    executor_id: number
    executor_project?: string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: number
    completed_steps?: number
    passed_steps?: number
    failed_steps?: number
    blocked_steps?: number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsUpdateWithoutTest_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    executor?: usersUpdateOneRequiredWithoutFunctional_test_executionsNestedInput
  }

  export type functional_test_executionsUncheckedUpdateWithoutTest_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type functional_test_executionsUncheckedUpdateManyWithoutTest_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    test_case_name?: StringFieldUpdateOperationsInput | string
    final_result?: Enumfunctional_execution_resultFieldUpdateOperationsInput | $Enums.functional_execution_result
    actual_result?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    executed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_project?: NullableStringFieldUpdateOperationsInput | string | null
    step_results?: NullableJsonNullValueInput | InputJsonValue
    total_steps?: IntFieldUpdateOperationsInput | number
    completed_steps?: IntFieldUpdateOperationsInput | number
    passed_steps?: IntFieldUpdateOperationsInput | number
    failed_steps?: IntFieldUpdateOperationsInput | number
    blocked_steps?: IntFieldUpdateOperationsInput | number
    screenshots?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type requirement_documentsCreateManyAi_sessionInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    project_id?: number | null
    project_version_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
  }

  export type requirement_documentsUpdateWithoutAi_sessionInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUpdateManyWithoutRequirement_docNestedInput
    users?: usersUpdateOneRequiredWithoutRequirement_documentsNestedInput
    project?: systemsUpdateOneWithoutRequirement_documentsNestedInput
    project_version?: project_versionsUpdateOneWithoutRequirement_documentsNestedInput
  }

  export type requirement_documentsUncheckedUpdateWithoutAi_sessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUncheckedUpdateManyWithoutRequirement_docNestedInput
  }

  export type requirement_documentsUncheckedUpdateManyWithoutAi_sessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type functional_test_casesCreateManyRequirement_docInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    creator_id: number
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    project_version_id?: number | null
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    deleted_at?: Date | string | null
  }

  export type functional_test_casesUpdateWithoutRequirement_docInput = {
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutFunctional_test_casesNestedInput
    project_version?: project_versionsUpdateOneWithoutFunctional_test_casesNestedInput
    executions?: functional_test_executionsUpdateManyWithoutTest_caseNestedInput
  }

  export type functional_test_casesUncheckedUpdateWithoutRequirement_docInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: functional_test_executionsUncheckedUpdateManyWithoutTest_caseNestedInput
  }

  export type functional_test_casesUncheckedUpdateManyWithoutRequirement_docInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type project_versionsCreateManyProjectInput = {
    id?: number
    version_name: string
    version_code: string
    description?: string | null
    is_main?: boolean
    status?: $Enums.system_status
    release_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type requirement_documentsCreateManyProjectInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_version_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
  }

  export type project_versionsUpdateWithoutProjectInput = {
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    functional_test_cases?: functional_test_casesUpdateManyWithoutProject_versionNestedInput
    requirement_documents?: requirement_documentsUpdateManyWithoutProject_versionNestedInput
  }

  export type project_versionsUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    functional_test_cases?: functional_test_casesUncheckedUpdateManyWithoutProject_versionNestedInput
    requirement_documents?: requirement_documentsUncheckedUpdateManyWithoutProject_versionNestedInput
  }

  export type project_versionsUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_name?: StringFieldUpdateOperationsInput | string
    version_code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_main?: BoolFieldUpdateOperationsInput | boolean
    status?: Enumsystem_statusFieldUpdateOperationsInput | $Enums.system_status
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requirement_documentsUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUpdateManyWithoutRequirement_docNestedInput
    ai_session?: ai_generation_sessionsUpdateOneWithoutRequirement_documentsNestedInput
    users?: usersUpdateOneRequiredWithoutRequirement_documentsNestedInput
    project_version?: project_versionsUpdateOneWithoutRequirement_documentsNestedInput
  }

  export type requirement_documentsUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUncheckedUpdateManyWithoutRequirement_docNestedInput
  }

  export type requirement_documentsUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_version_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type functional_test_casesCreateManyProject_versionInput = {
    id?: number
    case_id?: string | null
    name: string
    description?: string | null
    system?: string | null
    module?: string | null
    priority?: $Enums.functional_test_priority
    tags?: string | null
    status?: $Enums.functional_test_status
    source?: $Enums.functional_test_source
    ai_session_id?: string | null
    creator_id: number
    test_type?: string | null
    preconditions?: string | null
    test_data?: string | null
    section_id?: string | null
    section_name?: string | null
    scenario_name?: string | null
    scenario_description?: string | null
    batch_number?: number | null
    coverage_areas?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    case_type?: $Enums.functional_case_type
    requirement_source?: string | null
    section_description?: string | null
    expected_result?: string | null
    risk_level?: $Enums.functional_risk_level
    steps?: string | null
    test_point_name?: string | null
    test_purpose?: string | null
    requirement_doc_id?: number | null
    deleted_at?: Date | string | null
  }

  export type requirement_documentsCreateManyProject_versionInput = {
    id?: number
    title: string
    content: string
    summary?: string | null
    source_filename?: string | null
    ai_session_id?: string | null
    project_id?: number | null
    creator_id: number
    scenario_count?: number
    test_case_count?: number
    status?: $Enums.requirement_doc_status
    created_at?: Date | string
    updated_at?: Date | string
    module?: string | null
    system?: string | null
  }

  export type functional_test_casesUpdateWithoutProject_versionInput = {
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutFunctional_test_casesNestedInput
    requirement_doc?: requirement_documentsUpdateOneWithoutTest_casesNestedInput
    executions?: functional_test_executionsUpdateManyWithoutTest_caseNestedInput
  }

  export type functional_test_casesUncheckedUpdateWithoutProject_versionInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: functional_test_executionsUncheckedUpdateManyWithoutTest_caseNestedInput
  }

  export type functional_test_casesUncheckedUpdateManyWithoutProject_versionInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    module?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: Enumfunctional_test_priorityFieldUpdateOperationsInput | $Enums.functional_test_priority
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumfunctional_test_statusFieldUpdateOperationsInput | $Enums.functional_test_status
    source?: Enumfunctional_test_sourceFieldUpdateOperationsInput | $Enums.functional_test_source
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    test_type?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: NullableStringFieldUpdateOperationsInput | string | null
    test_data?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_name?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_description?: NullableStringFieldUpdateOperationsInput | string | null
    batch_number?: NullableIntFieldUpdateOperationsInput | number | null
    coverage_areas?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    case_type?: Enumfunctional_case_typeFieldUpdateOperationsInput | $Enums.functional_case_type
    requirement_source?: NullableStringFieldUpdateOperationsInput | string | null
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    expected_result?: NullableStringFieldUpdateOperationsInput | string | null
    risk_level?: Enumfunctional_risk_levelFieldUpdateOperationsInput | $Enums.functional_risk_level
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    test_point_name?: NullableStringFieldUpdateOperationsInput | string | null
    test_purpose?: NullableStringFieldUpdateOperationsInput | string | null
    requirement_doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type requirement_documentsUpdateWithoutProject_versionInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUpdateManyWithoutRequirement_docNestedInput
    ai_session?: ai_generation_sessionsUpdateOneWithoutRequirement_documentsNestedInput
    users?: usersUpdateOneRequiredWithoutRequirement_documentsNestedInput
    project?: systemsUpdateOneWithoutRequirement_documentsNestedInput
  }

  export type requirement_documentsUncheckedUpdateWithoutProject_versionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    test_cases?: functional_test_casesUncheckedUpdateManyWithoutRequirement_docNestedInput
  }

  export type requirement_documentsUncheckedUpdateManyWithoutProject_versionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    source_filename?: NullableStringFieldUpdateOperationsInput | string | null
    ai_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_id?: IntFieldUpdateOperationsInput | number
    scenario_count?: IntFieldUpdateOperationsInput | number
    test_case_count?: IntFieldUpdateOperationsInput | number
    status?: Enumrequirement_doc_statusFieldUpdateOperationsInput | $Enums.requirement_doc_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_plan_casesCreateManyPlanInput = {
    id?: number
    case_id: number
    case_type: string
    case_name: string
    sort_order?: number
    is_executed?: boolean
    execution_result?: string | null
    created_at?: Date | string
  }

  export type test_plan_executionsCreateManyPlanInput = {
    id?: string
    plan_name: string
    executor_id: number
    executor_name: string
    execution_type: string
    status: string
    progress?: number
    total_cases?: number
    completed_cases?: number
    passed_cases?: number
    failed_cases?: number
    blocked_cases?: number
    skipped_cases?: number
    started_at?: Date | string
    finished_at?: Date | string | null
    duration_ms?: number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_casesUpdateWithoutPlanInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    case_type?: StringFieldUpdateOperationsInput | string
    case_name?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    is_executed?: BoolFieldUpdateOperationsInput | boolean
    execution_result?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_casesUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    case_type?: StringFieldUpdateOperationsInput | string
    case_name?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    is_executed?: BoolFieldUpdateOperationsInput | boolean
    execution_result?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_casesUncheckedUpdateManyWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    case_type?: StringFieldUpdateOperationsInput | string
    case_name?: StringFieldUpdateOperationsInput | string
    sort_order?: IntFieldUpdateOperationsInput | number
    is_executed?: BoolFieldUpdateOperationsInput | boolean
    execution_result?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type test_plan_executionsUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_name?: StringFieldUpdateOperationsInput | string
    execution_type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    total_cases?: IntFieldUpdateOperationsInput | number
    completed_cases?: IntFieldUpdateOperationsInput | number
    passed_cases?: IntFieldUpdateOperationsInput | number
    failed_cases?: IntFieldUpdateOperationsInput | number
    blocked_cases?: IntFieldUpdateOperationsInput | number
    skipped_cases?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_executionsUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_name?: StringFieldUpdateOperationsInput | string
    execution_type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    total_cases?: IntFieldUpdateOperationsInput | number
    completed_cases?: IntFieldUpdateOperationsInput | number
    passed_cases?: IntFieldUpdateOperationsInput | number
    failed_cases?: IntFieldUpdateOperationsInput | number
    blocked_cases?: IntFieldUpdateOperationsInput | number
    skipped_cases?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type test_plan_executionsUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    executor_id?: IntFieldUpdateOperationsInput | number
    executor_name?: StringFieldUpdateOperationsInput | string
    execution_type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    total_cases?: IntFieldUpdateOperationsInput | number
    completed_cases?: IntFieldUpdateOperationsInput | number
    passed_cases?: IntFieldUpdateOperationsInput | number
    failed_cases?: IntFieldUpdateOperationsInput | number
    blocked_cases?: IntFieldUpdateOperationsInput | number
    skipped_cases?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_ms?: NullableIntFieldUpdateOperationsInput | number | null
    execution_results?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}