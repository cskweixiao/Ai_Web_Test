# Ai Web Test - 开源AI测试平台：从Axure原型到自动化执行

大家好，最近在做一个开源的AI测试平台，核心功能是**AI生成测试用例**和**UI自动化执行**。

目前已经在实际项目中使用，效果还不错，分享给大家，欢迎试用和反馈。

---

## 项目背景

传统的测试用例编写和维护成本太高：
- 从Axure原型手写用例，100个用例需要2-3天
- UI自动化脚本需要深入理解Playwright，学习成本高
- 团队测试经验散落在文档里，无法复用

所以做了这个项目，用AI来解决这些问题。

**项目地址**: https://github.com/Ai Web Test/Ai Web Test
**开源协议**: GPL-3.0

---

## 核心功能

### 1. AI测试用例生成

从Axure原型自动生成测试用例，10分钟完成100个用例。

**与市面上工具的差异**：

目前市面上的Dify、Coze等工具，都是通过固定Prompt直接生成用例，存在以下问题：
- 生成的用例格式不统一，无法直接用于自动化执行
- 缺少结构化的拆解过程，生成质量不稳定
- 没有人工审核环节，容易遗漏关键场景
- 生成的用例无法直接落地执行

**Ai Web Test的解决方案**：

采用**分阶段、结构化**的生成流程，每个阶段都有明确的产物和人工审核点：

```
上传Axure原型
    ↓
AI生成文字需求文档（可人工审核）
    ↓
AI预留测试模块（自动拆分）
    ↓
AI生成每个模块的测试目的
    ↓
AI生成每个目的的具体测试用例（JSON格式，可直接执行）
    ↓
RAG向量数据库增强（可选，自动检索测试知识）
```

**关键点**：
- 每一步都由**AI自动生成**，不需要手写
- 只在需求文档阶段需要人工审核（5-10分钟）
- 最后阶段可启用**RAG向量数据库**，自动检索四个维度的测试知识：
  - **业务规则**：常见验证规则（如用户名格式、密码强度）
  - **测试模式**：成熟的测试设计模式（如登录功能完整测试模式）
  - **易错点**：历史缺陷和容易遗漏的场景（如特殊字符处理）
  - **风险场景**：安全和性能相关的高风险测试（如SQL注入、XSS攻击）

---

**详细流程说明**：

**第1步：上传Axure原型**

支持Axure RP 8/9/10导出的HTML文件（最大50MB）。

系统会自动解析：
- 页面结构和层级关系
- 交互逻辑和跳转流程
- 表单元素和按钮
- 文本内容和UI文案

---

**第2步：生成文字需求文档**

AI分析原型后，生成结构化的需求文档，包含：

1. **系统概述**：系统功能和目标用户
2. **功能需求**：详细的功能点描述
3. **页面布局与文案**：UI元素和文案验证点
4. **业务规则**：关键业务逻辑和验证规则
5. **非功能需求**：性能、安全、兼容性

**关键点**：这一步生成的是**纯文字需求**，便于人工审核和补充。

可以直接在线编辑，补充：
- 边界条件（如字符长度限制）
- 异常场景（如网络异常、超时）
- 业务规则（如密码强度要求）

建议花5-10分钟仔细审核，这决定了最终用例的质量。

---

**第3步：预留测试模块（自动拆分）**

系统会根据需求文档，自动拆分为测试模块：

示例（电商系统）：
```
模块1: 用户登录与注册
模块2: 商品浏览与搜索
模块3: 购物车管理
模块4: 订单提交与支付
模块5: 页面布局与文案校验
```

每个模块包含8-15个功能点，避免单次AI调用过大。

---

**第4步：每个模块生成测试目的**

针对每个模块，AI会先生成测试目的，明确测试范围：

示例（模块1: 用户登录与注册）：
```
测试目的1: 验证用户正常登录流程
测试目的2: 验证登录异常场景（错误密码、空用户名等）
测试目的3: 验证用户注册功能
测试目的4: 验证密码重置功能
测试目的5: 验证"记住我"功能
测试目的6: 验证账号锁定机制
```

---

**第5步：每个目的生成具体测试用例**

针对每个测试目的，AI生成具体的测试用例，**格式为JSON**，可直接用于自动化执行。

示例：

```json
{
  "name": "测试用户登录-正常流程",
  "module": "用户登录与注册",
  "purpose": "验证用户正常登录流程",
  "priority": "high",
  "precondition": "用户已注册",
  "steps": [
    {
      "action": "navigate",
      "params": {"url": "http://test.example.com/login"},
      "description": "导航到登录页"
    },
    {
      "action": "fill",
      "params": {"selector": "#username", "value": "admin"},
      "description": "输入用户名"
    },
    {
      "action": "fill",
      "params": {"selector": "#password", "value": "admin123"},
      "description": "输入密码"
    },
    {
      "action": "click",
      "params": {"selector": "#login-btn"},
      "description": "点击登录按钮"
    },
    {
      "action": "expect",
      "params": {
        "selector": ".success-msg",
        "condition": "toBeVisible",
        "value": "登录成功"
      },
      "description": "验证登录成功"
    }
  ],
  "tags": ["登录", "认证", "核心流程"]
}
```

**关键点**：
- 每个步骤包含明确的`action`（操作类型）
- `params`包含具体参数（选择器、值等）
- 格式统一，可直接导入Playwright执行
- 包含断言验证（`expect`操作）

---

**第6步：RAG向量数据库增强（可选）**

这是Ai Web Test的核心优势之一。在生成测试用例时，系统会调用**Qdrant向量数据库**，自动检索四个维度的测试知识。

**四个维度**：

| 维度 | 说明 | 示例 |
|------|------|------|
| **业务规则** | 常见验证规则 | 用户名4-20字符，支持字母数字下划线 |
| **测试模式** | 成熟测试设计模式 | 登录功能完整测试模式（正常+异常+边界） |
| **易错点** | 历史缺陷和易遗漏场景 | 特殊字符导致登录失败 |
| **风险场景** | 安全和性能相关测试 | SQL注入、XSS攻击、并发压力 |

**工作原理**：

```
用户需求关键词（如"用户登录"）
    ↓
转换为768维向量
    ↓
在Qdrant向量数据库中相似度检索
    ↓
检索到相关知识（四个维度）：
  ✓ 业务规则: 用户名格式验证规则
  ✓ 测试模式: 登录功能完整测试模式
  ✓ 易错点: 特殊字符导致登录失败
  ✓ 风险场景: SQL注入风险测试
    ↓
合并到AI提示词中
    ↓
生成更高质量的测试用例
```

**效果提升**：
- 测试覆盖率提升：+15-25%
- 边界值覆盖提升：+40-55%
- 异常场景覆盖提升：+30-40%
- 专业准确性提升：+15-20%

**示例**：

假设团队之前遇到过"特殊字符导致登录失败"的缺陷，并录入到知识库。

下次生成登录测试用例时，系统会自动检索到这条知识，并在用例中补充特殊字符测试场景：

```json
{
  "name": "测试用户登录-特殊字符处理",
  "purpose": "验证登录对特殊字符的处理",
  "steps": [
    {
      "action": "fill",
      "params": {"selector": "#username", "value": "test'user"},
      "description": "输入包含单引号的用户名"
    },
    {
      "action": "click",
      "params": {"selector": "#login-btn"},
      "description": "点击登录"
    },
    {
      "action": "expect",
      "params": {"selector": ".error-msg", "condition": "toContainText", "value": "用户名格式错误"},
      "description": "验证系统正确处理特殊字符"
    }
  ]
}
```

这样团队的测试经验就可以**持续积累和复用**，避免重复踩坑。

---

**实际效果**：

最近用它生成了一个电商系统的测试用例：
- Axure原型：23页，156个交互
- 生成耗时：10分钟
- 生成用例：87个
- 质量评分：平均91/100

**流程耗时分解**：
- 上传原型并解析：20秒
- 生成需求文档：40秒
- 人工审核需求：5分钟
- 拆分模块并生成测试目的：10秒
- 批量生成用例（5个模块）：2分30秒
- 预览和保存：30秒

**总计**：约10分钟

**【截图1: AI生成器界面 - 上传Axure原型】**

*(这里插入上传Axure原型的截图)*

---

**【截图2: 需求文档生成结果】**

AI自动提取了以下内容：
- 系统功能概述
- 详细功能需求
- 页面布局和文案校验点
- 业务规则和验证逻辑

*(这里插入需求文档的截图)*

可以直接在线编辑，补充边界条件和异常场景。

---

**【截图3: 批量生成测试用例】**

系统会自动拆分批次，逐批生成：

```
批次1: 用户登录注册 (12个用例)
批次2: 商品浏览搜索 (18个用例)
批次3: 购物车管理 (16个用例)
批次4: 订单支付 (25个用例)
批次5: UI/文案验证 (16个用例)
```

*(这里插入批次生成进度的截图)*

---

**【截图4: 生成的测试用例预览】**

每个用例包含：
- 用例名称、优先级、质量评分
- 前置条件
- 测试步骤（JSON格式，可直接用于自动化）
- 预期结果
- 标签分类

*(这里插入用例卡片的截图)*

用例格式示例：

```json
{
  "name": "测试用户登录-正常流程",
  "priority": "high",
  "steps": [
    {
      "action": "navigate",
      "params": {"url": "http://test.example.com/login"},
      "description": "导航到登录页"
    },
    {
      "action": "fill",
      "params": {"selector": "#username", "value": "admin"},
      "description": "输入用户名"
    },
    {
      "action": "click",
      "params": {"selector": "#login-btn"},
      "description": "点击登录按钮"
    },
    {
      "action": "expect",
      "params": {
        "selector": ".success-msg",
        "condition": "toBeVisible"
      },
      "description": "验证登录成功"
    }
  ]
}
```

---

### 2. UI自动化测试执行

基于Playwright的浏览器自动化，**零代码执行JSON格式的测试用例**。

**与传统Playwright脚本的差异**：

传统方式需要编写Playwright代码：
```javascript
// 传统方式：需要写代码
const { test } = require('@playwright/test');
test('登录测试', async ({ page }) => {
  await page.goto('http://test.example.com/login');
  await page.fill('#username', 'admin');
  await page.fill('#password', 'admin123');
  await page.click('#login-btn');
  await expect(page.locator('.success-msg')).toBeVisible();
});
```

**Ai Web Test的解决方案**：

只需要JSON格式的测试用例，系统自动转换为Playwright操作并执行：
```json
{
  "steps": [
    {"action": "navigate", "params": {"url": "http://test.example.com/login"}},
    {"action": "fill", "params": {"selector": "#username", "value": "admin"}},
    {"action": "fill", "params": {"selector": "#password", "value": "admin123"}},
    {"action": "click", "params": {"selector": "#login-btn"}},
    {"action": "expect", "params": {"selector": ".success-msg", "condition": "toBeVisible"}}
  ]
}
```

**技术架构流程**：

```
前端Web界面
    ↓
选择测试用例（单个或批量）
    ↓
后端接收请求 → 队列管理器（并发控制）
    ↓
Playwright执行引擎（解析JSON → 转换为浏览器操作）
    ↓
浏览器实例（Chromium/Firefox/WebKit）
    ↓
执行每一步操作 + 自动截图
    ↓
WebSocket实时推送状态到前端
    ↓
收集执行证据（截图、日志、视频）
```

---

**详细执行流程**：

**第1步：队列管理与并发控制**

系统使用队列管理器调度测试执行：
- 支持并发执行3-12个用例（可配置）
- 自动分配浏览器实例
- 失败重试机制（可配置0-2次）

工作原理：
```
待执行队列：[用例1, 用例2, 用例3, ..., 用例50]
    ↓
并发槽位：[槽位1, 槽位2, 槽位3, 槽位4] （假设并发数=4）
    ↓
槽位1: 用例1 → 执行中 → 完成 → 自动取用例5
槽位2: 用例2 → 执行中 → 失败 → 重试 → 完成 → 自动取用例6
槽位3: 用例3 → 执行中 → 完成 → 自动取用例7
槽位4: 用例4 → 执行中 → 完成 → 自动取用例8
```

**第2步：JSON解析与Playwright转换**

系统会自动将JSON步骤转换为Playwright操作：

| JSON操作 | Playwright转换 | 说明 |
|---------|---------------|------|
| `{"action": "navigate"}` | `await page.goto(url)` | 导航到URL |
| `{"action": "fill"}` | `await page.fill(selector, value)` | 填充表单 |
| `{"action": "click"}` | `await page.click(selector)` | 点击元素 |
| `{"action": "select"}` | `await page.selectOption(selector, value)` | 选择下拉 |
| `{"action": "wait"}` | `await page.waitForTimeout(ms)` | 等待时间 |
| `{"action": "expect"}` | `await expect(locator).toBeVisible()` | 断言验证 |

**关键点**：测试人员**不需要写任何Playwright代码**，只需要JSON格式的测试用例（由AI生成或手动编写）。

**第3步：WebSocket实时状态推送**

执行过程中，系统通过WebSocket实时推送状态到前端界面：

```
执行开始
    ↓ WebSocket推送
前端显示："测试用例1 - 执行中"
    ↓
每步执行完成
    ↓ WebSocket推送
前端显示："步骤1/5 - 导航到登录页 - 成功（2.3秒）"
    ↓
每步执行完成
    ↓ WebSocket推送
前端显示："步骤2/5 - 输入用户名 - 成功（0.5秒）"
    ↓
...
    ↓
执行完成
    ↓ WebSocket推送
前端显示："测试用例1 - 通过（总耗时8.5秒）"
```

**实时监控内容**：
- 当前执行步骤进度（如：3/5步）
- 每步执行结果（成功/失败）
- 每步执行耗时
- 实时日志输出
- 浏览器实时画面（视频流）

**第4步：自动化证据收集**

系统在执行过程中自动收集多种证据：

1. **每步自动截图**
   - 每执行一步操作后自动截图
   - 文件命名：`step-1-navigate.png`、`step-2-fill-username.png`
   - 失败时额外保存错误截图：`error-step-3.png`

2. **完整执行日志**
   ```
   [2025-01-14 14:30:15] 开始执行测试：测试用户登录-正常流程
   [2025-01-14 14:30:16] 步骤1：导航到登录页 - 成功（2.3秒）
   [2025-01-14 14:30:18] 步骤2：输入用户名 - 成功（0.5秒）
   [2025-01-14 14:30:19] 步骤3：输入密码 - 成功（0.4秒）
   [2025-01-14 14:30:21] 步骤4：点击登录按钮 - 成功（1.2秒）
   [2025-01-14 14:30:23] 步骤5：验证登录成功 - 成功（0.8秒）
   [2025-01-14 14:30:23] 测试完成 - 通过（总耗时8.5秒）
   ```

3. **视频录制**（可选）
   - 完整记录浏览器操作过程
   - 失败时自动保留视频

4. **批量下载**
   - 支持一键下载所有证据（截图+日志）
   - ZIP格式打包

---

**【截图5：测试执行监控界面】**

执行时可以看到：
- 实时进度（已完成/执行中/等待中）
- 每步的执行结果和耗时
- 实时日志输出
- 并发执行的多个用例状态

*(这里插入执行监控面板的截图)*

---

**【截图6：实时画面监控】**

执行过程中可以看到浏览器实时画面（支持近全屏查看）。

这是通过WebSocket视频流实现的，可以实时看到：
- 页面导航过程
- 表单填充过程
- 按钮点击效果
- 页面跳转和响应

*(这里插入实时视频流的截图)*

---

**【截图7：测试证据收集】**

每步自动截图，失败时额外保存错误截图。

证据包含：
- 每步操作截图（PNG格式）
- 完整执行日志（TXT格式）
- 失败错误截图（PNG格式）
- 执行视频（可选，MP4格式）

支持批量下载所有证据。

*(这里插入测试证据列表的截图)*

---

**【截图8：批量执行测试套件】**

可以创建测试套件，批量执行多个用例：

```
套件名称：用户登录注册回归测试
总用例数：15个
并发数：4
失败策略：继续执行（或遇到失败立即停止）

执行结果：
  - 已通过：10个
  - 已失败：2个
  - 执行中：3个
  - 总耗时：00:08:45
```

系统会自动调度并发执行，实时更新每个用例的状态。

*(这里插入套件执行的截图)*

---

**支持的操作类型**：

Ai Web Test支持以下JSON操作类型（完整的Playwright操作覆盖）：

| 操作类型 | 说明 | 参数示例 |
|---------|------|---------|
| `navigate` | 导航到URL | `{"url": "http://example.com"}` |
| `fill` | 填充输入框 | `{"selector": "#username", "value": "admin"}` |
| `click` | 点击元素 | `{"selector": "#login-btn"}` |
| `select` | 选择下拉选项 | `{"selector": "#country", "value": "China"}` |
| `hover` | 鼠标悬停 | `{"selector": ".menu-item"}` |
| `wait` | 等待时间 | `{"timeout": 2000}` |
| `screenshot` | 手动截图 | `{"filename": "custom.png"}` |
| `expect` | 断言验证 | `{"selector": ".msg", "condition": "toBeVisible"}` |

**断言条件**：

| 条件 | 说明 |
|------|------|
| `toBeVisible` | 元素可见 |
| `toHaveText` | 包含文本 |
| `toHaveValue` | 输入框值匹配 |
| `toBeChecked` | 复选框选中 |
| `toHaveURL` | URL匹配 |
| `toContainText` | 包含部分文本 |

---

**实际执行示例**：

假设有以下JSON测试用例：

```json
{
  "name": "测试用户登录-正常流程",
  "steps": [
    {"action": "navigate", "params": {"url": "http://test.example.com/login"}, "description": "导航到登录页"},
    {"action": "fill", "params": {"selector": "#username", "value": "admin"}, "description": "输入用户名"},
    {"action": "fill", "params": {"selector": "#password", "value": "admin123"}, "description": "输入密码"},
    {"action": "click", "params": {"selector": "#login-btn"}, "description": "点击登录按钮"},
    {"action": "expect", "params": {"selector": ".success-msg", "condition": "toBeVisible"}, "description": "验证登录成功"}
  ]
}
```

**执行过程**：

1. 系统解析JSON → 创建Playwright浏览器实例
2. 执行步骤1：导航到登录页 → 自动截图 → WebSocket推送状态
3. 执行步骤2：输入用户名 → 自动截图 → WebSocket推送状态
4. 执行步骤3：输入密码 → 自动截图 → WebSocket推送状态
5. 执行步骤4：点击登录按钮 → 自动截图 → WebSocket推送状态
6. 执行步骤5：验证登录成功 → 自动截图 → WebSocket推送状态
7. 测试完成 → 收集所有证据 → 关闭浏览器

**前端实时显示**：

```
测试名称：测试用户登录-正常流程
执行状态：运行中
进度：3/5（60%）
已通过：3步
已失败：0步
执行时间：00:01:23

执行日志：
[14:30:15] 开始执行测试...
[14:30:16] 步骤1：导航到登录页 - 成功（2.3秒）
[14:30:18] 步骤2：输入用户名 - 成功（0.5秒）
[14:30:19] 步骤3：输入密码 - 成功（0.4秒）
[14:30:21] 步骤4：点击登录按钮 - 执行中...
```

**总结**：

Ai Web Test的UI自动化执行核心优势：
- **零代码**：只需JSON格式测试用例，不需要写Playwright代码
- **实时监控**：WebSocket推送执行状态，可看到浏览器实时画面
- **自动化证据**：每步自动截图，完整日志，支持视频录制
- **并发执行**：支持多个用例同时执行，大幅提升效率
- **失败重试**：自动重试机制，减少偶发性失败
- **完整覆盖**：支持所有常见的Playwright操作类型

---

### 3. RAG知识库（可选功能）

这是一个进阶功能，用Qdrant向量数据库存储测试知识。

AI生成用例时会自动检索相关知识，质量提升明显：
- 测试覆盖率提升15-25%
- 边界值覆盖提升40-55%
- 异常场景覆盖提升30-40%

**【截图9: 知识库管理界面】**

*(这里插入知识库列表的截图)*

**四个维度的测试知识**：

1. **业务规则**：常见验证规则
   - 示例：用户名4-20字符，支持字母数字下划线
   - 示例：密码至少8位，必须包含字母和数字

2. **测试模式**：成熟的测试设计模式
   - 示例：登录功能完整测试模式（正常+异常+边界）
   - 示例：表单验证完整测试模式

3. **易错点**：历史缺陷和容易遗漏的场景
   - 示例：特殊字符导致登录失败
   - 示例：空格前后缀导致查询失败

4. **风险场景**：安全和性能相关的高风险测试
   - 示例：SQL注入风险测试
   - 示例：XSS攻击风险测试
   - 示例：并发压力测试

---

## 真实使用效果

### 案例1: 某电商项目

**项目背景**：
- 电商平台重构
- Axure原型：45页，320个交互

**传统方式**：
- 2个测试工程师，4天
- 生成180个用例
- 质量评分：平均78分

**使用Ai Web Test**：
- 1个测试工程师，AI生成25分钟，人工审核2小时
- 生成215个用例
- 质量评分：平均89分

**效果**：
- 时间节省93%
- 成本节省87%
- 质量提升14%

---

### 案例2: 某金融项目回归测试

**项目背景**：
- 在线贷款系统回归测试
- 120个测试用例

**传统方式**：
- 3人手动执行，2天
- 6人天

**使用Ai Web Test**：
- 自动化执行（并发6个），3小时
- 1人监控

**效果**：
- 时间节省92%
- 成本节省96%
- 自动收集720张截图

---

## 技术架构

**前端**：
- React 18 + TypeScript
- Tailwind CSS
- WebSocket实时通信

**后端**：
- Node.js + Express
- Prisma ORM + MySQL
- WebSocket服务

**AI引擎**：
- 支持OpenRouter / DeepSeek / Claude / Gemini
- RAG: Qdrant向量数据库
- MCP协议标准化集成

**测试执行**：
- Playwright浏览器自动化
- 队列管理器（并发控制）
- 自动截图和日志收集

---

## 快速开始

### 安装

```bash
# 克隆项目
git clone https://github.com/Ai Web Test/Ai Web Test.git
cd Ai Web Test

# 安装依赖
npm install

# 配置环境变量
cp .env.example .env
# 编辑.env，配置数据库和AI模型

# 初始化数据库
npx prisma migrate dev
npx prisma db seed

# 启动服务
npm run dev
```

### 访问

- 前端: http://localhost:5173
- 后端: http://localhost:3001
- 默认账号: admin / admin123

### AI模型配置

在`.env`中配置（支持4种AI模型）：

```bash
# 推荐使用DeepSeek（性价比高）
AI_MODEL_PROVIDER=deepseek
DEEPSEEK_API_KEY=sk-your-key
DEEPSEEK_MODEL=deepseek-chat
```

其他支持的模型：
- OpenRouter（支持GPT-4o/DeepSeek/Claude）
- Anthropic（Claude）
- 本地Gemini

---

## 后续计划

近期会更新：
- 支持更多原型工具（Figma、墨刀）
- 测试报告可视化
- API自动化测试
- 移动端自动化（Appium）

---

## 欢迎试用和反馈

**项目地址**: https://github.com/Ai Web Test/Ai Web Test

目前已经在实际项目中使用，效果还不错。欢迎大家试用，有任何问题或建议都可以提Issue或者回复讨论。

如果觉得有帮助，欢迎给项目一个Star支持！

---

**开源协议**: GPL-3.0
**联系方式**: support@Ai Web Test.dev
